// Code generated from swiftgrammar.g4 by ANTLR 4.13.0. DO NOT EDIT.

package parser // swiftgrammar

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

import arrayList "github.com/colegno/arraylist"
import "Servidor1/interfaces"
import "Servidor1/expresion"
import "Servidor1/instructionExpre"
import "Servidor1/instruction"

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type swiftgrammar struct {
	*antlr.BaseParser
}

var SwiftgrammarParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func swiftgrammarParserInit() {
	staticData := &SwiftgrammarParserStaticData
	staticData.LiteralNames = []string{
		"", "'print'", "'Int'", "'Float'", "'String'", "'Bool'", "' String'",
		"'Character'", "'array'", "'Vector'", "'usize'", "'if'", "'else'", "'while'",
		"'for'", "'in'", "'break'", "'continue'", "'switch'", "'|'", "'case'",
		"'default'", "'true'", "'false'", "'as'", "'at'", "'let'", "'var'",
		"'struct'", "'count'", "'new()'", "'capacity()'", "'append'", "'insert'",
		"'remove'", "'mod'", "'->'", "'func'", "'return'", "", "", "", "'.'",
		"','", "';'", "'::'", "':'", "'='", "'=>'", "'_'", "", "'!='", "'=='",
		"'>='", "'<='", "'>'", "'<'", "'+='", "'*'", "'/'", "'+'", "'-'", "'%'",
		"'&&'", "'||'", "'!'", "'?'", "'&'", "'inout'", "'('", "')'", "'{'",
		"'}'", "'['", "']'",
	}
	staticData.SymbolicNames = []string{
		"", "PRINT_CON", "T_NUMBER", "T_FLOAT", "T_STRING", "T_BOOL", "T_STR",
		"T_CHAT", "T_ARRAY", "T_VECTOR", "USIZE", "IF", "ELSE", "WHILE", "FOR",
		"IN", "BREAK", "CONTINUE", "SWITCH", "MTOR", "CASE", "DEFAULT", "TRUE",
		"FALSE", "AS", "AT", "LET", "MUT", "STRUCT", "COUNT", "NEW", "CAPF",
		"APPEND", "INSERT", "REMOVE", "MODULO", "TYPETHEN", "FN", "RETURN",
		"NUMBER", "FLOAT", "STRING", "PUNTO", "COMA", "PTCOMA", "DOSPUNTO",
		"DPUNTO2", "ASIGNACION", "MTHEN", "GUIONB", "ID", "DISTINTO", "IGUAL",
		"MAYORIGUAL", "MENORIGUAL", "MAYOR", "MENOR", "ASIG", "MUL", "DIV",
		"ADD", "SUB", "MOD", "AND", "OR", "NOT", "INTERROG", "AMP", "INOUT",
		"PARIZQ", "PARDER", "LLAVEIZQ", "LLAVEDER", "CORIZQ", "CORDER", "CHAR",
		"WHITESPACE", "L_COMMENT", "COMMENT",
	}
	staticData.RuleNames = []string{
		"start", "instrucciones", "listaglobal", "in_global", "modulo_item",
		"funcion", "params_declar", "declar_parametros", "fn_main", "instruccion",
		"instruccion_dentro", "appendVec", "newStruct", "lista_struct", "callFunction",
		"returnFun", "printconsola", "while_true", "lWhile", "lForin", "lBreak",
		"lContinue", "listParams", "listParamsCall", "es_referencia", "declaracion",
		"es_var", "es_varr", "letid", "vector_types", "array_type", "asignacion",
		"l_AccessStruct", "list_index", "index_array", "if_sent", "if_exp",
		"list_elseif", "list_elseif_exp", "else_if", "else_if_exp", "switch_sent",
		"match_brazos", "match_brazos_exp", "matchbrazo", "matchbrazo_exp",
		"listaOpciones", "bloque_inst", "bloque_princip", "bloque_exp", "tipos_var",
		"expression", "expr_arit", "casteo", "tipo_cast", "l_StructExp", "primitivo",
		"listIDArray", "strings",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 78, 1216, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 1, 0, 1, 0, 1, 0, 1, 1, 5, 1, 123, 8, 1, 10, 1, 12, 1, 126,
		9, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 5, 2,
		138, 8, 2, 10, 2, 12, 2, 141, 9, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		3, 3, 149, 8, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 157, 8, 4, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 215, 8, 5, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 5, 6, 226, 8, 6, 10, 6, 12,
		6, 229, 9, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1,
		7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1,
		7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1,
		7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 273, 8, 7, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
		9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
		9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
		9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
		9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 331, 8, 9, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 3, 10, 380, 8, 10, 1, 11, 1, 11, 1, 11, 1, 11,
		1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 3, 11, 400, 8, 11, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 432, 8, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 5, 13, 460, 8, 13, 10, 13, 12, 13, 463, 9, 13, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 475,
		8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 483, 8, 15, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 514, 8, 20,
		1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1,
		22, 1, 22, 5, 22, 528, 8, 22, 10, 22, 12, 22, 531, 9, 22, 1, 23, 1, 23,
		1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 5, 23, 544,
		8, 23, 10, 23, 12, 23, 547, 9, 23, 1, 24, 1, 24, 1, 24, 3, 24, 552, 8,
		24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25,
		1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1,
		25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25,
		1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1,
		25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25,
		1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1,
		25, 3, 25, 617, 8, 25, 1, 26, 1, 26, 1, 26, 3, 26, 622, 8, 26, 1, 27, 1,
		27, 1, 27, 1, 27, 3, 27, 628, 8, 27, 1, 28, 1, 28, 1, 28, 3, 28, 633, 8,
		28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29,
		3, 29, 645, 8, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 3, 30, 666, 8, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1,
		31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31,
		1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1,
		31, 1, 31, 1, 31, 1, 31, 3, 31, 699, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32,
		1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 709, 8, 32, 10, 32, 12, 32, 712, 9,
		32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 5, 33, 722,
		8, 33, 10, 33, 12, 33, 725, 9, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1,
		35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 758, 8, 35, 1, 36, 1, 36, 1, 36,
		1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1,
		36, 1, 36, 3, 36, 775, 8, 36, 1, 37, 4, 37, 778, 8, 37, 11, 37, 12, 37,
		779, 1, 37, 1, 37, 1, 38, 4, 38, 785, 8, 38, 11, 38, 12, 38, 786, 1, 38,
		1, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1,
		40, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 847, 8, 41, 1, 42, 1, 42, 1, 42,
		1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 5, 42, 857, 8, 42, 10, 42, 12, 42, 860,
		9, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 5, 43, 870,
		8, 43, 10, 43, 12, 43, 873, 9, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1,
		44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 887, 8, 44, 1, 45,
		1, 45, 1, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 5, 46, 903, 8, 46, 10, 46, 12, 46, 906, 9, 46, 1, 47,
		1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 916, 8, 47, 1,
		48, 1, 48, 1, 48, 1, 48, 3, 48, 922, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 50, 1, 50, 5, 50, 931, 8, 50, 10, 50, 12, 50, 934, 9, 50, 1,
		50, 1, 50, 1, 50, 5, 50, 939, 8, 50, 10, 50, 12, 50, 942, 9, 50, 1, 50,
		1, 50, 1, 50, 5, 50, 947, 8, 50, 10, 50, 12, 50, 950, 9, 50, 1, 50, 1,
		50, 1, 50, 5, 50, 955, 8, 50, 10, 50, 12, 50, 958, 9, 50, 1, 50, 1, 50,
		1, 50, 5, 50, 963, 8, 50, 10, 50, 12, 50, 966, 9, 50, 1, 50, 1, 50, 1,
		50, 5, 50, 971, 8, 50, 10, 50, 12, 50, 974, 9, 50, 1, 50, 1, 50, 1, 50,
		5, 50, 979, 8, 50, 10, 50, 12, 50, 982, 9, 50, 1, 50, 1, 50, 1, 50, 5,
		50, 987, 8, 50, 10, 50, 12, 50, 990, 9, 50, 1, 50, 1, 50, 1, 50, 5, 50,
		995, 8, 50, 10, 50, 12, 50, 998, 9, 50, 1, 50, 3, 50, 1001, 8, 50, 1, 51,
		1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 5,
		51, 1014, 8, 51, 10, 51, 12, 51, 1017, 9, 51, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1091, 8, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 5, 52, 1122, 8, 52, 10, 52, 12,
		52, 1125, 9, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54,
		1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1140, 8, 54, 1, 55, 1, 55, 1,
		55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55,
		5, 55, 1155, 8, 55, 10, 55, 12, 55, 1158, 9, 55, 1, 56, 1, 56, 1, 56, 1,
		56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 3, 56, 1176, 8, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 5, 57, 1192,
		8, 57, 10, 57, 12, 57, 1195, 9, 57, 1, 58, 4, 58, 1198, 8, 58, 11, 58,
		12, 58, 1199, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 1, 58, 3, 58, 1214, 8, 58, 1, 58, 0, 14, 4, 12, 26, 44,
		46, 64, 66, 84, 86, 92, 102, 104, 110, 114, 59, 0, 2, 4, 6, 8, 10, 12,
		14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
		50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84,
		86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,
		0, 3, 2, 0, 58, 59, 62, 62, 1, 0, 60, 61, 1, 0, 51, 56, 1300, 0, 118, 1,
		0, 0, 0, 2, 124, 1, 0, 0, 0, 4, 129, 1, 0, 0, 0, 6, 148, 1, 0, 0, 0, 8,
		156, 1, 0, 0, 0, 10, 214, 1, 0, 0, 0, 12, 216, 1, 0, 0, 0, 14, 272, 1,
		0, 0, 0, 16, 274, 1, 0, 0, 0, 18, 330, 1, 0, 0, 0, 20, 379, 1, 0, 0, 0,
		22, 399, 1, 0, 0, 0, 24, 401, 1, 0, 0, 0, 26, 431, 1, 0, 0, 0, 28, 474,
		1, 0, 0, 0, 30, 482, 1, 0, 0, 0, 32, 484, 1, 0, 0, 0, 34, 490, 1, 0, 0,
		0, 36, 495, 1, 0, 0, 0, 38, 500, 1, 0, 0, 0, 40, 513, 1, 0, 0, 0, 42, 515,
		1, 0, 0, 0, 44, 518, 1, 0, 0, 0, 46, 532, 1, 0, 0, 0, 48, 551, 1, 0, 0,
		0, 50, 616, 1, 0, 0, 0, 52, 621, 1, 0, 0, 0, 54, 627, 1, 0, 0, 0, 56, 632,
		1, 0, 0, 0, 58, 644, 1, 0, 0, 0, 60, 665, 1, 0, 0, 0, 62, 698, 1, 0, 0,
		0, 64, 700, 1, 0, 0, 0, 66, 713, 1, 0, 0, 0, 68, 726, 1, 0, 0, 0, 70, 757,
		1, 0, 0, 0, 72, 774, 1, 0, 0, 0, 74, 777, 1, 0, 0, 0, 76, 784, 1, 0, 0,
		0, 78, 790, 1, 0, 0, 0, 80, 796, 1, 0, 0, 0, 82, 846, 1, 0, 0, 0, 84, 848,
		1, 0, 0, 0, 86, 861, 1, 0, 0, 0, 88, 886, 1, 0, 0, 0, 90, 888, 1, 0, 0,
		0, 92, 893, 1, 0, 0, 0, 94, 915, 1, 0, 0, 0, 96, 921, 1, 0, 0, 0, 98, 923,
		1, 0, 0, 0, 100, 1000, 1, 0, 0, 0, 102, 1002, 1, 0, 0, 0, 104, 1090, 1,
		0, 0, 0, 106, 1126, 1, 0, 0, 0, 108, 1139, 1, 0, 0, 0, 110, 1141, 1, 0,
		0, 0, 112, 1175, 1, 0, 0, 0, 114, 1177, 1, 0, 0, 0, 116, 1213, 1, 0, 0,
		0, 118, 119, 3, 4, 2, 0, 119, 120, 6, 0, -1, 0, 120, 1, 1, 0, 0, 0, 121,
		123, 3, 18, 9, 0, 122, 121, 1, 0, 0, 0, 123, 126, 1, 0, 0, 0, 124, 122,
		1, 0, 0, 0, 124, 125, 1, 0, 0, 0, 125, 127, 1, 0, 0, 0, 126, 124, 1, 0,
		0, 0, 127, 128, 6, 1, -1, 0, 128, 3, 1, 0, 0, 0, 129, 130, 6, 2, -1, 0,
		130, 131, 3, 6, 3, 0, 131, 132, 6, 2, -1, 0, 132, 139, 1, 0, 0, 0, 133,
		134, 10, 2, 0, 0, 134, 135, 3, 6, 3, 0, 135, 136, 6, 2, -1, 0, 136, 138,
		1, 0, 0, 0, 137, 133, 1, 0, 0, 0, 138, 141, 1, 0, 0, 0, 139, 137, 1, 0,
		0, 0, 139, 140, 1, 0, 0, 0, 140, 5, 1, 0, 0, 0, 141, 139, 1, 0, 0, 0, 142,
		143, 3, 10, 5, 0, 143, 144, 6, 3, -1, 0, 144, 149, 1, 0, 0, 0, 145, 146,
		3, 24, 12, 0, 146, 147, 6, 3, -1, 0, 147, 149, 1, 0, 0, 0, 148, 142, 1,
		0, 0, 0, 148, 145, 1, 0, 0, 0, 149, 7, 1, 0, 0, 0, 150, 151, 3, 10, 5,
		0, 151, 152, 6, 4, -1, 0, 152, 157, 1, 0, 0, 0, 153, 154, 3, 24, 12, 0,
		154, 155, 6, 4, -1, 0, 155, 157, 1, 0, 0, 0, 156, 150, 1, 0, 0, 0, 156,
		153, 1, 0, 0, 0, 157, 9, 1, 0, 0, 0, 158, 159, 3, 16, 8, 0, 159, 160, 6,
		5, -1, 0, 160, 215, 1, 0, 0, 0, 161, 162, 5, 37, 0, 0, 162, 163, 5, 50,
		0, 0, 163, 164, 5, 69, 0, 0, 164, 165, 5, 70, 0, 0, 165, 166, 5, 36, 0,
		0, 166, 167, 3, 100, 50, 0, 167, 168, 3, 94, 47, 0, 168, 169, 6, 5, -1,
		0, 169, 215, 1, 0, 0, 0, 170, 171, 5, 37, 0, 0, 171, 172, 5, 50, 0, 0,
		172, 173, 5, 69, 0, 0, 173, 174, 5, 70, 0, 0, 174, 175, 5, 36, 0, 0, 175,
		176, 5, 50, 0, 0, 176, 177, 3, 94, 47, 0, 177, 178, 6, 5, -1, 0, 178, 215,
		1, 0, 0, 0, 179, 180, 5, 37, 0, 0, 180, 181, 5, 50, 0, 0, 181, 182, 5,
		69, 0, 0, 182, 183, 5, 70, 0, 0, 183, 184, 3, 94, 47, 0, 184, 185, 6, 5,
		-1, 0, 185, 215, 1, 0, 0, 0, 186, 187, 5, 37, 0, 0, 187, 188, 5, 50, 0,
		0, 188, 189, 5, 69, 0, 0, 189, 190, 3, 12, 6, 0, 190, 191, 5, 70, 0, 0,
		191, 192, 3, 94, 47, 0, 192, 193, 6, 5, -1, 0, 193, 215, 1, 0, 0, 0, 194,
		195, 5, 37, 0, 0, 195, 196, 5, 50, 0, 0, 196, 197, 5, 69, 0, 0, 197, 198,
		3, 12, 6, 0, 198, 199, 5, 70, 0, 0, 199, 200, 5, 36, 0, 0, 200, 201, 3,
		100, 50, 0, 201, 202, 3, 94, 47, 0, 202, 203, 6, 5, -1, 0, 203, 215, 1,
		0, 0, 0, 204, 205, 5, 37, 0, 0, 205, 206, 5, 50, 0, 0, 206, 207, 5, 69,
		0, 0, 207, 208, 3, 12, 6, 0, 208, 209, 5, 70, 0, 0, 209, 210, 5, 36, 0,
		0, 210, 211, 5, 50, 0, 0, 211, 212, 3, 94, 47, 0, 212, 213, 6, 5, -1, 0,
		213, 215, 1, 0, 0, 0, 214, 158, 1, 0, 0, 0, 214, 161, 1, 0, 0, 0, 214,
		170, 1, 0, 0, 0, 214, 179, 1, 0, 0, 0, 214, 186, 1, 0, 0, 0, 214, 194,
		1, 0, 0, 0, 214, 204, 1, 0, 0, 0, 215, 11, 1, 0, 0, 0, 216, 217, 6, 6,
		-1, 0, 217, 218, 3, 14, 7, 0, 218, 219, 6, 6, -1, 0, 219, 227, 1, 0, 0,
		0, 220, 221, 10, 2, 0, 0, 221, 222, 5, 43, 0, 0, 222, 223, 3, 14, 7, 0,
		223, 224, 6, 6, -1, 0, 224, 226, 1, 0, 0, 0, 225, 220, 1, 0, 0, 0, 226,
		229, 1, 0, 0, 0, 227, 225, 1, 0, 0, 0, 227, 228, 1, 0, 0, 0, 228, 13, 1,
		0, 0, 0, 229, 227, 1, 0, 0, 0, 230, 231, 3, 52, 26, 0, 231, 232, 5, 50,
		0, 0, 232, 233, 5, 46, 0, 0, 233, 234, 3, 100, 50, 0, 234, 235, 6, 7, -1,
		0, 235, 273, 1, 0, 0, 0, 236, 237, 5, 50, 0, 0, 237, 238, 5, 46, 0, 0,
		238, 239, 3, 48, 24, 0, 239, 240, 5, 73, 0, 0, 240, 241, 5, 50, 0, 0, 241,
		242, 5, 74, 0, 0, 242, 243, 6, 7, -1, 0, 243, 273, 1, 0, 0, 0, 244, 245,
		5, 50, 0, 0, 245, 246, 5, 46, 0, 0, 246, 247, 3, 48, 24, 0, 247, 248, 5,
		73, 0, 0, 248, 249, 3, 100, 50, 0, 249, 250, 5, 74, 0, 0, 250, 251, 6,
		7, -1, 0, 251, 273, 1, 0, 0, 0, 252, 253, 5, 50, 0, 0, 253, 254, 5, 46,
		0, 0, 254, 255, 5, 68, 0, 0, 255, 256, 3, 60, 30, 0, 256, 257, 6, 7, -1,
		0, 257, 273, 1, 0, 0, 0, 258, 259, 5, 50, 0, 0, 259, 260, 5, 46, 0, 0,
		260, 261, 3, 48, 24, 0, 261, 262, 5, 50, 0, 0, 262, 263, 6, 7, -1, 0, 263,
		273, 1, 0, 0, 0, 264, 265, 3, 52, 26, 0, 265, 266, 5, 50, 0, 0, 266, 267,
		5, 46, 0, 0, 267, 268, 5, 73, 0, 0, 268, 269, 5, 50, 0, 0, 269, 270, 5,
		74, 0, 0, 270, 271, 6, 7, -1, 0, 271, 273, 1, 0, 0, 0, 272, 230, 1, 0,
		0, 0, 272, 236, 1, 0, 0, 0, 272, 244, 1, 0, 0, 0, 272, 252, 1, 0, 0, 0,
		272, 258, 1, 0, 0, 0, 272, 264, 1, 0, 0, 0, 273, 15, 1, 0, 0, 0, 274, 275,
		3, 96, 48, 0, 275, 276, 5, 42, 0, 0, 276, 277, 6, 8, -1, 0, 277, 17, 1,
		0, 0, 0, 278, 279, 3, 32, 16, 0, 279, 280, 6, 9, -1, 0, 280, 331, 1, 0,
		0, 0, 281, 282, 3, 50, 25, 0, 282, 283, 6, 9, -1, 0, 283, 331, 1, 0, 0,
		0, 284, 285, 3, 62, 31, 0, 285, 286, 6, 9, -1, 0, 286, 331, 1, 0, 0, 0,
		287, 288, 3, 22, 11, 0, 288, 289, 6, 9, -1, 0, 289, 331, 1, 0, 0, 0, 290,
		291, 3, 70, 35, 0, 291, 292, 6, 9, -1, 0, 292, 331, 1, 0, 0, 0, 293, 294,
		3, 82, 41, 0, 294, 295, 6, 9, -1, 0, 295, 331, 1, 0, 0, 0, 296, 297, 3,
		34, 17, 0, 297, 298, 6, 9, -1, 0, 298, 331, 1, 0, 0, 0, 299, 300, 3, 36,
		18, 0, 300, 301, 6, 9, -1, 0, 301, 331, 1, 0, 0, 0, 302, 303, 3, 38, 19,
		0, 303, 304, 6, 9, -1, 0, 304, 331, 1, 0, 0, 0, 305, 306, 3, 40, 20, 0,
		306, 307, 6, 9, -1, 0, 307, 331, 1, 0, 0, 0, 308, 309, 3, 42, 21, 0, 309,
		310, 6, 9, -1, 0, 310, 331, 1, 0, 0, 0, 311, 312, 3, 24, 12, 0, 312, 313,
		6, 9, -1, 0, 313, 331, 1, 0, 0, 0, 314, 315, 3, 28, 14, 0, 315, 316, 6,
		9, -1, 0, 316, 331, 1, 0, 0, 0, 317, 318, 3, 30, 15, 0, 318, 319, 6, 9,
		-1, 0, 319, 331, 1, 0, 0, 0, 320, 321, 5, 50, 0, 0, 321, 322, 5, 42, 0,
		0, 322, 323, 5, 34, 0, 0, 323, 324, 5, 69, 0, 0, 324, 325, 5, 25, 0, 0,
		325, 326, 5, 46, 0, 0, 326, 327, 3, 102, 51, 0, 327, 328, 5, 70, 0, 0,
		328, 329, 6, 9, -1, 0, 329, 331, 1, 0, 0, 0, 330, 278, 1, 0, 0, 0, 330,
		281, 1, 0, 0, 0, 330, 284, 1, 0, 0, 0, 330, 287, 1, 0, 0, 0, 330, 290,
		1, 0, 0, 0, 330, 293, 1, 0, 0, 0, 330, 296, 1, 0, 0, 0, 330, 299, 1, 0,
		0, 0, 330, 302, 1, 0, 0, 0, 330, 305, 1, 0, 0, 0, 330, 308, 1, 0, 0, 0,
		330, 311, 1, 0, 0, 0, 330, 314, 1, 0, 0, 0, 330, 317, 1, 0, 0, 0, 330,
		320, 1, 0, 0, 0, 331, 19, 1, 0, 0, 0, 332, 333, 3, 32, 16, 0, 333, 334,
		6, 10, -1, 0, 334, 380, 1, 0, 0, 0, 335, 336, 3, 50, 25, 0, 336, 337, 6,
		10, -1, 0, 337, 380, 1, 0, 0, 0, 338, 339, 3, 62, 31, 0, 339, 340, 6, 10,
		-1, 0, 340, 380, 1, 0, 0, 0, 341, 342, 3, 22, 11, 0, 342, 343, 6, 10, -1,
		0, 343, 380, 1, 0, 0, 0, 344, 345, 3, 70, 35, 0, 345, 346, 6, 10, -1, 0,
		346, 380, 1, 0, 0, 0, 347, 348, 3, 82, 41, 0, 348, 349, 6, 10, -1, 0, 349,
		380, 1, 0, 0, 0, 350, 351, 3, 34, 17, 0, 351, 352, 6, 10, -1, 0, 352, 380,
		1, 0, 0, 0, 353, 354, 3, 36, 18, 0, 354, 355, 6, 10, -1, 0, 355, 380, 1,
		0, 0, 0, 356, 357, 3, 38, 19, 0, 357, 358, 6, 10, -1, 0, 358, 380, 1, 0,
		0, 0, 359, 360, 3, 40, 20, 0, 360, 361, 6, 10, -1, 0, 361, 380, 1, 0, 0,
		0, 362, 363, 3, 42, 21, 0, 363, 364, 6, 10, -1, 0, 364, 380, 1, 0, 0, 0,
		365, 366, 3, 28, 14, 0, 366, 367, 6, 10, -1, 0, 367, 380, 1, 0, 0, 0, 368,
		369, 3, 30, 15, 0, 369, 370, 6, 10, -1, 0, 370, 380, 1, 0, 0, 0, 371, 372,
		5, 50, 0, 0, 372, 373, 5, 42, 0, 0, 373, 374, 5, 34, 0, 0, 374, 375, 5,
		69, 0, 0, 375, 376, 3, 102, 51, 0, 376, 377, 5, 70, 0, 0, 377, 378, 6,
		10, -1, 0, 378, 380, 1, 0, 0, 0, 379, 332, 1, 0, 0, 0, 379, 335, 1, 0,
		0, 0, 379, 338, 1, 0, 0, 0, 379, 341, 1, 0, 0, 0, 379, 344, 1, 0, 0, 0,
		379, 347, 1, 0, 0, 0, 379, 350, 1, 0, 0, 0, 379, 353, 1, 0, 0, 0, 379,
		356, 1, 0, 0, 0, 379, 359, 1, 0, 0, 0, 379, 362, 1, 0, 0, 0, 379, 365,
		1, 0, 0, 0, 379, 368, 1, 0, 0, 0, 379, 371, 1, 0, 0, 0, 380, 21, 1, 0,
		0, 0, 381, 382, 5, 50, 0, 0, 382, 383, 5, 42, 0, 0, 383, 384, 5, 32, 0,
		0, 384, 385, 5, 69, 0, 0, 385, 386, 3, 102, 51, 0, 386, 387, 5, 70, 0,
		0, 387, 388, 6, 11, -1, 0, 388, 400, 1, 0, 0, 0, 389, 390, 5, 50, 0, 0,
		390, 391, 5, 42, 0, 0, 391, 392, 5, 33, 0, 0, 392, 393, 5, 69, 0, 0, 393,
		394, 3, 102, 51, 0, 394, 395, 5, 43, 0, 0, 395, 396, 3, 102, 51, 0, 396,
		397, 5, 70, 0, 0, 397, 398, 6, 11, -1, 0, 398, 400, 1, 0, 0, 0, 399, 381,
		1, 0, 0, 0, 399, 389, 1, 0, 0, 0, 400, 23, 1, 0, 0, 0, 401, 402, 5, 28,
		0, 0, 402, 403, 5, 50, 0, 0, 403, 404, 5, 71, 0, 0, 404, 405, 3, 26, 13,
		0, 405, 406, 5, 72, 0, 0, 406, 407, 6, 12, -1, 0, 407, 25, 1, 0, 0, 0,
		408, 409, 6, 13, -1, 0, 409, 410, 5, 27, 0, 0, 410, 411, 5, 50, 0, 0, 411,
		412, 5, 46, 0, 0, 412, 413, 3, 100, 50, 0, 413, 414, 6, 13, -1, 0, 414,
		432, 1, 0, 0, 0, 415, 416, 5, 27, 0, 0, 416, 417, 5, 50, 0, 0, 417, 418,
		5, 46, 0, 0, 418, 419, 5, 50, 0, 0, 419, 432, 6, 13, -1, 0, 420, 421, 5,
		26, 0, 0, 421, 422, 5, 50, 0, 0, 422, 423, 5, 46, 0, 0, 423, 424, 3, 100,
		50, 0, 424, 425, 6, 13, -1, 0, 425, 432, 1, 0, 0, 0, 426, 427, 5, 26, 0,
		0, 427, 428, 5, 50, 0, 0, 428, 429, 5, 46, 0, 0, 429, 430, 5, 50, 0, 0,
		430, 432, 6, 13, -1, 0, 431, 408, 1, 0, 0, 0, 431, 415, 1, 0, 0, 0, 431,
		420, 1, 0, 0, 0, 431, 426, 1, 0, 0, 0, 432, 461, 1, 0, 0, 0, 433, 434,
		10, 8, 0, 0, 434, 435, 5, 27, 0, 0, 435, 436, 5, 50, 0, 0, 436, 437, 5,
		46, 0, 0, 437, 438, 3, 100, 50, 0, 438, 439, 6, 13, -1, 0, 439, 460, 1,
		0, 0, 0, 440, 441, 10, 7, 0, 0, 441, 442, 5, 27, 0, 0, 442, 443, 5, 50,
		0, 0, 443, 444, 5, 46, 0, 0, 444, 445, 5, 50, 0, 0, 445, 460, 6, 13, -1,
		0, 446, 447, 10, 6, 0, 0, 447, 448, 5, 26, 0, 0, 448, 449, 5, 50, 0, 0,
		449, 450, 5, 46, 0, 0, 450, 451, 3, 100, 50, 0, 451, 452, 6, 13, -1, 0,
		452, 460, 1, 0, 0, 0, 453, 454, 10, 5, 0, 0, 454, 455, 5, 26, 0, 0, 455,
		456, 5, 50, 0, 0, 456, 457, 5, 46, 0, 0, 457, 458, 5, 50, 0, 0, 458, 460,
		6, 13, -1, 0, 459, 433, 1, 0, 0, 0, 459, 440, 1, 0, 0, 0, 459, 446, 1,
		0, 0, 0, 459, 453, 1, 0, 0, 0, 460, 463, 1, 0, 0, 0, 461, 459, 1, 0, 0,
		0, 461, 462, 1, 0, 0, 0, 462, 27, 1, 0, 0, 0, 463, 461, 1, 0, 0, 0, 464,
		465, 5, 50, 0, 0, 465, 466, 5, 69, 0, 0, 466, 467, 5, 70, 0, 0, 467, 475,
		6, 14, -1, 0, 468, 469, 5, 50, 0, 0, 469, 470, 5, 69, 0, 0, 470, 471, 3,
		46, 23, 0, 471, 472, 5, 70, 0, 0, 472, 473, 6, 14, -1, 0, 473, 475, 1,
		0, 0, 0, 474, 464, 1, 0, 0, 0, 474, 468, 1, 0, 0, 0, 475, 29, 1, 0, 0,
		0, 476, 477, 5, 38, 0, 0, 477, 483, 6, 15, -1, 0, 478, 479, 5, 38, 0, 0,
		479, 480, 3, 102, 51, 0, 480, 481, 6, 15, -1, 0, 481, 483, 1, 0, 0, 0,
		482, 476, 1, 0, 0, 0, 482, 478, 1, 0, 0, 0, 483, 31, 1, 0, 0, 0, 484, 485,
		5, 1, 0, 0, 485, 486, 5, 69, 0, 0, 486, 487, 3, 44, 22, 0, 487, 488, 5,
		70, 0, 0, 488, 489, 6, 16, -1, 0, 489, 33, 1, 0, 0, 0, 490, 491, 5, 13,
		0, 0, 491, 492, 5, 22, 0, 0, 492, 493, 3, 94, 47, 0, 493, 494, 6, 17, -1,
		0, 494, 35, 1, 0, 0, 0, 495, 496, 5, 13, 0, 0, 496, 497, 3, 102, 51, 0,
		497, 498, 3, 94, 47, 0, 498, 499, 6, 18, -1, 0, 499, 37, 1, 0, 0, 0, 500,
		501, 5, 14, 0, 0, 501, 502, 5, 50, 0, 0, 502, 503, 5, 15, 0, 0, 503, 504,
		3, 102, 51, 0, 504, 505, 3, 94, 47, 0, 505, 506, 6, 19, -1, 0, 506, 39,
		1, 0, 0, 0, 507, 508, 5, 16, 0, 0, 508, 514, 6, 20, -1, 0, 509, 510, 5,
		16, 0, 0, 510, 511, 3, 102, 51, 0, 511, 512, 6, 20, -1, 0, 512, 514, 1,
		0, 0, 0, 513, 507, 1, 0, 0, 0, 513, 509, 1, 0, 0, 0, 514, 41, 1, 0, 0,
		0, 515, 516, 5, 17, 0, 0, 516, 517, 6, 21, -1, 0, 517, 43, 1, 0, 0, 0,
		518, 519, 6, 22, -1, 0, 519, 520, 3, 102, 51, 0, 520, 521, 6, 22, -1, 0,
		521, 529, 1, 0, 0, 0, 522, 523, 10, 2, 0, 0, 523, 524, 5, 43, 0, 0, 524,
		525, 3, 102, 51, 0, 525, 526, 6, 22, -1, 0, 526, 528, 1, 0, 0, 0, 527,
		522, 1, 0, 0, 0, 528, 531, 1, 0, 0, 0, 529, 527, 1, 0, 0, 0, 529, 530,
		1, 0, 0, 0, 530, 45, 1, 0, 0, 0, 531, 529, 1, 0, 0, 0, 532, 533, 6, 23,
		-1, 0, 533, 534, 3, 48, 24, 0, 534, 535, 3, 102, 51, 0, 535, 536, 6, 23,
		-1, 0, 536, 545, 1, 0, 0, 0, 537, 538, 10, 2, 0, 0, 538, 539, 5, 43, 0,
		0, 539, 540, 3, 48, 24, 0, 540, 541, 3, 102, 51, 0, 541, 542, 6, 23, -1,
		0, 542, 544, 1, 0, 0, 0, 543, 537, 1, 0, 0, 0, 544, 547, 1, 0, 0, 0, 545,
		543, 1, 0, 0, 0, 545, 546, 1, 0, 0, 0, 546, 47, 1, 0, 0, 0, 547, 545, 1,
		0, 0, 0, 548, 549, 5, 67, 0, 0, 549, 552, 6, 24, -1, 0, 550, 552, 6, 24,
		-1, 0, 551, 548, 1, 0, 0, 0, 551, 550, 1, 0, 0, 0, 552, 49, 1, 0, 0, 0,
		553, 554, 3, 54, 27, 0, 554, 555, 5, 50, 0, 0, 555, 556, 5, 46, 0, 0, 556,
		557, 3, 100, 50, 0, 557, 558, 5, 47, 0, 0, 558, 559, 3, 102, 51, 0, 559,
		560, 6, 25, -1, 0, 560, 617, 1, 0, 0, 0, 561, 562, 3, 54, 27, 0, 562, 563,
		5, 50, 0, 0, 563, 564, 3, 56, 28, 0, 564, 565, 5, 47, 0, 0, 565, 566, 3,
		102, 51, 0, 566, 567, 6, 25, -1, 0, 567, 617, 1, 0, 0, 0, 568, 569, 3,
		54, 27, 0, 569, 570, 5, 50, 0, 0, 570, 571, 5, 46, 0, 0, 571, 572, 3, 58,
		29, 0, 572, 573, 5, 47, 0, 0, 573, 574, 5, 73, 0, 0, 574, 575, 5, 74, 0,
		0, 575, 576, 6, 25, -1, 0, 576, 617, 1, 0, 0, 0, 577, 578, 3, 54, 27, 0,
		578, 579, 5, 50, 0, 0, 579, 580, 5, 46, 0, 0, 580, 581, 3, 58, 29, 0, 581,
		582, 5, 47, 0, 0, 582, 583, 3, 102, 51, 0, 583, 584, 6, 25, -1, 0, 584,
		617, 1, 0, 0, 0, 585, 586, 3, 54, 27, 0, 586, 587, 5, 50, 0, 0, 587, 588,
		5, 46, 0, 0, 588, 589, 5, 73, 0, 0, 589, 590, 5, 50, 0, 0, 590, 591, 5,
		74, 0, 0, 591, 592, 5, 47, 0, 0, 592, 593, 5, 73, 0, 0, 593, 594, 5, 74,
		0, 0, 594, 595, 6, 25, -1, 0, 595, 617, 1, 0, 0, 0, 596, 597, 3, 54, 27,
		0, 597, 598, 5, 50, 0, 0, 598, 599, 5, 46, 0, 0, 599, 600, 5, 73, 0, 0,
		600, 601, 5, 50, 0, 0, 601, 602, 5, 74, 0, 0, 602, 603, 5, 47, 0, 0, 603,
		604, 3, 102, 51, 0, 604, 605, 6, 25, -1, 0, 605, 617, 1, 0, 0, 0, 606,
		607, 3, 54, 27, 0, 607, 608, 5, 50, 0, 0, 608, 609, 5, 46, 0, 0, 609, 610,
		5, 73, 0, 0, 610, 611, 3, 100, 50, 0, 611, 612, 5, 74, 0, 0, 612, 613,
		5, 47, 0, 0, 613, 614, 3, 102, 51, 0, 614, 615, 6, 25, -1, 0, 615, 617,
		1, 0, 0, 0, 616, 553, 1, 0, 0, 0, 616, 561, 1, 0, 0, 0, 616, 568, 1, 0,
		0, 0, 616, 577, 1, 0, 0, 0, 616, 585, 1, 0, 0, 0, 616, 596, 1, 0, 0, 0,
		616, 606, 1, 0, 0, 0, 617, 51, 1, 0, 0, 0, 618, 619, 5, 27, 0, 0, 619,
		622, 6, 26, -1, 0, 620, 622, 1, 0, 0, 0, 621, 618, 1, 0, 0, 0, 621, 620,
		1, 0, 0, 0, 622, 53, 1, 0, 0, 0, 623, 624, 5, 27, 0, 0, 624, 628, 6, 27,
		-1, 0, 625, 626, 5, 26, 0, 0, 626, 628, 6, 27, -1, 0, 627, 623, 1, 0, 0,
		0, 627, 625, 1, 0, 0, 0, 628, 55, 1, 0, 0, 0, 629, 630, 5, 46, 0, 0, 630,
		633, 5, 50, 0, 0, 631, 633, 1, 0, 0, 0, 632, 629, 1, 0, 0, 0, 632, 631,
		1, 0, 0, 0, 633, 57, 1, 0, 0, 0, 634, 635, 5, 73, 0, 0, 635, 636, 3, 58,
		29, 0, 636, 637, 5, 74, 0, 0, 637, 638, 6, 29, -1, 0, 638, 645, 1, 0, 0,
		0, 639, 640, 5, 73, 0, 0, 640, 641, 3, 100, 50, 0, 641, 642, 5, 74, 0,
		0, 642, 643, 6, 29, -1, 0, 643, 645, 1, 0, 0, 0, 644, 634, 1, 0, 0, 0,
		644, 639, 1, 0, 0, 0, 645, 59, 1, 0, 0, 0, 646, 647, 5, 73, 0, 0, 647,
		648, 3, 60, 30, 0, 648, 649, 5, 44, 0, 0, 649, 650, 3, 102, 51, 0, 650,
		651, 5, 74, 0, 0, 651, 652, 6, 30, -1, 0, 652, 666, 1, 0, 0, 0, 653, 654,
		5, 73, 0, 0, 654, 655, 3, 100, 50, 0, 655, 656, 5, 44, 0, 0, 656, 657,
		3, 102, 51, 0, 657, 658, 5, 74, 0, 0, 658, 659, 6, 30, -1, 0, 659, 666,
		1, 0, 0, 0, 660, 661, 5, 73, 0, 0, 661, 662, 3, 100, 50, 0, 662, 663, 5,
		74, 0, 0, 663, 664, 6, 30, -1, 0, 664, 666, 1, 0, 0, 0, 665, 646, 1, 0,
		0, 0, 665, 653, 1, 0, 0, 0, 665, 660, 1, 0, 0, 0, 666, 61, 1, 0, 0, 0,
		667, 668, 5, 50, 0, 0, 668, 669, 5, 47, 0, 0, 669, 670, 3, 102, 51, 0,
		670, 671, 6, 31, -1, 0, 671, 699, 1, 0, 0, 0, 672, 673, 5, 50, 0, 0, 673,
		674, 3, 66, 33, 0, 674, 675, 5, 47, 0, 0, 675, 676, 3, 102, 51, 0, 676,
		677, 6, 31, -1, 0, 677, 699, 1, 0, 0, 0, 678, 679, 3, 64, 32, 0, 679, 680,
		5, 47, 0, 0, 680, 681, 3, 102, 51, 0, 681, 682, 6, 31, -1, 0, 682, 699,
		1, 0, 0, 0, 683, 684, 5, 50, 0, 0, 684, 685, 5, 73, 0, 0, 685, 686, 3,
		102, 51, 0, 686, 687, 5, 74, 0, 0, 687, 688, 5, 42, 0, 0, 688, 689, 3,
		64, 32, 0, 689, 690, 5, 47, 0, 0, 690, 691, 3, 102, 51, 0, 691, 692, 6,
		31, -1, 0, 692, 699, 1, 0, 0, 0, 693, 694, 5, 50, 0, 0, 694, 695, 5, 57,
		0, 0, 695, 696, 3, 102, 51, 0, 696, 697, 6, 31, -1, 0, 697, 699, 1, 0,
		0, 0, 698, 667, 1, 0, 0, 0, 698, 672, 1, 0, 0, 0, 698, 678, 1, 0, 0, 0,
		698, 683, 1, 0, 0, 0, 698, 693, 1, 0, 0, 0, 699, 63, 1, 0, 0, 0, 700, 701,
		6, 32, -1, 0, 701, 702, 5, 50, 0, 0, 702, 703, 6, 32, -1, 0, 703, 710,
		1, 0, 0, 0, 704, 705, 10, 2, 0, 0, 705, 706, 5, 42, 0, 0, 706, 707, 5,
		50, 0, 0, 707, 709, 6, 32, -1, 0, 708, 704, 1, 0, 0, 0, 709, 712, 1, 0,
		0, 0, 710, 708, 1, 0, 0, 0, 710, 711, 1, 0, 0, 0, 711, 65, 1, 0, 0, 0,
		712, 710, 1, 0, 0, 0, 713, 714, 6, 33, -1, 0, 714, 715, 3, 68, 34, 0, 715,
		716, 6, 33, -1, 0, 716, 723, 1, 0, 0, 0, 717, 718, 10, 2, 0, 0, 718, 719,
		3, 68, 34, 0, 719, 720, 6, 33, -1, 0, 720, 722, 1, 0, 0, 0, 721, 717, 1,
		0, 0, 0, 722, 725, 1, 0, 0, 0, 723, 721, 1, 0, 0, 0, 723, 724, 1, 0, 0,
		0, 724, 67, 1, 0, 0, 0, 725, 723, 1, 0, 0, 0, 726, 727, 5, 73, 0, 0, 727,
		728, 3, 102, 51, 0, 728, 729, 5, 74, 0, 0, 729, 730, 6, 34, -1, 0, 730,
		69, 1, 0, 0, 0, 731, 732, 5, 11, 0, 0, 732, 733, 3, 102, 51, 0, 733, 734,
		3, 94, 47, 0, 734, 735, 6, 35, -1, 0, 735, 758, 1, 0, 0, 0, 736, 737, 5,
		11, 0, 0, 737, 738, 3, 102, 51, 0, 738, 739, 3, 94, 47, 0, 739, 740, 5,
		12, 0, 0, 740, 741, 3, 94, 47, 0, 741, 742, 6, 35, -1, 0, 742, 758, 1,
		0, 0, 0, 743, 744, 5, 11, 0, 0, 744, 745, 3, 102, 51, 0, 745, 746, 3, 94,
		47, 0, 746, 747, 3, 74, 37, 0, 747, 748, 6, 35, -1, 0, 748, 758, 1, 0,
		0, 0, 749, 750, 5, 11, 0, 0, 750, 751, 3, 102, 51, 0, 751, 752, 3, 94,
		47, 0, 752, 753, 3, 74, 37, 0, 753, 754, 5, 12, 0, 0, 754, 755, 3, 94,
		47, 0, 755, 756, 6, 35, -1, 0, 756, 758, 1, 0, 0, 0, 757, 731, 1, 0, 0,
		0, 757, 736, 1, 0, 0, 0, 757, 743, 1, 0, 0, 0, 757, 749, 1, 0, 0, 0, 758,
		71, 1, 0, 0, 0, 759, 760, 5, 11, 0, 0, 760, 761, 3, 102, 51, 0, 761, 762,
		3, 98, 49, 0, 762, 763, 5, 12, 0, 0, 763, 764, 3, 98, 49, 0, 764, 765,
		6, 36, -1, 0, 765, 775, 1, 0, 0, 0, 766, 767, 5, 11, 0, 0, 767, 768, 3,
		102, 51, 0, 768, 769, 3, 98, 49, 0, 769, 770, 3, 76, 38, 0, 770, 771, 5,
		12, 0, 0, 771, 772, 3, 98, 49, 0, 772, 773, 6, 36, -1, 0, 773, 775, 1,
		0, 0, 0, 774, 759, 1, 0, 0, 0, 774, 766, 1, 0, 0, 0, 775, 73, 1, 0, 0,
		0, 776, 778, 3, 78, 39, 0, 777, 776, 1, 0, 0, 0, 778, 779, 1, 0, 0, 0,
		779, 777, 1, 0, 0, 0, 779, 780, 1, 0, 0, 0, 780, 781, 1, 0, 0, 0, 781,
		782, 6, 37, -1, 0, 782, 75, 1, 0, 0, 0, 783, 785, 3, 80, 40, 0, 784, 783,
		1, 0, 0, 0, 785, 786, 1, 0, 0, 0, 786, 784, 1, 0, 0, 0, 786, 787, 1, 0,
		0, 0, 787, 788, 1, 0, 0, 0, 788, 789, 6, 38, -1, 0, 789, 77, 1, 0, 0, 0,
		790, 791, 5, 12, 0, 0, 791, 792, 5, 11, 0, 0, 792, 793, 3, 102, 51, 0,
		793, 794, 3, 94, 47, 0, 794, 795, 6, 39, -1, 0, 795, 79, 1, 0, 0, 0, 796,
		797, 5, 12, 0, 0, 797, 798, 5, 11, 0, 0, 798, 799, 3, 102, 51, 0, 799,
		800, 3, 98, 49, 0, 800, 801, 6, 40, -1, 0, 801, 81, 1, 0, 0, 0, 802, 803,
		5, 18, 0, 0, 803, 804, 3, 102, 51, 0, 804, 805, 5, 71, 0, 0, 805, 806,
		3, 84, 42, 0, 806, 807, 5, 72, 0, 0, 807, 808, 6, 41, -1, 0, 808, 847,
		1, 0, 0, 0, 809, 810, 5, 18, 0, 0, 810, 811, 3, 102, 51, 0, 811, 812, 5,
		71, 0, 0, 812, 813, 3, 84, 42, 0, 813, 814, 5, 21, 0, 0, 814, 815, 5, 46,
		0, 0, 815, 816, 3, 94, 47, 0, 816, 817, 5, 72, 0, 0, 817, 818, 6, 41, -1,
		0, 818, 847, 1, 0, 0, 0, 819, 820, 5, 18, 0, 0, 820, 821, 3, 102, 51, 0,
		821, 822, 5, 71, 0, 0, 822, 823, 3, 84, 42, 0, 823, 824, 5, 21, 0, 0, 824,
		825, 5, 46, 0, 0, 825, 826, 3, 20, 10, 0, 826, 827, 5, 72, 0, 0, 827, 828,
		6, 41, -1, 0, 828, 847, 1, 0, 0, 0, 829, 830, 5, 18, 0, 0, 830, 831, 3,
		102, 51, 0, 831, 832, 5, 71, 0, 0, 832, 833, 3, 86, 43, 0, 833, 834, 5,
		72, 0, 0, 834, 835, 6, 41, -1, 0, 835, 847, 1, 0, 0, 0, 836, 837, 5, 18,
		0, 0, 837, 838, 3, 102, 51, 0, 838, 839, 5, 71, 0, 0, 839, 840, 3, 86,
		43, 0, 840, 841, 5, 21, 0, 0, 841, 842, 5, 46, 0, 0, 842, 843, 3, 102,
		51, 0, 843, 844, 5, 72, 0, 0, 844, 845, 6, 41, -1, 0, 845, 847, 1, 0, 0,
		0, 846, 802, 1, 0, 0, 0, 846, 809, 1, 0, 0, 0, 846, 819, 1, 0, 0, 0, 846,
		829, 1, 0, 0, 0, 846, 836, 1, 0, 0, 0, 847, 83, 1, 0, 0, 0, 848, 849, 6,
		42, -1, 0, 849, 850, 3, 88, 44, 0, 850, 851, 6, 42, -1, 0, 851, 858, 1,
		0, 0, 0, 852, 853, 10, 2, 0, 0, 853, 854, 3, 88, 44, 0, 854, 855, 6, 42,
		-1, 0, 855, 857, 1, 0, 0, 0, 856, 852, 1, 0, 0, 0, 857, 860, 1, 0, 0, 0,
		858, 856, 1, 0, 0, 0, 858, 859, 1, 0, 0, 0, 859, 85, 1, 0, 0, 0, 860, 858,
		1, 0, 0, 0, 861, 862, 6, 43, -1, 0, 862, 863, 3, 90, 45, 0, 863, 864, 6,
		43, -1, 0, 864, 871, 1, 0, 0, 0, 865, 866, 10, 2, 0, 0, 866, 867, 3, 90,
		45, 0, 867, 868, 6, 43, -1, 0, 868, 870, 1, 0, 0, 0, 869, 865, 1, 0, 0,
		0, 870, 873, 1, 0, 0, 0, 871, 869, 1, 0, 0, 0, 871, 872, 1, 0, 0, 0, 872,
		87, 1, 0, 0, 0, 873, 871, 1, 0, 0, 0, 874, 875, 5, 20, 0, 0, 875, 876,
		3, 92, 46, 0, 876, 877, 5, 46, 0, 0, 877, 878, 3, 94, 47, 0, 878, 879,
		6, 44, -1, 0, 879, 887, 1, 0, 0, 0, 880, 881, 5, 20, 0, 0, 881, 882, 3,
		92, 46, 0, 882, 883, 5, 46, 0, 0, 883, 884, 3, 20, 10, 0, 884, 885, 6,
		44, -1, 0, 885, 887, 1, 0, 0, 0, 886, 874, 1, 0, 0, 0, 886, 880, 1, 0,
		0, 0, 887, 89, 1, 0, 0, 0, 888, 889, 3, 92, 46, 0, 889, 890, 5, 46, 0,
		0, 890, 891, 3, 102, 51, 0, 891, 892, 6, 45, -1, 0, 892, 91, 1, 0, 0, 0,
		893, 894, 6, 46, -1, 0, 894, 895, 3, 112, 56, 0, 895, 896, 6, 46, -1, 0,
		896, 904, 1, 0, 0, 0, 897, 898, 10, 2, 0, 0, 898, 899, 5, 43, 0, 0, 899,
		900, 3, 112, 56, 0, 900, 901, 6, 46, -1, 0, 901, 903, 1, 0, 0, 0, 902,
		897, 1, 0, 0, 0, 903, 906, 1, 0, 0, 0, 904, 902, 1, 0, 0, 0, 904, 905,
		1, 0, 0, 0, 905, 93, 1, 0, 0, 0, 906, 904, 1, 0, 0, 0, 907, 908, 5, 71,
		0, 0, 908, 909, 3, 2, 1, 0, 909, 910, 5, 72, 0, 0, 910, 911, 6, 47, -1,
		0, 911, 916, 1, 0, 0, 0, 912, 913, 5, 71, 0, 0, 913, 914, 5, 72, 0, 0,
		914, 916, 6, 47, -1, 0, 915, 907, 1, 0, 0, 0, 915, 912, 1, 0, 0, 0, 916,
		95, 1, 0, 0, 0, 917, 918, 3, 2, 1, 0, 918, 919, 6, 48, -1, 0, 919, 922,
		1, 0, 0, 0, 920, 922, 6, 48, -1, 0, 921, 917, 1, 0, 0, 0, 921, 920, 1,
		0, 0, 0, 922, 97, 1, 0, 0, 0, 923, 924, 5, 71, 0, 0, 924, 925, 3, 102,
		51, 0, 925, 926, 5, 72, 0, 0, 926, 927, 6, 49, -1, 0, 927, 99, 1, 0, 0,
		0, 928, 932, 5, 2, 0, 0, 929, 931, 5, 66, 0, 0, 930, 929, 1, 0, 0, 0, 931,
		934, 1, 0, 0, 0, 932, 930, 1, 0, 0, 0, 932, 933, 1, 0, 0, 0, 933, 935,
		1, 0, 0, 0, 934, 932, 1, 0, 0, 0, 935, 1001, 6, 50, -1, 0, 936, 940, 5,
		4, 0, 0, 937, 939, 5, 66, 0, 0, 938, 937, 1, 0, 0, 0, 939, 942, 1, 0, 0,
		0, 940, 938, 1, 0, 0, 0, 940, 941, 1, 0, 0, 0, 941, 943, 1, 0, 0, 0, 942,
		940, 1, 0, 0, 0, 943, 1001, 6, 50, -1, 0, 944, 948, 5, 3, 0, 0, 945, 947,
		5, 66, 0, 0, 946, 945, 1, 0, 0, 0, 947, 950, 1, 0, 0, 0, 948, 946, 1, 0,
		0, 0, 948, 949, 1, 0, 0, 0, 949, 951, 1, 0, 0, 0, 950, 948, 1, 0, 0, 0,
		951, 1001, 6, 50, -1, 0, 952, 956, 5, 5, 0, 0, 953, 955, 5, 66, 0, 0, 954,
		953, 1, 0, 0, 0, 955, 958, 1, 0, 0, 0, 956, 954, 1, 0, 0, 0, 956, 957,
		1, 0, 0, 0, 957, 959, 1, 0, 0, 0, 958, 956, 1, 0, 0, 0, 959, 1001, 6, 50,
		-1, 0, 960, 964, 5, 6, 0, 0, 961, 963, 5, 66, 0, 0, 962, 961, 1, 0, 0,
		0, 963, 966, 1, 0, 0, 0, 964, 962, 1, 0, 0, 0, 964, 965, 1, 0, 0, 0, 965,
		967, 1, 0, 0, 0, 966, 964, 1, 0, 0, 0, 967, 1001, 6, 50, -1, 0, 968, 972,
		5, 28, 0, 0, 969, 971, 5, 66, 0, 0, 970, 969, 1, 0, 0, 0, 971, 974, 1,
		0, 0, 0, 972, 970, 1, 0, 0, 0, 972, 973, 1, 0, 0, 0, 973, 975, 1, 0, 0,
		0, 974, 972, 1, 0, 0, 0, 975, 1001, 6, 50, -1, 0, 976, 980, 5, 7, 0, 0,
		977, 979, 5, 66, 0, 0, 978, 977, 1, 0, 0, 0, 979, 982, 1, 0, 0, 0, 980,
		978, 1, 0, 0, 0, 980, 981, 1, 0, 0, 0, 981, 983, 1, 0, 0, 0, 982, 980,
		1, 0, 0, 0, 983, 1001, 6, 50, -1, 0, 984, 988, 5, 8, 0, 0, 985, 987, 5,
		66, 0, 0, 986, 985, 1, 0, 0, 0, 987, 990, 1, 0, 0, 0, 988, 986, 1, 0, 0,
		0, 988, 989, 1, 0, 0, 0, 989, 991, 1, 0, 0, 0, 990, 988, 1, 0, 0, 0, 991,
		1001, 6, 50, -1, 0, 992, 996, 5, 9, 0, 0, 993, 995, 5, 66, 0, 0, 994, 993,
		1, 0, 0, 0, 995, 998, 1, 0, 0, 0, 996, 994, 1, 0, 0, 0, 996, 997, 1, 0,
		0, 0, 997, 999, 1, 0, 0, 0, 998, 996, 1, 0, 0, 0, 999, 1001, 6, 50, -1,
		0, 1000, 928, 1, 0, 0, 0, 1000, 936, 1, 0, 0, 0, 1000, 944, 1, 0, 0, 0,
		1000, 952, 1, 0, 0, 0, 1000, 960, 1, 0, 0, 0, 1000, 968, 1, 0, 0, 0, 1000,
		976, 1, 0, 0, 0, 1000, 984, 1, 0, 0, 0, 1000, 992, 1, 0, 0, 0, 1001, 101,
		1, 0, 0, 0, 1002, 1003, 6, 51, -1, 0, 1003, 1004, 3, 104, 52, 0, 1004,
		1005, 6, 51, -1, 0, 1005, 1015, 1, 0, 0, 0, 1006, 1007, 10, 1, 0, 0, 1007,
		1008, 5, 42, 0, 0, 1008, 1009, 5, 42, 0, 0, 1009, 1010, 5, 42, 0, 0, 1010,
		1011, 3, 102, 51, 2, 1011, 1012, 6, 51, -1, 0, 1012, 1014, 1, 0, 0, 0,
		1013, 1006, 1, 0, 0, 0, 1014, 1017, 1, 0, 0, 0, 1015, 1013, 1, 0, 0, 0,
		1015, 1016, 1, 0, 0, 0, 1016, 103, 1, 0, 0, 0, 1017, 1015, 1, 0, 0, 0,
		1018, 1019, 6, 52, -1, 0, 1019, 1020, 5, 61, 0, 0, 1020, 1021, 3, 104,
		52, 22, 1021, 1022, 6, 52, -1, 0, 1022, 1091, 1, 0, 0, 0, 1023, 1024, 5,
		65, 0, 0, 1024, 1025, 3, 104, 52, 17, 1025, 1026, 6, 52, -1, 0, 1026, 1091,
		1, 0, 0, 0, 1027, 1028, 5, 4, 0, 0, 1028, 1029, 5, 69, 0, 0, 1029, 1030,
		3, 104, 52, 0, 1030, 1031, 5, 70, 0, 0, 1031, 1032, 6, 52, -1, 0, 1032,
		1091, 1, 0, 0, 0, 1033, 1034, 5, 50, 0, 0, 1034, 1035, 5, 42, 0, 0, 1035,
		1036, 5, 31, 0, 0, 1036, 1091, 6, 52, -1, 0, 1037, 1038, 5, 73, 0, 0, 1038,
		1039, 3, 102, 51, 0, 1039, 1040, 5, 44, 0, 0, 1040, 1041, 3, 102, 51, 0,
		1041, 1042, 5, 74, 0, 0, 1042, 1043, 6, 52, -1, 0, 1043, 1091, 1, 0, 0,
		0, 1044, 1045, 5, 73, 0, 0, 1045, 1046, 3, 44, 22, 0, 1046, 1047, 5, 74,
		0, 0, 1047, 1048, 6, 52, -1, 0, 1048, 1091, 1, 0, 0, 0, 1049, 1050, 5,
		50, 0, 0, 1050, 1051, 5, 69, 0, 0, 1051, 1052, 3, 110, 55, 0, 1052, 1053,
		5, 70, 0, 0, 1053, 1054, 6, 52, -1, 0, 1054, 1091, 1, 0, 0, 0, 1055, 1056,
		3, 112, 56, 0, 1056, 1057, 6, 52, -1, 0, 1057, 1091, 1, 0, 0, 0, 1058,
		1059, 5, 69, 0, 0, 1059, 1060, 3, 102, 51, 0, 1060, 1061, 5, 70, 0, 0,
		1061, 1062, 6, 52, -1, 0, 1062, 1091, 1, 0, 0, 0, 1063, 1064, 3, 106, 53,
		0, 1064, 1065, 6, 52, -1, 0, 1065, 1091, 1, 0, 0, 0, 1066, 1067, 3, 72,
		36, 0, 1067, 1068, 6, 52, -1, 0, 1068, 1091, 1, 0, 0, 0, 1069, 1070, 3,
		82, 41, 0, 1070, 1071, 6, 52, -1, 0, 1071, 1091, 1, 0, 0, 0, 1072, 1073,
		3, 34, 17, 0, 1073, 1074, 6, 52, -1, 0, 1074, 1091, 1, 0, 0, 0, 1075, 1076,
		3, 28, 14, 0, 1076, 1077, 6, 52, -1, 0, 1077, 1091, 1, 0, 0, 0, 1078, 1079,
		5, 50, 0, 0, 1079, 1080, 5, 42, 0, 0, 1080, 1081, 5, 34, 0, 0, 1081, 1082,
		5, 69, 0, 0, 1082, 1083, 3, 102, 51, 0, 1083, 1084, 5, 70, 0, 0, 1084,
		1085, 6, 52, -1, 0, 1085, 1091, 1, 0, 0, 0, 1086, 1087, 5, 15, 0, 0, 1087,
		1088, 3, 112, 56, 0, 1088, 1089, 6, 52, -1, 0, 1089, 1091, 1, 0, 0, 0,
		1090, 1018, 1, 0, 0, 0, 1090, 1023, 1, 0, 0, 0, 1090, 1027, 1, 0, 0, 0,
		1090, 1033, 1, 0, 0, 0, 1090, 1037, 1, 0, 0, 0, 1090, 1044, 1, 0, 0, 0,
		1090, 1049, 1, 0, 0, 0, 1090, 1055, 1, 0, 0, 0, 1090, 1058, 1, 0, 0, 0,
		1090, 1063, 1, 0, 0, 0, 1090, 1066, 1, 0, 0, 0, 1090, 1069, 1, 0, 0, 0,
		1090, 1072, 1, 0, 0, 0, 1090, 1075, 1, 0, 0, 0, 1090, 1078, 1, 0, 0, 0,
		1090, 1086, 1, 0, 0, 0, 1091, 1123, 1, 0, 0, 0, 1092, 1093, 10, 21, 0,
		0, 1093, 1094, 7, 0, 0, 0, 1094, 1095, 3, 104, 52, 22, 1095, 1096, 6, 52,
		-1, 0, 1096, 1122, 1, 0, 0, 0, 1097, 1098, 10, 19, 0, 0, 1098, 1099, 7,
		1, 0, 0, 1099, 1100, 3, 104, 52, 20, 1100, 1101, 6, 52, -1, 0, 1101, 1122,
		1, 0, 0, 0, 1102, 1103, 10, 18, 0, 0, 1103, 1104, 7, 2, 0, 0, 1104, 1105,
		3, 104, 52, 19, 1105, 1106, 6, 52, -1, 0, 1106, 1122, 1, 0, 0, 0, 1107,
		1108, 10, 16, 0, 0, 1108, 1109, 5, 63, 0, 0, 1109, 1110, 3, 104, 52, 17,
		1110, 1111, 6, 52, -1, 0, 1111, 1122, 1, 0, 0, 0, 1112, 1113, 10, 15, 0,
		0, 1113, 1114, 5, 64, 0, 0, 1114, 1115, 3, 104, 52, 16, 1115, 1116, 6,
		52, -1, 0, 1116, 1122, 1, 0, 0, 0, 1117, 1118, 10, 20, 0, 0, 1118, 1119,
		5, 42, 0, 0, 1119, 1120, 5, 29, 0, 0, 1120, 1122, 6, 52, -1, 0, 1121, 1092,
		1, 0, 0, 0, 1121, 1097, 1, 0, 0, 0, 1121, 1102, 1, 0, 0, 0, 1121, 1107,
		1, 0, 0, 0, 1121, 1112, 1, 0, 0, 0, 1121, 1117, 1, 0, 0, 0, 1122, 1125,
		1, 0, 0, 0, 1123, 1121, 1, 0, 0, 0, 1123, 1124, 1, 0, 0, 0, 1124, 105,
		1, 0, 0, 0, 1125, 1123, 1, 0, 0, 0, 1126, 1127, 5, 69, 0, 0, 1127, 1128,
		3, 102, 51, 0, 1128, 1129, 5, 24, 0, 0, 1129, 1130, 3, 108, 54, 0, 1130,
		1131, 5, 70, 0, 0, 1131, 1132, 6, 53, -1, 0, 1132, 107, 1, 0, 0, 0, 1133,
		1134, 5, 3, 0, 0, 1134, 1140, 6, 54, -1, 0, 1135, 1136, 5, 2, 0, 0, 1136,
		1140, 6, 54, -1, 0, 1137, 1138, 5, 10, 0, 0, 1138, 1140, 6, 54, -1, 0,
		1139, 1133, 1, 0, 0, 0, 1139, 1135, 1, 0, 0, 0, 1139, 1137, 1, 0, 0, 0,
		1140, 109, 1, 0, 0, 0, 1141, 1142, 6, 55, -1, 0, 1142, 1143, 5, 50, 0,
		0, 1143, 1144, 5, 46, 0, 0, 1144, 1145, 3, 102, 51, 0, 1145, 1146, 6, 55,
		-1, 0, 1146, 1156, 1, 0, 0, 0, 1147, 1148, 10, 2, 0, 0, 1148, 1149, 5,
		43, 0, 0, 1149, 1150, 5, 50, 0, 0, 1150, 1151, 5, 46, 0, 0, 1151, 1152,
		3, 102, 51, 0, 1152, 1153, 6, 55, -1, 0, 1153, 1155, 1, 0, 0, 0, 1154,
		1147, 1, 0, 0, 0, 1155, 1158, 1, 0, 0, 0, 1156, 1154, 1, 0, 0, 0, 1156,
		1157, 1, 0, 0, 0, 1157, 111, 1, 0, 0, 0, 1158, 1156, 1, 0, 0, 0, 1159,
		1160, 5, 39, 0, 0, 1160, 1176, 6, 56, -1, 0, 1161, 1162, 5, 40, 0, 0, 1162,
		1176, 6, 56, -1, 0, 1163, 1164, 3, 116, 58, 0, 1164, 1165, 6, 56, -1, 0,
		1165, 1176, 1, 0, 0, 0, 1166, 1167, 5, 75, 0, 0, 1167, 1176, 6, 56, -1,
		0, 1168, 1169, 5, 22, 0, 0, 1169, 1176, 6, 56, -1, 0, 1170, 1171, 5, 23,
		0, 0, 1171, 1176, 6, 56, -1, 0, 1172, 1173, 3, 114, 57, 0, 1173, 1174,
		6, 56, -1, 0, 1174, 1176, 1, 0, 0, 0, 1175, 1159, 1, 0, 0, 0, 1175, 1161,
		1, 0, 0, 0, 1175, 1163, 1, 0, 0, 0, 1175, 1166, 1, 0, 0, 0, 1175, 1168,
		1, 0, 0, 0, 1175, 1170, 1, 0, 0, 0, 1175, 1172, 1, 0, 0, 0, 1176, 113,
		1, 0, 0, 0, 1177, 1178, 6, 57, -1, 0, 1178, 1179, 5, 50, 0, 0, 1179, 1180,
		6, 57, -1, 0, 1180, 1193, 1, 0, 0, 0, 1181, 1182, 10, 3, 0, 0, 1182, 1183,
		5, 73, 0, 0, 1183, 1184, 3, 102, 51, 0, 1184, 1185, 5, 74, 0, 0, 1185,
		1186, 6, 57, -1, 0, 1186, 1192, 1, 0, 0, 0, 1187, 1188, 10, 2, 0, 0, 1188,
		1189, 5, 42, 0, 0, 1189, 1190, 5, 50, 0, 0, 1190, 1192, 6, 57, -1, 0, 1191,
		1181, 1, 0, 0, 0, 1191, 1187, 1, 0, 0, 0, 1192, 1195, 1, 0, 0, 0, 1193,
		1191, 1, 0, 0, 0, 1193, 1194, 1, 0, 0, 0, 1194, 115, 1, 0, 0, 0, 1195,
		1193, 1, 0, 0, 0, 1196, 1198, 5, 67, 0, 0, 1197, 1196, 1, 0, 0, 0, 1198,
		1199, 1, 0, 0, 0, 1199, 1197, 1, 0, 0, 0, 1199, 1200, 1, 0, 0, 0, 1200,
		1201, 1, 0, 0, 0, 1201, 1202, 5, 4, 0, 0, 1202, 1203, 5, 69, 0, 0, 1203,
		1204, 5, 41, 0, 0, 1204, 1205, 5, 70, 0, 0, 1205, 1214, 6, 58, -1, 0, 1206,
		1207, 5, 4, 0, 0, 1207, 1208, 5, 69, 0, 0, 1208, 1209, 5, 41, 0, 0, 1209,
		1210, 5, 70, 0, 0, 1210, 1214, 6, 58, -1, 0, 1211, 1212, 5, 41, 0, 0, 1212,
		1214, 6, 58, -1, 0, 1213, 1197, 1, 0, 0, 0, 1213, 1206, 1, 0, 0, 0, 1213,
		1211, 1, 0, 0, 0, 1214, 117, 1, 0, 0, 0, 60, 124, 139, 148, 156, 214, 227,
		272, 330, 379, 399, 431, 459, 461, 474, 482, 513, 529, 545, 551, 616, 621,
		627, 632, 644, 665, 698, 710, 723, 757, 774, 779, 786, 846, 858, 871, 886,
		904, 915, 921, 932, 940, 948, 956, 964, 972, 980, 988, 996, 1000, 1015,
		1090, 1121, 1123, 1139, 1156, 1175, 1191, 1193, 1199, 1213,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// swiftgrammarInit initializes any static state used to implement swiftgrammar. By default the
// static state used to implement the parser is lazily initialized during the first call to
// Newswiftgrammar(). You can call this function if you wish to initialize the static state ahead
// of time.
func SwiftgrammarInit() {
	staticData := &SwiftgrammarParserStaticData
	staticData.once.Do(swiftgrammarParserInit)
}

// Newswiftgrammar produces a new parser instance for the optional input antlr.TokenStream.
func Newswiftgrammar(input antlr.TokenStream) *swiftgrammar {
	SwiftgrammarInit()
	this := new(swiftgrammar)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &SwiftgrammarParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "swiftgrammar.g4"

	return this
}

// swiftgrammar tokens.
const (
	swiftgrammarEOF        = antlr.TokenEOF
	swiftgrammarPRINT_CON  = 1
	swiftgrammarT_NUMBER   = 2
	swiftgrammarT_FLOAT    = 3
	swiftgrammarT_STRING   = 4
	swiftgrammarT_BOOL     = 5
	swiftgrammarT_STR      = 6
	swiftgrammarT_CHAT     = 7
	swiftgrammarT_ARRAY    = 8
	swiftgrammarT_VECTOR   = 9
	swiftgrammarUSIZE      = 10
	swiftgrammarIF         = 11
	swiftgrammarELSE       = 12
	swiftgrammarWHILE      = 13
	swiftgrammarFOR        = 14
	swiftgrammarIN         = 15
	swiftgrammarBREAK      = 16
	swiftgrammarCONTINUE   = 17
	swiftgrammarSWITCH     = 18
	swiftgrammarMTOR       = 19
	swiftgrammarCASE       = 20
	swiftgrammarDEFAULT    = 21
	swiftgrammarTRUE       = 22
	swiftgrammarFALSE      = 23
	swiftgrammarAS         = 24
	swiftgrammarAT         = 25
	swiftgrammarLET        = 26
	swiftgrammarMUT        = 27
	swiftgrammarSTRUCT     = 28
	swiftgrammarCOUNT      = 29
	swiftgrammarNEW        = 30
	swiftgrammarCAPF       = 31
	swiftgrammarAPPEND     = 32
	swiftgrammarINSERT     = 33
	swiftgrammarREMOVE     = 34
	swiftgrammarMODULO     = 35
	swiftgrammarTYPETHEN   = 36
	swiftgrammarFN         = 37
	swiftgrammarRETURN     = 38
	swiftgrammarNUMBER     = 39
	swiftgrammarFLOAT      = 40
	swiftgrammarSTRING     = 41
	swiftgrammarPUNTO      = 42
	swiftgrammarCOMA       = 43
	swiftgrammarPTCOMA     = 44
	swiftgrammarDOSPUNTO   = 45
	swiftgrammarDPUNTO2    = 46
	swiftgrammarASIGNACION = 47
	swiftgrammarMTHEN      = 48
	swiftgrammarGUIONB     = 49
	swiftgrammarID         = 50
	swiftgrammarDISTINTO   = 51
	swiftgrammarIGUAL      = 52
	swiftgrammarMAYORIGUAL = 53
	swiftgrammarMENORIGUAL = 54
	swiftgrammarMAYOR      = 55
	swiftgrammarMENOR      = 56
	swiftgrammarASIG       = 57
	swiftgrammarMUL        = 58
	swiftgrammarDIV        = 59
	swiftgrammarADD        = 60
	swiftgrammarSUB        = 61
	swiftgrammarMOD        = 62
	swiftgrammarAND        = 63
	swiftgrammarOR         = 64
	swiftgrammarNOT        = 65
	swiftgrammarINTERROG   = 66
	swiftgrammarAMP        = 67
	swiftgrammarINOUT      = 68
	swiftgrammarPARIZQ     = 69
	swiftgrammarPARDER     = 70
	swiftgrammarLLAVEIZQ   = 71
	swiftgrammarLLAVEDER   = 72
	swiftgrammarCORIZQ     = 73
	swiftgrammarCORDER     = 74
	swiftgrammarCHAR       = 75
	swiftgrammarWHITESPACE = 76
	swiftgrammarL_COMMENT  = 77
	swiftgrammarCOMMENT    = 78
)

// swiftgrammar rules.
const (
	swiftgrammarRULE_start              = 0
	swiftgrammarRULE_instrucciones      = 1
	swiftgrammarRULE_listaglobal        = 2
	swiftgrammarRULE_in_global          = 3
	swiftgrammarRULE_modulo_item        = 4
	swiftgrammarRULE_funcion            = 5
	swiftgrammarRULE_params_declar      = 6
	swiftgrammarRULE_declar_parametros  = 7
	swiftgrammarRULE_fn_main            = 8
	swiftgrammarRULE_instruccion        = 9
	swiftgrammarRULE_instruccion_dentro = 10
	swiftgrammarRULE_appendVec          = 11
	swiftgrammarRULE_newStruct          = 12
	swiftgrammarRULE_lista_struct       = 13
	swiftgrammarRULE_callFunction       = 14
	swiftgrammarRULE_returnFun          = 15
	swiftgrammarRULE_printconsola       = 16
	swiftgrammarRULE_while_true         = 17
	swiftgrammarRULE_lWhile             = 18
	swiftgrammarRULE_lForin             = 19
	swiftgrammarRULE_lBreak             = 20
	swiftgrammarRULE_lContinue          = 21
	swiftgrammarRULE_listParams         = 22
	swiftgrammarRULE_listParamsCall     = 23
	swiftgrammarRULE_es_referencia      = 24
	swiftgrammarRULE_declaracion        = 25
	swiftgrammarRULE_es_var             = 26
	swiftgrammarRULE_es_varr            = 27
	swiftgrammarRULE_letid              = 28
	swiftgrammarRULE_vector_types       = 29
	swiftgrammarRULE_array_type         = 30
	swiftgrammarRULE_asignacion         = 31
	swiftgrammarRULE_l_AccessStruct     = 32
	swiftgrammarRULE_list_index         = 33
	swiftgrammarRULE_index_array        = 34
	swiftgrammarRULE_if_sent            = 35
	swiftgrammarRULE_if_exp             = 36
	swiftgrammarRULE_list_elseif        = 37
	swiftgrammarRULE_list_elseif_exp    = 38
	swiftgrammarRULE_else_if            = 39
	swiftgrammarRULE_else_if_exp        = 40
	swiftgrammarRULE_switch_sent        = 41
	swiftgrammarRULE_match_brazos       = 42
	swiftgrammarRULE_match_brazos_exp   = 43
	swiftgrammarRULE_matchbrazo         = 44
	swiftgrammarRULE_matchbrazo_exp     = 45
	swiftgrammarRULE_listaOpciones      = 46
	swiftgrammarRULE_bloque_inst        = 47
	swiftgrammarRULE_bloque_princip     = 48
	swiftgrammarRULE_bloque_exp         = 49
	swiftgrammarRULE_tipos_var          = 50
	swiftgrammarRULE_expression         = 51
	swiftgrammarRULE_expr_arit          = 52
	swiftgrammarRULE_casteo             = 53
	swiftgrammarRULE_tipo_cast          = 54
	swiftgrammarRULE_l_StructExp        = 55
	swiftgrammarRULE_primitivo          = 56
	swiftgrammarRULE_listIDArray        = 57
	swiftgrammarRULE_strings            = 58
)

// IStartContext is an interface to support dynamic dispatch.
type IStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_listaglobal returns the _listaglobal rule contexts.
	Get_listaglobal() IListaglobalContext

	// Set_listaglobal sets the _listaglobal rule contexts.
	Set_listaglobal(IListaglobalContext)

	// GetLista returns the lista attribute.
	GetLista() *arrayList.List

	// SetLista sets the lista attribute.
	SetLista(*arrayList.List)

	// Getter signatures
	Listaglobal() IListaglobalContext

	// IsStartContext differentiates from other interfaces.
	IsStartContext()
}

type StartContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	lista        *arrayList.List
	_listaglobal IListaglobalContext
}

func NewEmptyStartContext() *StartContext {
	var p = new(StartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_start
	return p
}

func InitEmptyStartContext(p *StartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_start
}

func (*StartContext) IsStartContext() {}

func NewStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartContext {
	var p = new(StartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_start

	return p
}

func (s *StartContext) GetParser() antlr.Parser { return s.parser }

func (s *StartContext) Get_listaglobal() IListaglobalContext { return s._listaglobal }

func (s *StartContext) Set_listaglobal(v IListaglobalContext) { s._listaglobal = v }

func (s *StartContext) GetLista() *arrayList.List { return s.lista }

func (s *StartContext) SetLista(v *arrayList.List) { s.lista = v }

func (s *StartContext) Listaglobal() IListaglobalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListaglobalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListaglobalContext)
}

func (s *StartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterStart(s)
	}
}

func (s *StartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitStart(s)
	}
}

func (p *swiftgrammar) Start_() (localctx IStartContext) {
	localctx = NewStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, swiftgrammarRULE_start)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(118)

		var _x = p.listaglobal(0)

		localctx.(*StartContext)._listaglobal = _x
	}
	localctx.(*StartContext).lista = localctx.(*StartContext).Get_listaglobal().GetLista()

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstruccionesContext is an interface to support dynamic dispatch.
type IInstruccionesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_instruccion returns the _instruccion rule contexts.
	Get_instruccion() IInstruccionContext

	// Set_instruccion sets the _instruccion rule contexts.
	Set_instruccion(IInstruccionContext)

	// GetE returns the e rule context list.
	GetE() []IInstruccionContext

	// SetE sets the e rule context list.
	SetE([]IInstruccionContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// Getter signatures
	AllInstruccion() []IInstruccionContext
	Instruccion(i int) IInstruccionContext

	// IsInstruccionesContext differentiates from other interfaces.
	IsInstruccionesContext()
}

type InstruccionesContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	l            *arrayList.List
	_instruccion IInstruccionContext
	e            []IInstruccionContext
}

func NewEmptyInstruccionesContext() *InstruccionesContext {
	var p = new(InstruccionesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_instrucciones
	return p
}

func InitEmptyInstruccionesContext(p *InstruccionesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_instrucciones
}

func (*InstruccionesContext) IsInstruccionesContext() {}

func NewInstruccionesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstruccionesContext {
	var p = new(InstruccionesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_instrucciones

	return p
}

func (s *InstruccionesContext) GetParser() antlr.Parser { return s.parser }

func (s *InstruccionesContext) Get_instruccion() IInstruccionContext { return s._instruccion }

func (s *InstruccionesContext) Set_instruccion(v IInstruccionContext) { s._instruccion = v }

func (s *InstruccionesContext) GetE() []IInstruccionContext { return s.e }

func (s *InstruccionesContext) SetE(v []IInstruccionContext) { s.e = v }

func (s *InstruccionesContext) GetL() *arrayList.List { return s.l }

func (s *InstruccionesContext) SetL(v *arrayList.List) { s.l = v }

func (s *InstruccionesContext) AllInstruccion() []IInstruccionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInstruccionContext); ok {
			len++
		}
	}

	tst := make([]IInstruccionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInstruccionContext); ok {
			tst[i] = t.(IInstruccionContext)
			i++
		}
	}

	return tst
}

func (s *InstruccionesContext) Instruccion(i int) IInstruccionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstruccionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstruccionContext)
}

func (s *InstruccionesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstruccionesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstruccionesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterInstrucciones(s)
	}
}

func (s *InstruccionesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitInstrucciones(s)
	}
}

func (p *swiftgrammar) Instrucciones() (localctx IInstruccionesContext) {
	localctx = NewInstruccionesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, swiftgrammarRULE_instrucciones)

	localctx.(*InstruccionesContext).l = arrayList.New()

	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(124)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		//goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1126175254996994) != 0 {
		{
			p.SetState(121)

			var _x = p.Instruccion()

			localctx.(*InstruccionesContext)._instruccion = _x
		}
		localctx.(*InstruccionesContext).e = append(localctx.(*InstruccionesContext).e, localctx.(*InstruccionesContext)._instruccion)

		p.SetState(126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			//goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	listInt := localctx.(*InstruccionesContext).GetE()
	for _, e := range listInt {
		localctx.(*InstruccionesContext).l.Add(e.GetInstr())
	}
	//fmt.Printf("tipo %T",localctx.(*InstruccionesContext).GetE())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListaglobalContext is an interface to support dynamic dispatch.
type IListaglobalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLisfun returns the lisfun rule contexts.
	GetLisfun() IListaglobalContext

	// Get_in_global returns the _in_global rule contexts.
	Get_in_global() IIn_globalContext

	// SetLisfun sets the lisfun rule contexts.
	SetLisfun(IListaglobalContext)

	// Set_in_global sets the _in_global rule contexts.
	Set_in_global(IIn_globalContext)

	// GetLista returns the lista attribute.
	GetLista() *arrayList.List

	// SetLista sets the lista attribute.
	SetLista(*arrayList.List)

	// Getter signatures
	In_global() IIn_globalContext
	Listaglobal() IListaglobalContext

	// IsListaglobalContext differentiates from other interfaces.
	IsListaglobalContext()
}

type ListaglobalContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	lista      *arrayList.List
	lisfun     IListaglobalContext
	_in_global IIn_globalContext
}

func NewEmptyListaglobalContext() *ListaglobalContext {
	var p = new(ListaglobalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_listaglobal
	return p
}

func InitEmptyListaglobalContext(p *ListaglobalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_listaglobal
}

func (*ListaglobalContext) IsListaglobalContext() {}

func NewListaglobalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListaglobalContext {
	var p = new(ListaglobalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_listaglobal

	return p
}

func (s *ListaglobalContext) GetParser() antlr.Parser { return s.parser }

func (s *ListaglobalContext) GetLisfun() IListaglobalContext { return s.lisfun }

func (s *ListaglobalContext) Get_in_global() IIn_globalContext { return s._in_global }

func (s *ListaglobalContext) SetLisfun(v IListaglobalContext) { s.lisfun = v }

func (s *ListaglobalContext) Set_in_global(v IIn_globalContext) { s._in_global = v }

func (s *ListaglobalContext) GetLista() *arrayList.List { return s.lista }

func (s *ListaglobalContext) SetLista(v *arrayList.List) { s.lista = v }

func (s *ListaglobalContext) In_global() IIn_globalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIn_globalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIn_globalContext)
}

func (s *ListaglobalContext) Listaglobal() IListaglobalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListaglobalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListaglobalContext)
}

func (s *ListaglobalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListaglobalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListaglobalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterListaglobal(s)
	}
}

func (s *ListaglobalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitListaglobal(s)
	}
}

func (p *swiftgrammar) Listaglobal() (localctx IListaglobalContext) {
	return p.listaglobal(0)
}

func (p *swiftgrammar) listaglobal(_p int) (localctx IListaglobalContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewListaglobalContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListaglobalContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 4
	p.EnterRecursionRule(localctx, 4, swiftgrammarRULE_listaglobal, _p)

	localctx.(*ListaglobalContext).lista = arrayList.New()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(130)

		var _x = p.In_global()

		localctx.(*ListaglobalContext)._in_global = _x
	}
	localctx.(*ListaglobalContext).lista.Add(localctx.(*ListaglobalContext).Get_in_global().GetGlobals())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListaglobalContext(p, _parentctx, _parentState)
			localctx.(*ListaglobalContext).lisfun = _prevctx
			p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_listaglobal)
			p.SetState(133)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(134)

				var _x = p.In_global()

				localctx.(*ListaglobalContext)._in_global = _x
			}

			localctx.(*ListaglobalContext).GetLisfun().GetLista().Add(localctx.(*ListaglobalContext).Get_in_global().GetGlobals())
			localctx.(*ListaglobalContext).lista = localctx.(*ListaglobalContext).GetLisfun().GetLista()

		}
		p.SetState(141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIn_globalContext is an interface to support dynamic dispatch.
type IIn_globalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_funcion returns the _funcion rule contexts.
	Get_funcion() IFuncionContext

	// Get_newStruct returns the _newStruct rule contexts.
	Get_newStruct() INewStructContext

	// Set_funcion sets the _funcion rule contexts.
	Set_funcion(IFuncionContext)

	// Set_newStruct sets the _newStruct rule contexts.
	Set_newStruct(INewStructContext)

	// GetGlobals returns the globals attribute.
	GetGlobals() interfaces.Instruction

	// SetGlobals sets the globals attribute.
	SetGlobals(interfaces.Instruction)

	// Getter signatures
	Funcion() IFuncionContext
	NewStruct() INewStructContext

	// IsIn_globalContext differentiates from other interfaces.
	IsIn_globalContext()
}

type In_globalContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	globals    interfaces.Instruction
	_funcion   IFuncionContext
	_newStruct INewStructContext
}

func NewEmptyIn_globalContext() *In_globalContext {
	var p = new(In_globalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_in_global
	return p
}

func InitEmptyIn_globalContext(p *In_globalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_in_global
}

func (*In_globalContext) IsIn_globalContext() {}

func NewIn_globalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *In_globalContext {
	var p = new(In_globalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_in_global

	return p
}

func (s *In_globalContext) GetParser() antlr.Parser { return s.parser }

func (s *In_globalContext) Get_funcion() IFuncionContext { return s._funcion }

func (s *In_globalContext) Get_newStruct() INewStructContext { return s._newStruct }

func (s *In_globalContext) Set_funcion(v IFuncionContext) { s._funcion = v }

func (s *In_globalContext) Set_newStruct(v INewStructContext) { s._newStruct = v }

func (s *In_globalContext) GetGlobals() interfaces.Instruction { return s.globals }

func (s *In_globalContext) SetGlobals(v interfaces.Instruction) { s.globals = v }

func (s *In_globalContext) Funcion() IFuncionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncionContext)
}

func (s *In_globalContext) NewStruct() INewStructContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewStructContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewStructContext)
}

func (s *In_globalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_globalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *In_globalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterIn_global(s)
	}
}

func (s *In_globalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitIn_global(s)
	}
}

func (p *swiftgrammar) In_global() (localctx IIn_globalContext) {
	localctx = NewIn_globalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, swiftgrammarRULE_in_global)
	p.SetState(148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(142)

			var _x = p.Funcion()

			localctx.(*In_globalContext)._funcion = _x
		}
		localctx.(*In_globalContext).globals = localctx.(*In_globalContext).Get_funcion().GetInstr()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(145)

			var _x = p.NewStruct()

			localctx.(*In_globalContext)._newStruct = _x
		}
		localctx.(*In_globalContext).globals = localctx.(*In_globalContext).Get_newStruct().GetStr()

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModulo_itemContext is an interface to support dynamic dispatch.
type IModulo_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_funcion returns the _funcion rule contexts.
	Get_funcion() IFuncionContext

	// Get_newStruct returns the _newStruct rule contexts.
	Get_newStruct() INewStructContext

	// Set_funcion sets the _funcion rule contexts.
	Set_funcion(IFuncionContext)

	// Set_newStruct sets the _newStruct rule contexts.
	Set_newStruct(INewStructContext)

	// GetInstr returns the instr attribute.
	GetInstr() interfaces.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(interfaces.Instruction)

	// Getter signatures
	Funcion() IFuncionContext
	NewStruct() INewStructContext

	// IsModulo_itemContext differentiates from other interfaces.
	IsModulo_itemContext()
}

type Modulo_itemContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	instr      interfaces.Instruction
	_funcion   IFuncionContext
	_newStruct INewStructContext
}

func NewEmptyModulo_itemContext() *Modulo_itemContext {
	var p = new(Modulo_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_modulo_item
	return p
}

func InitEmptyModulo_itemContext(p *Modulo_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_modulo_item
}

func (*Modulo_itemContext) IsModulo_itemContext() {}

func NewModulo_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modulo_itemContext {
	var p = new(Modulo_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_modulo_item

	return p
}

func (s *Modulo_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Modulo_itemContext) Get_funcion() IFuncionContext { return s._funcion }

func (s *Modulo_itemContext) Get_newStruct() INewStructContext { return s._newStruct }

func (s *Modulo_itemContext) Set_funcion(v IFuncionContext) { s._funcion = v }

func (s *Modulo_itemContext) Set_newStruct(v INewStructContext) { s._newStruct = v }

func (s *Modulo_itemContext) GetInstr() interfaces.Instruction { return s.instr }

func (s *Modulo_itemContext) SetInstr(v interfaces.Instruction) { s.instr = v }

func (s *Modulo_itemContext) Funcion() IFuncionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncionContext)
}

func (s *Modulo_itemContext) NewStruct() INewStructContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewStructContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewStructContext)
}

func (s *Modulo_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modulo_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modulo_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterModulo_item(s)
	}
}

func (s *Modulo_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitModulo_item(s)
	}
}

func (p *swiftgrammar) Modulo_item() (localctx IModulo_itemContext) {
	localctx = NewModulo_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, swiftgrammarRULE_modulo_item)
	p.SetState(156)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(150)

			var _x = p.Funcion()

			localctx.(*Modulo_itemContext)._funcion = _x
		}
		localctx.(*Modulo_itemContext).instr = localctx.(*Modulo_itemContext).Get_funcion().GetInstr()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(153)

			var _x = p.NewStruct()

			localctx.(*Modulo_itemContext)._newStruct = _x
		}
		localctx.(*Modulo_itemContext).instr = localctx.(*Modulo_itemContext).Get_newStruct().GetStr()

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFuncionContext is an interface to support dynamic dispatch.
type IFuncionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// GetIdob returns the idob token.
	GetIdob() antlr.Token

	// GetId returns the id token.
	GetId() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// SetIdob sets the idob token.
	SetIdob(antlr.Token)

	// SetId sets the id token.
	SetId(antlr.Token)

	// Get_fn_main returns the _fn_main rule contexts.
	Get_fn_main() IFn_mainContext

	// Get_tipos_var returns the _tipos_var rule contexts.
	Get_tipos_var() ITipos_varContext

	// Get_bloque_inst returns the _bloque_inst rule contexts.
	Get_bloque_inst() IBloque_instContext

	// Get_params_declar returns the _params_declar rule contexts.
	Get_params_declar() IParams_declarContext

	// Set_fn_main sets the _fn_main rule contexts.
	Set_fn_main(IFn_mainContext)

	// Set_tipos_var sets the _tipos_var rule contexts.
	Set_tipos_var(ITipos_varContext)

	// Set_bloque_inst sets the _bloque_inst rule contexts.
	Set_bloque_inst(IBloque_instContext)

	// Set_params_declar sets the _params_declar rule contexts.
	Set_params_declar(IParams_declarContext)

	// GetInstr returns the instr attribute.
	GetInstr() interfaces.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(interfaces.Instruction)

	// Getter signatures
	Fn_main() IFn_mainContext
	FN() antlr.TerminalNode
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	PARDER() antlr.TerminalNode
	TYPETHEN() antlr.TerminalNode
	Tipos_var() ITipos_varContext
	Bloque_inst() IBloque_instContext
	Params_declar() IParams_declarContext

	// IsFuncionContext differentiates from other interfaces.
	IsFuncionContext()
}

type FuncionContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	instr          interfaces.Instruction
	_fn_main       IFn_mainContext
	_ID            antlr.Token
	_tipos_var     ITipos_varContext
	_bloque_inst   IBloque_instContext
	idob           antlr.Token
	_params_declar IParams_declarContext
	id             antlr.Token
}

func NewEmptyFuncionContext() *FuncionContext {
	var p = new(FuncionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_funcion
	return p
}

func InitEmptyFuncionContext(p *FuncionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_funcion
}

func (*FuncionContext) IsFuncionContext() {}

func NewFuncionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncionContext {
	var p = new(FuncionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_funcion

	return p
}

func (s *FuncionContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncionContext) Get_ID() antlr.Token { return s._ID }

func (s *FuncionContext) GetIdob() antlr.Token { return s.idob }

func (s *FuncionContext) GetId() antlr.Token { return s.id }

func (s *FuncionContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *FuncionContext) SetIdob(v antlr.Token) { s.idob = v }

func (s *FuncionContext) SetId(v antlr.Token) { s.id = v }

func (s *FuncionContext) Get_fn_main() IFn_mainContext { return s._fn_main }

func (s *FuncionContext) Get_tipos_var() ITipos_varContext { return s._tipos_var }

func (s *FuncionContext) Get_bloque_inst() IBloque_instContext { return s._bloque_inst }

func (s *FuncionContext) Get_params_declar() IParams_declarContext { return s._params_declar }

func (s *FuncionContext) Set_fn_main(v IFn_mainContext) { s._fn_main = v }

func (s *FuncionContext) Set_tipos_var(v ITipos_varContext) { s._tipos_var = v }

func (s *FuncionContext) Set_bloque_inst(v IBloque_instContext) { s._bloque_inst = v }

func (s *FuncionContext) Set_params_declar(v IParams_declarContext) { s._params_declar = v }

func (s *FuncionContext) GetInstr() interfaces.Instruction { return s.instr }

func (s *FuncionContext) SetInstr(v interfaces.Instruction) { s.instr = v }

func (s *FuncionContext) Fn_main() IFn_mainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFn_mainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFn_mainContext)
}

func (s *FuncionContext) FN() antlr.TerminalNode {
	return s.GetToken(swiftgrammarFN, 0)
}

func (s *FuncionContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(swiftgrammarID)
}

func (s *FuncionContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, i)
}

func (s *FuncionContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARIZQ, 0)
}

func (s *FuncionContext) PARDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARDER, 0)
}

func (s *FuncionContext) TYPETHEN() antlr.TerminalNode {
	return s.GetToken(swiftgrammarTYPETHEN, 0)
}

func (s *FuncionContext) Tipos_var() ITipos_varContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipos_varContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipos_varContext)
}

func (s *FuncionContext) Bloque_inst() IBloque_instContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBloque_instContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBloque_instContext)
}

func (s *FuncionContext) Params_declar() IParams_declarContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParams_declarContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParams_declarContext)
}

func (s *FuncionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterFuncion(s)
	}
}

func (s *FuncionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitFuncion(s)
	}
}

func (p *swiftgrammar) Funcion() (localctx IFuncionContext) {
	localctx = NewFuncionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, swiftgrammarRULE_funcion)
	listParams := arrayList.New()
	p.SetState(214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(158)

			var _x = p.Fn_main()

			localctx.(*FuncionContext)._fn_main = _x
		}
		localctx.(*FuncionContext).instr = localctx.(*FuncionContext).Get_fn_main().GetInstr()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(161)
			p.Match(swiftgrammarFN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(162)

			var _m = p.Match(swiftgrammarID)

			localctx.(*FuncionContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(163)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(164)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(165)
			p.Match(swiftgrammarTYPETHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(166)

			var _x = p.Tipos_var()

			localctx.(*FuncionContext)._tipos_var = _x
		}
		{
			p.SetState(167)

			var _x = p.Bloque_inst()

			localctx.(*FuncionContext)._bloque_inst = _x
		}
		localctx.(*FuncionContext).instr = instructionExpre.NewFunction((func() string {
			if localctx.(*FuncionContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*FuncionContext).Get_ID().GetText()
			}
		}()), listParams, localctx.(*FuncionContext).Get_bloque_inst().GetL(), localctx.(*FuncionContext).Get_tipos_var().GetTipo(), (func() int {
			if localctx.(*FuncionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*FuncionContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*FuncionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*FuncionContext).Get_ID().GetColumn()
			}
		}()), "")

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(170)
			p.Match(swiftgrammarFN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(171)

			var _m = p.Match(swiftgrammarID)

			localctx.(*FuncionContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(172)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(173)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(174)
			p.Match(swiftgrammarTYPETHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(175)

			var _m = p.Match(swiftgrammarID)

			localctx.(*FuncionContext).idob = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(176)

			var _x = p.Bloque_inst()

			localctx.(*FuncionContext)._bloque_inst = _x
		}
		localctx.(*FuncionContext).instr = instructionExpre.NewFunction((func() string {
			if localctx.(*FuncionContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*FuncionContext).Get_ID().GetText()
			}
		}()), listParams, localctx.(*FuncionContext).Get_bloque_inst().GetL(), interfaces.VOID, (func() int {
			if localctx.(*FuncionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*FuncionContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*FuncionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*FuncionContext).Get_ID().GetColumn()
			}
		}()), (func() string {
			if localctx.(*FuncionContext).GetIdob() == nil {
				return ""
			} else {
				return localctx.(*FuncionContext).GetIdob().GetText()
			}
		}()))

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(179)
			p.Match(swiftgrammarFN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(180)

			var _m = p.Match(swiftgrammarID)

			localctx.(*FuncionContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(181)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(182)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(183)

			var _x = p.Bloque_inst()

			localctx.(*FuncionContext)._bloque_inst = _x
		}
		localctx.(*FuncionContext).instr = instructionExpre.NewFunction((func() string {
			if localctx.(*FuncionContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*FuncionContext).Get_ID().GetText()
			}
		}()), listParams, localctx.(*FuncionContext).Get_bloque_inst().GetL(), interfaces.VOID, (func() int {
			if localctx.(*FuncionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*FuncionContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*FuncionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*FuncionContext).Get_ID().GetColumn()
			}
		}()), "")

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(186)
			p.Match(swiftgrammarFN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(187)

			var _m = p.Match(swiftgrammarID)

			localctx.(*FuncionContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(188)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(189)

			var _x = p.params_declar(0)

			localctx.(*FuncionContext)._params_declar = _x
		}
		{
			p.SetState(190)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(191)

			var _x = p.Bloque_inst()

			localctx.(*FuncionContext)._bloque_inst = _x
		}
		localctx.(*FuncionContext).instr = instructionExpre.NewFunction((func() string {
			if localctx.(*FuncionContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*FuncionContext).Get_ID().GetText()
			}
		}()), localctx.(*FuncionContext).Get_params_declar().GetLista(), localctx.(*FuncionContext).Get_bloque_inst().GetL(), interfaces.VOID, (func() int {
			if localctx.(*FuncionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*FuncionContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*FuncionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*FuncionContext).Get_ID().GetColumn()
			}
		}()), "")

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(194)
			p.Match(swiftgrammarFN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(195)

			var _m = p.Match(swiftgrammarID)

			localctx.(*FuncionContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(196)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(197)

			var _x = p.params_declar(0)

			localctx.(*FuncionContext)._params_declar = _x
		}
		{
			p.SetState(198)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(199)
			p.Match(swiftgrammarTYPETHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(200)

			var _x = p.Tipos_var()

			localctx.(*FuncionContext)._tipos_var = _x
		}
		{
			p.SetState(201)

			var _x = p.Bloque_inst()

			localctx.(*FuncionContext)._bloque_inst = _x
		}
		localctx.(*FuncionContext).instr = instructionExpre.NewFunction((func() string {
			if localctx.(*FuncionContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*FuncionContext).Get_ID().GetText()
			}
		}()), localctx.(*FuncionContext).Get_params_declar().GetLista(), localctx.(*FuncionContext).Get_bloque_inst().GetL(), localctx.(*FuncionContext).Get_tipos_var().GetTipo(), (func() int {
			if localctx.(*FuncionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*FuncionContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*FuncionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*FuncionContext).Get_ID().GetColumn()
			}
		}()), "")

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(204)
			p.Match(swiftgrammarFN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(205)

			var _m = p.Match(swiftgrammarID)

			localctx.(*FuncionContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(206)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(207)

			var _x = p.params_declar(0)

			localctx.(*FuncionContext)._params_declar = _x
		}
		{
			p.SetState(208)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(209)
			p.Match(swiftgrammarTYPETHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(210)

			var _m = p.Match(swiftgrammarID)

			localctx.(*FuncionContext).idob = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(211)

			var _x = p.Bloque_inst()

			localctx.(*FuncionContext)._bloque_inst = _x
		}
		localctx.(*FuncionContext).instr = instructionExpre.NewFunction((func() string {
			if localctx.(*FuncionContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*FuncionContext).GetId().GetText()
			}
		}()), localctx.(*FuncionContext).Get_params_declar().GetLista(), localctx.(*FuncionContext).Get_bloque_inst().GetL(), interfaces.VOID, (func() int {
			if localctx.(*FuncionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*FuncionContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*FuncionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*FuncionContext).GetId().GetColumn()
			}
		}()), (func() string {
			if localctx.(*FuncionContext).GetIdob() == nil {
				return ""
			} else {
				return localctx.(*FuncionContext).GetIdob().GetText()
			}
		}()))

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParams_declarContext is an interface to support dynamic dispatch.
type IParams_declarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetListdec returns the listdec rule contexts.
	GetListdec() IParams_declarContext

	// Get_declar_parametros returns the _declar_parametros rule contexts.
	Get_declar_parametros() IDeclar_parametrosContext

	// SetListdec sets the listdec rule contexts.
	SetListdec(IParams_declarContext)

	// Set_declar_parametros sets the _declar_parametros rule contexts.
	Set_declar_parametros(IDeclar_parametrosContext)

	// GetLista returns the lista attribute.
	GetLista() *arrayList.List

	// SetLista sets the lista attribute.
	SetLista(*arrayList.List)

	// Getter signatures
	Declar_parametros() IDeclar_parametrosContext
	COMA() antlr.TerminalNode
	Params_declar() IParams_declarContext

	// IsParams_declarContext differentiates from other interfaces.
	IsParams_declarContext()
}

type Params_declarContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	lista              *arrayList.List
	listdec            IParams_declarContext
	_declar_parametros IDeclar_parametrosContext
}

func NewEmptyParams_declarContext() *Params_declarContext {
	var p = new(Params_declarContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_params_declar
	return p
}

func InitEmptyParams_declarContext(p *Params_declarContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_params_declar
}

func (*Params_declarContext) IsParams_declarContext() {}

func NewParams_declarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Params_declarContext {
	var p = new(Params_declarContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_params_declar

	return p
}

func (s *Params_declarContext) GetParser() antlr.Parser { return s.parser }

func (s *Params_declarContext) GetListdec() IParams_declarContext { return s.listdec }

func (s *Params_declarContext) Get_declar_parametros() IDeclar_parametrosContext {
	return s._declar_parametros
}

func (s *Params_declarContext) SetListdec(v IParams_declarContext) { s.listdec = v }

func (s *Params_declarContext) Set_declar_parametros(v IDeclar_parametrosContext) {
	s._declar_parametros = v
}

func (s *Params_declarContext) GetLista() *arrayList.List { return s.lista }

func (s *Params_declarContext) SetLista(v *arrayList.List) { s.lista = v }

func (s *Params_declarContext) Declar_parametros() IDeclar_parametrosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclar_parametrosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclar_parametrosContext)
}

func (s *Params_declarContext) COMA() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCOMA, 0)
}

func (s *Params_declarContext) Params_declar() IParams_declarContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParams_declarContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParams_declarContext)
}

func (s *Params_declarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Params_declarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Params_declarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterParams_declar(s)
	}
}

func (s *Params_declarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitParams_declar(s)
	}
}

func (p *swiftgrammar) Params_declar() (localctx IParams_declarContext) {
	return p.params_declar(0)
}

func (p *swiftgrammar) params_declar(_p int) (localctx IParams_declarContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewParams_declarContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IParams_declarContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 12
	p.EnterRecursionRule(localctx, 12, swiftgrammarRULE_params_declar, _p)

	localctx.(*Params_declarContext).lista = arrayList.New()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(217)

		var _x = p.Declar_parametros()

		localctx.(*Params_declarContext)._declar_parametros = _x
	}
	localctx.(*Params_declarContext).lista.Add(localctx.(*Params_declarContext).Get_declar_parametros().GetIn_dec())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(227)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewParams_declarContext(p, _parentctx, _parentState)
			localctx.(*Params_declarContext).listdec = _prevctx
			p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_params_declar)
			p.SetState(220)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(221)
				p.Match(swiftgrammarCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(222)

				var _x = p.Declar_parametros()

				localctx.(*Params_declarContext)._declar_parametros = _x
			}

			localctx.(*Params_declarContext).GetListdec().GetLista().Add(localctx.(*Params_declarContext).Get_declar_parametros().GetIn_dec())
			localctx.(*Params_declarContext).lista = localctx.(*Params_declarContext).GetListdec().GetLista()

		}
		p.SetState(229)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclar_parametrosContext is an interface to support dynamic dispatch.
type IDeclar_parametrosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// GetId returns the id token.
	GetId() antlr.Token

	// GetIdob returns the idob token.
	GetIdob() antlr.Token

	// GetIdstruct returns the idstruct token.
	GetIdstruct() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// SetId sets the id token.
	SetId(antlr.Token)

	// SetIdob sets the idob token.
	SetIdob(antlr.Token)

	// SetIdstruct sets the idstruct token.
	SetIdstruct(antlr.Token)

	// GetIsVar returns the isVar rule contexts.
	GetIsVar() IEs_varContext

	// Get_tipos_var returns the _tipos_var rule contexts.
	Get_tipos_var() ITipos_varContext

	// Get_es_referencia returns the _es_referencia rule contexts.
	Get_es_referencia() IEs_referenciaContext

	// Get_array_type returns the _array_type rule contexts.
	Get_array_type() IArray_typeContext

	// GetIsRef returns the isRef rule contexts.
	GetIsRef() IEs_varContext

	// SetIsVar sets the isVar rule contexts.
	SetIsVar(IEs_varContext)

	// Set_tipos_var sets the _tipos_var rule contexts.
	Set_tipos_var(ITipos_varContext)

	// Set_es_referencia sets the _es_referencia rule contexts.
	Set_es_referencia(IEs_referenciaContext)

	// Set_array_type sets the _array_type rule contexts.
	Set_array_type(IArray_typeContext)

	// SetIsRef sets the isRef rule contexts.
	SetIsRef(IEs_varContext)

	// GetIn_dec returns the in_dec attribute.
	GetIn_dec() interfaces.Instruction

	// SetIn_dec sets the in_dec attribute.
	SetIn_dec(interfaces.Instruction)

	// Getter signatures
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	DPUNTO2() antlr.TerminalNode
	Tipos_var() ITipos_varContext
	Es_var() IEs_varContext
	Es_referencia() IEs_referenciaContext
	CORIZQ() antlr.TerminalNode
	CORDER() antlr.TerminalNode
	INOUT() antlr.TerminalNode
	Array_type() IArray_typeContext

	// IsDeclar_parametrosContext differentiates from other interfaces.
	IsDeclar_parametrosContext()
}

type Declar_parametrosContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	in_dec         interfaces.Instruction
	isVar          IEs_varContext
	_ID            antlr.Token
	_tipos_var     ITipos_varContext
	id             antlr.Token
	_es_referencia IEs_referenciaContext
	idob           antlr.Token
	_array_type    IArray_typeContext
	idstruct       antlr.Token
	isRef          IEs_varContext
}

func NewEmptyDeclar_parametrosContext() *Declar_parametrosContext {
	var p = new(Declar_parametrosContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_declar_parametros
	return p
}

func InitEmptyDeclar_parametrosContext(p *Declar_parametrosContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_declar_parametros
}

func (*Declar_parametrosContext) IsDeclar_parametrosContext() {}

func NewDeclar_parametrosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declar_parametrosContext {
	var p = new(Declar_parametrosContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_declar_parametros

	return p
}

func (s *Declar_parametrosContext) GetParser() antlr.Parser { return s.parser }

func (s *Declar_parametrosContext) Get_ID() antlr.Token { return s._ID }

func (s *Declar_parametrosContext) GetId() antlr.Token { return s.id }

func (s *Declar_parametrosContext) GetIdob() antlr.Token { return s.idob }

func (s *Declar_parametrosContext) GetIdstruct() antlr.Token { return s.idstruct }

func (s *Declar_parametrosContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *Declar_parametrosContext) SetId(v antlr.Token) { s.id = v }

func (s *Declar_parametrosContext) SetIdob(v antlr.Token) { s.idob = v }

func (s *Declar_parametrosContext) SetIdstruct(v antlr.Token) { s.idstruct = v }

func (s *Declar_parametrosContext) GetIsVar() IEs_varContext { return s.isVar }

func (s *Declar_parametrosContext) Get_tipos_var() ITipos_varContext { return s._tipos_var }

func (s *Declar_parametrosContext) Get_es_referencia() IEs_referenciaContext { return s._es_referencia }

func (s *Declar_parametrosContext) Get_array_type() IArray_typeContext { return s._array_type }

func (s *Declar_parametrosContext) GetIsRef() IEs_varContext { return s.isRef }

func (s *Declar_parametrosContext) SetIsVar(v IEs_varContext) { s.isVar = v }

func (s *Declar_parametrosContext) Set_tipos_var(v ITipos_varContext) { s._tipos_var = v }

func (s *Declar_parametrosContext) Set_es_referencia(v IEs_referenciaContext) { s._es_referencia = v }

func (s *Declar_parametrosContext) Set_array_type(v IArray_typeContext) { s._array_type = v }

func (s *Declar_parametrosContext) SetIsRef(v IEs_varContext) { s.isRef = v }

func (s *Declar_parametrosContext) GetIn_dec() interfaces.Instruction { return s.in_dec }

func (s *Declar_parametrosContext) SetIn_dec(v interfaces.Instruction) { s.in_dec = v }

func (s *Declar_parametrosContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(swiftgrammarID)
}

func (s *Declar_parametrosContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, i)
}

func (s *Declar_parametrosContext) DPUNTO2() antlr.TerminalNode {
	return s.GetToken(swiftgrammarDPUNTO2, 0)
}

func (s *Declar_parametrosContext) Tipos_var() ITipos_varContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipos_varContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipos_varContext)
}

func (s *Declar_parametrosContext) Es_var() IEs_varContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEs_varContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEs_varContext)
}

func (s *Declar_parametrosContext) Es_referencia() IEs_referenciaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEs_referenciaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEs_referenciaContext)
}

func (s *Declar_parametrosContext) CORIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORIZQ, 0)
}

func (s *Declar_parametrosContext) CORDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORDER, 0)
}

func (s *Declar_parametrosContext) INOUT() antlr.TerminalNode {
	return s.GetToken(swiftgrammarINOUT, 0)
}

func (s *Declar_parametrosContext) Array_type() IArray_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_typeContext)
}

func (s *Declar_parametrosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declar_parametrosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declar_parametrosContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterDeclar_parametros(s)
	}
}

func (s *Declar_parametrosContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitDeclar_parametros(s)
	}
}

func (p *swiftgrammar) Declar_parametros() (localctx IDeclar_parametrosContext) {
	localctx = NewDeclar_parametrosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, swiftgrammarRULE_declar_parametros)
	p.SetState(272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(230)

			var _x = p.Es_var()

			localctx.(*Declar_parametrosContext).isVar = _x
		}
		{
			p.SetState(231)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Declar_parametrosContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(232)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(233)

			var _x = p.Tipos_var()

			localctx.(*Declar_parametrosContext)._tipos_var = _x
		}

		listaIdes := arrayList.New()
		listaIdes.Add(expresion.NewIdentificador((func() string {
			if localctx.(*Declar_parametrosContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Declar_parametrosContext).Get_ID().GetText()
			}
		}()), (func() int {
			if localctx.(*Declar_parametrosContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*Declar_parametrosContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).Get_ID().GetColumn()
			}
		}())))
		decl := instruction.NewDeclaration((func() string {
			if localctx.(*Declar_parametrosContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Declar_parametrosContext).Get_ID().GetText()
			}
		}()), localctx.(*Declar_parametrosContext).Get_tipos_var().GetTipo(), nil, localctx.(*Declar_parametrosContext).GetIsVar().GetMut(), (func() int {
			if localctx.(*Declar_parametrosContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*Declar_parametrosContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).Get_ID().GetColumn()
			}
		}()))
		localctx.(*Declar_parametrosContext).in_dec = decl

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(236)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Declar_parametrosContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(237)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(238)

			var _x = p.Es_referencia()

			localctx.(*Declar_parametrosContext)._es_referencia = _x
		}
		{
			p.SetState(239)
			p.Match(swiftgrammarCORIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(240)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Declar_parametrosContext).idob = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(241)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		decl := instruction.NewVectorDeclaration((func() string {
			if localctx.(*Declar_parametrosContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*Declar_parametrosContext).GetId().GetText()
			}
		}()), interfaces.NULL, nil, localctx.(*Declar_parametrosContext).Get_es_referencia().GetRef(), (func() int {
			if localctx.(*Declar_parametrosContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*Declar_parametrosContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).GetId().GetColumn()
			}
		}()), nil, (func() string {
			if localctx.(*Declar_parametrosContext).GetIdob() == nil {
				return ""
			} else {
				return localctx.(*Declar_parametrosContext).GetIdob().GetText()
			}
		}()))
		localctx.(*Declar_parametrosContext).in_dec = decl

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(244)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Declar_parametrosContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(245)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(246)

			var _x = p.Es_referencia()

			localctx.(*Declar_parametrosContext)._es_referencia = _x
		}
		{
			p.SetState(247)
			p.Match(swiftgrammarCORIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(248)

			var _x = p.Tipos_var()

			localctx.(*Declar_parametrosContext)._tipos_var = _x
		}
		{
			p.SetState(249)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		decl := instruction.NewVectorDeclaration((func() string {
			if localctx.(*Declar_parametrosContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*Declar_parametrosContext).GetId().GetText()
			}
		}()), localctx.(*Declar_parametrosContext).Get_tipos_var().GetTipo(), nil, localctx.(*Declar_parametrosContext).Get_es_referencia().GetRef(), (func() int {
			if localctx.(*Declar_parametrosContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*Declar_parametrosContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).GetId().GetColumn()
			}
		}()), nil, "")
		localctx.(*Declar_parametrosContext).in_dec = decl

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(252)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Declar_parametrosContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(253)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(254)
			p.Match(swiftgrammarINOUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(255)

			var _x = p.Array_type()

			localctx.(*Declar_parametrosContext)._array_type = _x
		}

		listaIdes := arrayList.New()
		listaIdes.Add(expresion.NewIdentificador((func() string {
			if localctx.(*Declar_parametrosContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Declar_parametrosContext).Get_ID().GetText()
			}
		}()), (func() int {
			if localctx.(*Declar_parametrosContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*Declar_parametrosContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).Get_ID().GetColumn()
			}
		}())))
		decl := instruction.NewArrayDeclaration((func() string {
			if localctx.(*Declar_parametrosContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Declar_parametrosContext).Get_ID().GetText()
			}
		}()), localctx.(*Declar_parametrosContext).Get_array_type().GetTy(), nil, true, (func() int {
			if localctx.(*Declar_parametrosContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*Declar_parametrosContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).Get_ID().GetColumn()
			}
		}()))
		localctx.(*Declar_parametrosContext).in_dec = decl

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(258)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Declar_parametrosContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(259)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(260)

			var _x = p.Es_referencia()

			localctx.(*Declar_parametrosContext)._es_referencia = _x
		}
		{
			p.SetState(261)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Declar_parametrosContext).idstruct = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		decl := instruction.NewDeclaration((func() string {
			if localctx.(*Declar_parametrosContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*Declar_parametrosContext).GetId().GetText()
			}
		}()), interfaces.STRUCT, nil, localctx.(*Declar_parametrosContext).Get_es_referencia().GetRef(), (func() int {
			if localctx.(*Declar_parametrosContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*Declar_parametrosContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).GetId().GetColumn()
			}
		}()))
		localctx.(*Declar_parametrosContext).in_dec = decl

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(264)

			var _x = p.Es_var()

			localctx.(*Declar_parametrosContext).isRef = _x
		}
		{
			p.SetState(265)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Declar_parametrosContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(266)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(267)
			p.Match(swiftgrammarCORIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(268)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Declar_parametrosContext).idob = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(269)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		decl := instruction.NewVectorDeclaration((func() string {
			if localctx.(*Declar_parametrosContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*Declar_parametrosContext).GetId().GetText()
			}
		}()), interfaces.NULL, nil, localctx.(*Declar_parametrosContext).GetIsRef().GetMut(), (func() int {
			if localctx.(*Declar_parametrosContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*Declar_parametrosContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*Declar_parametrosContext).GetId().GetColumn()
			}
		}()), nil, (func() string {
			if localctx.(*Declar_parametrosContext).GetIdob() == nil {
				return ""
			} else {
				return localctx.(*Declar_parametrosContext).GetIdob().GetText()
			}
		}()))
		localctx.(*Declar_parametrosContext).in_dec = decl

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFn_mainContext is an interface to support dynamic dispatch.
type IFn_mainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_bloque_princip returns the _bloque_princip rule contexts.
	Get_bloque_princip() IBloque_principContext

	// Set_bloque_princip sets the _bloque_princip rule contexts.
	Set_bloque_princip(IBloque_principContext)

	// GetInstr returns the instr attribute.
	GetInstr() interfaces.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(interfaces.Instruction)

	// Getter signatures
	Bloque_princip() IBloque_principContext
	PUNTO() antlr.TerminalNode

	// IsFn_mainContext differentiates from other interfaces.
	IsFn_mainContext()
}

type Fn_mainContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	instr           interfaces.Instruction
	_bloque_princip IBloque_principContext
}

func NewEmptyFn_mainContext() *Fn_mainContext {
	var p = new(Fn_mainContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_fn_main
	return p
}

func InitEmptyFn_mainContext(p *Fn_mainContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_fn_main
}

func (*Fn_mainContext) IsFn_mainContext() {}

func NewFn_mainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fn_mainContext {
	var p = new(Fn_mainContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_fn_main

	return p
}

func (s *Fn_mainContext) GetParser() antlr.Parser { return s.parser }

func (s *Fn_mainContext) Get_bloque_princip() IBloque_principContext { return s._bloque_princip }

func (s *Fn_mainContext) Set_bloque_princip(v IBloque_principContext) { s._bloque_princip = v }

func (s *Fn_mainContext) GetInstr() interfaces.Instruction { return s.instr }

func (s *Fn_mainContext) SetInstr(v interfaces.Instruction) { s.instr = v }

func (s *Fn_mainContext) Bloque_princip() IBloque_principContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBloque_principContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBloque_principContext)
}

func (s *Fn_mainContext) PUNTO() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPUNTO, 0)
}

func (s *Fn_mainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fn_mainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fn_mainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterFn_main(s)
	}
}

func (s *Fn_mainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitFn_main(s)
	}
}

func (p *swiftgrammar) Fn_main() (localctx IFn_mainContext) {
	localctx = NewFn_mainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, swiftgrammarRULE_fn_main)
	listParams := arrayList.New()
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(274)

		var _x = p.Bloque_princip()

		localctx.(*Fn_mainContext)._bloque_princip = _x
	}
	{
		p.SetState(275)
		p.Match(swiftgrammarPUNTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*Fn_mainContext).instr = instructionExpre.NewFunction("main", listParams, localctx.(*Fn_mainContext).Get_bloque_princip().GetL(), interfaces.VOID, 0, 0, "")

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstruccionContext is an interface to support dynamic dispatch.
type IInstruccionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_printconsola returns the _printconsola rule contexts.
	Get_printconsola() IPrintconsolaContext

	// Get_declaracion returns the _declaracion rule contexts.
	Get_declaracion() IDeclaracionContext

	// Get_asignacion returns the _asignacion rule contexts.
	Get_asignacion() IAsignacionContext

	// Get_appendVec returns the _appendVec rule contexts.
	Get_appendVec() IAppendVecContext

	// Get_if_sent returns the _if_sent rule contexts.
	Get_if_sent() IIf_sentContext

	// Get_switch_sent returns the _switch_sent rule contexts.
	Get_switch_sent() ISwitch_sentContext

	// Get_while_true returns the _while_true rule contexts.
	Get_while_true() IWhile_trueContext

	// Get_lWhile returns the _lWhile rule contexts.
	Get_lWhile() ILWhileContext

	// Get_lForin returns the _lForin rule contexts.
	Get_lForin() ILForinContext

	// Get_lBreak returns the _lBreak rule contexts.
	Get_lBreak() ILBreakContext

	// Get_lContinue returns the _lContinue rule contexts.
	Get_lContinue() ILContinueContext

	// Get_newStruct returns the _newStruct rule contexts.
	Get_newStruct() INewStructContext

	// Get_callFunction returns the _callFunction rule contexts.
	Get_callFunction() ICallFunctionContext

	// Get_returnFun returns the _returnFun rule contexts.
	Get_returnFun() IReturnFunContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_printconsola sets the _printconsola rule contexts.
	Set_printconsola(IPrintconsolaContext)

	// Set_declaracion sets the _declaracion rule contexts.
	Set_declaracion(IDeclaracionContext)

	// Set_asignacion sets the _asignacion rule contexts.
	Set_asignacion(IAsignacionContext)

	// Set_appendVec sets the _appendVec rule contexts.
	Set_appendVec(IAppendVecContext)

	// Set_if_sent sets the _if_sent rule contexts.
	Set_if_sent(IIf_sentContext)

	// Set_switch_sent sets the _switch_sent rule contexts.
	Set_switch_sent(ISwitch_sentContext)

	// Set_while_true sets the _while_true rule contexts.
	Set_while_true(IWhile_trueContext)

	// Set_lWhile sets the _lWhile rule contexts.
	Set_lWhile(ILWhileContext)

	// Set_lForin sets the _lForin rule contexts.
	Set_lForin(ILForinContext)

	// Set_lBreak sets the _lBreak rule contexts.
	Set_lBreak(ILBreakContext)

	// Set_lContinue sets the _lContinue rule contexts.
	Set_lContinue(ILContinueContext)

	// Set_newStruct sets the _newStruct rule contexts.
	Set_newStruct(INewStructContext)

	// Set_callFunction sets the _callFunction rule contexts.
	Set_callFunction(ICallFunctionContext)

	// Set_returnFun sets the _returnFun rule contexts.
	Set_returnFun(IReturnFunContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetInstr returns the instr attribute.
	GetInstr() interfaces.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(interfaces.Instruction)

	// Getter signatures
	Printconsola() IPrintconsolaContext
	Declaracion() IDeclaracionContext
	Asignacion() IAsignacionContext
	AppendVec() IAppendVecContext
	If_sent() IIf_sentContext
	Switch_sent() ISwitch_sentContext
	While_true() IWhile_trueContext
	LWhile() ILWhileContext
	LForin() ILForinContext
	LBreak() ILBreakContext
	LContinue() ILContinueContext
	NewStruct() INewStructContext
	CallFunction() ICallFunctionContext
	ReturnFun() IReturnFunContext
	ID() antlr.TerminalNode
	PUNTO() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	AT() antlr.TerminalNode
	DPUNTO2() antlr.TerminalNode
	Expression() IExpressionContext
	PARDER() antlr.TerminalNode

	// IsInstruccionContext differentiates from other interfaces.
	IsInstruccionContext()
}

type InstruccionContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	instr         interfaces.Instruction
	_printconsola IPrintconsolaContext
	_declaracion  IDeclaracionContext
	_asignacion   IAsignacionContext
	_appendVec    IAppendVecContext
	_if_sent      IIf_sentContext
	_switch_sent  ISwitch_sentContext
	_while_true   IWhile_trueContext
	_lWhile       ILWhileContext
	_lForin       ILForinContext
	_lBreak       ILBreakContext
	_lContinue    ILContinueContext
	_newStruct    INewStructContext
	_callFunction ICallFunctionContext
	_returnFun    IReturnFunContext
	_ID           antlr.Token
	_expression   IExpressionContext
}

func NewEmptyInstruccionContext() *InstruccionContext {
	var p = new(InstruccionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_instruccion
	return p
}

func InitEmptyInstruccionContext(p *InstruccionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_instruccion
}

func (*InstruccionContext) IsInstruccionContext() {}

func NewInstruccionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstruccionContext {
	var p = new(InstruccionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_instruccion

	return p
}

func (s *InstruccionContext) GetParser() antlr.Parser { return s.parser }

func (s *InstruccionContext) Get_ID() antlr.Token { return s._ID }

func (s *InstruccionContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *InstruccionContext) Get_printconsola() IPrintconsolaContext { return s._printconsola }

func (s *InstruccionContext) Get_declaracion() IDeclaracionContext { return s._declaracion }

func (s *InstruccionContext) Get_asignacion() IAsignacionContext { return s._asignacion }

func (s *InstruccionContext) Get_appendVec() IAppendVecContext { return s._appendVec }

func (s *InstruccionContext) Get_if_sent() IIf_sentContext { return s._if_sent }

func (s *InstruccionContext) Get_switch_sent() ISwitch_sentContext { return s._switch_sent }

func (s *InstruccionContext) Get_while_true() IWhile_trueContext { return s._while_true }

func (s *InstruccionContext) Get_lWhile() ILWhileContext { return s._lWhile }

func (s *InstruccionContext) Get_lForin() ILForinContext { return s._lForin }

func (s *InstruccionContext) Get_lBreak() ILBreakContext { return s._lBreak }

func (s *InstruccionContext) Get_lContinue() ILContinueContext { return s._lContinue }

func (s *InstruccionContext) Get_newStruct() INewStructContext { return s._newStruct }

func (s *InstruccionContext) Get_callFunction() ICallFunctionContext { return s._callFunction }

func (s *InstruccionContext) Get_returnFun() IReturnFunContext { return s._returnFun }

func (s *InstruccionContext) Get_expression() IExpressionContext { return s._expression }

func (s *InstruccionContext) Set_printconsola(v IPrintconsolaContext) { s._printconsola = v }

func (s *InstruccionContext) Set_declaracion(v IDeclaracionContext) { s._declaracion = v }

func (s *InstruccionContext) Set_asignacion(v IAsignacionContext) { s._asignacion = v }

func (s *InstruccionContext) Set_appendVec(v IAppendVecContext) { s._appendVec = v }

func (s *InstruccionContext) Set_if_sent(v IIf_sentContext) { s._if_sent = v }

func (s *InstruccionContext) Set_switch_sent(v ISwitch_sentContext) { s._switch_sent = v }

func (s *InstruccionContext) Set_while_true(v IWhile_trueContext) { s._while_true = v }

func (s *InstruccionContext) Set_lWhile(v ILWhileContext) { s._lWhile = v }

func (s *InstruccionContext) Set_lForin(v ILForinContext) { s._lForin = v }

func (s *InstruccionContext) Set_lBreak(v ILBreakContext) { s._lBreak = v }

func (s *InstruccionContext) Set_lContinue(v ILContinueContext) { s._lContinue = v }

func (s *InstruccionContext) Set_newStruct(v INewStructContext) { s._newStruct = v }

func (s *InstruccionContext) Set_callFunction(v ICallFunctionContext) { s._callFunction = v }

func (s *InstruccionContext) Set_returnFun(v IReturnFunContext) { s._returnFun = v }

func (s *InstruccionContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *InstruccionContext) GetInstr() interfaces.Instruction { return s.instr }

func (s *InstruccionContext) SetInstr(v interfaces.Instruction) { s.instr = v }

func (s *InstruccionContext) Printconsola() IPrintconsolaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrintconsolaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrintconsolaContext)
}

func (s *InstruccionContext) Declaracion() IDeclaracionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaracionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaracionContext)
}

func (s *InstruccionContext) Asignacion() IAsignacionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsignacionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsignacionContext)
}

func (s *InstruccionContext) AppendVec() IAppendVecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAppendVecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAppendVecContext)
}

func (s *InstruccionContext) If_sent() IIf_sentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_sentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_sentContext)
}

func (s *InstruccionContext) Switch_sent() ISwitch_sentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitch_sentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitch_sentContext)
}

func (s *InstruccionContext) While_true() IWhile_trueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhile_trueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhile_trueContext)
}

func (s *InstruccionContext) LWhile() ILWhileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILWhileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILWhileContext)
}

func (s *InstruccionContext) LForin() ILForinContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILForinContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILForinContext)
}

func (s *InstruccionContext) LBreak() ILBreakContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILBreakContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILBreakContext)
}

func (s *InstruccionContext) LContinue() ILContinueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILContinueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILContinueContext)
}

func (s *InstruccionContext) NewStruct() INewStructContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewStructContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewStructContext)
}

func (s *InstruccionContext) CallFunction() ICallFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallFunctionContext)
}

func (s *InstruccionContext) ReturnFun() IReturnFunContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnFunContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnFunContext)
}

func (s *InstruccionContext) ID() antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, 0)
}

func (s *InstruccionContext) PUNTO() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPUNTO, 0)
}

func (s *InstruccionContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(swiftgrammarREMOVE, 0)
}

func (s *InstruccionContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARIZQ, 0)
}

func (s *InstruccionContext) AT() antlr.TerminalNode {
	return s.GetToken(swiftgrammarAT, 0)
}

func (s *InstruccionContext) DPUNTO2() antlr.TerminalNode {
	return s.GetToken(swiftgrammarDPUNTO2, 0)
}

func (s *InstruccionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InstruccionContext) PARDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARDER, 0)
}

func (s *InstruccionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstruccionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstruccionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterInstruccion(s)
	}
}

func (s *InstruccionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitInstruccion(s)
	}
}

func (p *swiftgrammar) Instruccion() (localctx IInstruccionContext) {
	localctx = NewInstruccionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, swiftgrammarRULE_instruccion)
	p.SetState(330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(278)

			var _x = p.Printconsola()

			localctx.(*InstruccionContext)._printconsola = _x
		}
		localctx.(*InstruccionContext).instr = localctx.(*InstruccionContext).Get_printconsola().GetInstr()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(281)

			var _x = p.Declaracion()

			localctx.(*InstruccionContext)._declaracion = _x
		}
		localctx.(*InstruccionContext).instr = localctx.(*InstruccionContext).Get_declaracion().GetInstr()

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(284)

			var _x = p.Asignacion()

			localctx.(*InstruccionContext)._asignacion = _x
		}
		localctx.(*InstruccionContext).instr = localctx.(*InstruccionContext).Get_asignacion().GetInstr()

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(287)

			var _x = p.AppendVec()

			localctx.(*InstruccionContext)._appendVec = _x
		}
		localctx.(*InstruccionContext).instr = localctx.(*InstruccionContext).Get_appendVec().GetInstr()

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(290)

			var _x = p.If_sent()

			localctx.(*InstruccionContext)._if_sent = _x
		}
		localctx.(*InstruccionContext).instr = localctx.(*InstruccionContext).Get_if_sent().GetInstr()

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(293)

			var _x = p.Switch_sent()

			localctx.(*InstruccionContext)._switch_sent = _x
		}
		localctx.(*InstruccionContext).instr = localctx.(*InstruccionContext).Get_switch_sent().GetInstr()

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(296)

			var _x = p.While_true()

			localctx.(*InstruccionContext)._while_true = _x
		}
		localctx.(*InstruccionContext).instr = localctx.(*InstruccionContext).Get_while_true().GetLop()

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(299)

			var _x = p.LWhile()

			localctx.(*InstruccionContext)._lWhile = _x
		}
		localctx.(*InstruccionContext).instr = localctx.(*InstruccionContext).Get_lWhile().GetLwh()

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(302)

			var _x = p.LForin()

			localctx.(*InstruccionContext)._lForin = _x
		}
		localctx.(*InstruccionContext).instr = localctx.(*InstruccionContext).Get_lForin().GetLfor()

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(305)

			var _x = p.LBreak()

			localctx.(*InstruccionContext)._lBreak = _x
		}
		localctx.(*InstruccionContext).instr = localctx.(*InstruccionContext).Get_lBreak().GetBr()

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(308)

			var _x = p.LContinue()

			localctx.(*InstruccionContext)._lContinue = _x
		}
		localctx.(*InstruccionContext).instr = localctx.(*InstruccionContext).Get_lContinue().GetCn()

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(311)

			var _x = p.NewStruct()

			localctx.(*InstruccionContext)._newStruct = _x
		}
		localctx.(*InstruccionContext).instr = localctx.(*InstruccionContext).Get_newStruct().GetStr()

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(314)

			var _x = p.CallFunction()

			localctx.(*InstruccionContext)._callFunction = _x
		}
		localctx.(*InstruccionContext).instr = localctx.(*InstruccionContext).Get_callFunction().GetInstr()

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(317)

			var _x = p.ReturnFun()

			localctx.(*InstruccionContext)._returnFun = _x
		}
		localctx.(*InstruccionContext).instr = localctx.(*InstruccionContext).Get_returnFun().GetInstr()

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(320)

			var _m = p.Match(swiftgrammarID)

			localctx.(*InstruccionContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(321)
			p.Match(swiftgrammarPUNTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(322)
			p.Match(swiftgrammarREMOVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(323)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(324)
			p.Match(swiftgrammarAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(325)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(326)

			var _x = p.expression(0)

			localctx.(*InstruccionContext)._expression = _x
		}
		{
			p.SetState(327)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*InstruccionContext).instr = instructionExpre.NewRemove((func() string {
			if localctx.(*InstruccionContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*InstruccionContext).Get_ID().GetText()
			}
		}()), localctx.(*InstruccionContext).Get_expression().GetP(), (func() int {
			if localctx.(*InstruccionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*InstruccionContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*InstruccionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*InstruccionContext).Get_ID().GetColumn()
			}
		}()))

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstruccion_dentroContext is an interface to support dynamic dispatch.
type IInstruccion_dentroContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_printconsola returns the _printconsola rule contexts.
	Get_printconsola() IPrintconsolaContext

	// Get_declaracion returns the _declaracion rule contexts.
	Get_declaracion() IDeclaracionContext

	// Get_asignacion returns the _asignacion rule contexts.
	Get_asignacion() IAsignacionContext

	// Get_appendVec returns the _appendVec rule contexts.
	Get_appendVec() IAppendVecContext

	// Get_if_sent returns the _if_sent rule contexts.
	Get_if_sent() IIf_sentContext

	// Get_switch_sent returns the _switch_sent rule contexts.
	Get_switch_sent() ISwitch_sentContext

	// Get_while_true returns the _while_true rule contexts.
	Get_while_true() IWhile_trueContext

	// Get_lWhile returns the _lWhile rule contexts.
	Get_lWhile() ILWhileContext

	// Get_lForin returns the _lForin rule contexts.
	Get_lForin() ILForinContext

	// Get_lBreak returns the _lBreak rule contexts.
	Get_lBreak() ILBreakContext

	// Get_lContinue returns the _lContinue rule contexts.
	Get_lContinue() ILContinueContext

	// Get_callFunction returns the _callFunction rule contexts.
	Get_callFunction() ICallFunctionContext

	// Get_returnFun returns the _returnFun rule contexts.
	Get_returnFun() IReturnFunContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_printconsola sets the _printconsola rule contexts.
	Set_printconsola(IPrintconsolaContext)

	// Set_declaracion sets the _declaracion rule contexts.
	Set_declaracion(IDeclaracionContext)

	// Set_asignacion sets the _asignacion rule contexts.
	Set_asignacion(IAsignacionContext)

	// Set_appendVec sets the _appendVec rule contexts.
	Set_appendVec(IAppendVecContext)

	// Set_if_sent sets the _if_sent rule contexts.
	Set_if_sent(IIf_sentContext)

	// Set_switch_sent sets the _switch_sent rule contexts.
	Set_switch_sent(ISwitch_sentContext)

	// Set_while_true sets the _while_true rule contexts.
	Set_while_true(IWhile_trueContext)

	// Set_lWhile sets the _lWhile rule contexts.
	Set_lWhile(ILWhileContext)

	// Set_lForin sets the _lForin rule contexts.
	Set_lForin(ILForinContext)

	// Set_lBreak sets the _lBreak rule contexts.
	Set_lBreak(ILBreakContext)

	// Set_lContinue sets the _lContinue rule contexts.
	Set_lContinue(ILContinueContext)

	// Set_callFunction sets the _callFunction rule contexts.
	Set_callFunction(ICallFunctionContext)

	// Set_returnFun sets the _returnFun rule contexts.
	Set_returnFun(IReturnFunContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetInstr returns the instr attribute.
	GetInstr() interfaces.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(interfaces.Instruction)

	// Getter signatures
	Printconsola() IPrintconsolaContext
	Declaracion() IDeclaracionContext
	Asignacion() IAsignacionContext
	AppendVec() IAppendVecContext
	If_sent() IIf_sentContext
	Switch_sent() ISwitch_sentContext
	While_true() IWhile_trueContext
	LWhile() ILWhileContext
	LForin() ILForinContext
	LBreak() ILBreakContext
	LContinue() ILContinueContext
	CallFunction() ICallFunctionContext
	ReturnFun() IReturnFunContext
	ID() antlr.TerminalNode
	PUNTO() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	Expression() IExpressionContext
	PARDER() antlr.TerminalNode

	// IsInstruccion_dentroContext differentiates from other interfaces.
	IsInstruccion_dentroContext()
}

type Instruccion_dentroContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	instr         interfaces.Instruction
	_printconsola IPrintconsolaContext
	_declaracion  IDeclaracionContext
	_asignacion   IAsignacionContext
	_appendVec    IAppendVecContext
	_if_sent      IIf_sentContext
	_switch_sent  ISwitch_sentContext
	_while_true   IWhile_trueContext
	_lWhile       ILWhileContext
	_lForin       ILForinContext
	_lBreak       ILBreakContext
	_lContinue    ILContinueContext
	_callFunction ICallFunctionContext
	_returnFun    IReturnFunContext
	_ID           antlr.Token
	_expression   IExpressionContext
}

func NewEmptyInstruccion_dentroContext() *Instruccion_dentroContext {
	var p = new(Instruccion_dentroContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_instruccion_dentro
	return p
}

func InitEmptyInstruccion_dentroContext(p *Instruccion_dentroContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_instruccion_dentro
}

func (*Instruccion_dentroContext) IsInstruccion_dentroContext() {}

func NewInstruccion_dentroContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instruccion_dentroContext {
	var p = new(Instruccion_dentroContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_instruccion_dentro

	return p
}

func (s *Instruccion_dentroContext) GetParser() antlr.Parser { return s.parser }

func (s *Instruccion_dentroContext) Get_ID() antlr.Token { return s._ID }

func (s *Instruccion_dentroContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *Instruccion_dentroContext) Get_printconsola() IPrintconsolaContext { return s._printconsola }

func (s *Instruccion_dentroContext) Get_declaracion() IDeclaracionContext { return s._declaracion }

func (s *Instruccion_dentroContext) Get_asignacion() IAsignacionContext { return s._asignacion }

func (s *Instruccion_dentroContext) Get_appendVec() IAppendVecContext { return s._appendVec }

func (s *Instruccion_dentroContext) Get_if_sent() IIf_sentContext { return s._if_sent }

func (s *Instruccion_dentroContext) Get_switch_sent() ISwitch_sentContext { return s._switch_sent }

func (s *Instruccion_dentroContext) Get_while_true() IWhile_trueContext { return s._while_true }

func (s *Instruccion_dentroContext) Get_lWhile() ILWhileContext { return s._lWhile }

func (s *Instruccion_dentroContext) Get_lForin() ILForinContext { return s._lForin }

func (s *Instruccion_dentroContext) Get_lBreak() ILBreakContext { return s._lBreak }

func (s *Instruccion_dentroContext) Get_lContinue() ILContinueContext { return s._lContinue }

func (s *Instruccion_dentroContext) Get_callFunction() ICallFunctionContext { return s._callFunction }

func (s *Instruccion_dentroContext) Get_returnFun() IReturnFunContext { return s._returnFun }

func (s *Instruccion_dentroContext) Get_expression() IExpressionContext { return s._expression }

func (s *Instruccion_dentroContext) Set_printconsola(v IPrintconsolaContext) { s._printconsola = v }

func (s *Instruccion_dentroContext) Set_declaracion(v IDeclaracionContext) { s._declaracion = v }

func (s *Instruccion_dentroContext) Set_asignacion(v IAsignacionContext) { s._asignacion = v }

func (s *Instruccion_dentroContext) Set_appendVec(v IAppendVecContext) { s._appendVec = v }

func (s *Instruccion_dentroContext) Set_if_sent(v IIf_sentContext) { s._if_sent = v }

func (s *Instruccion_dentroContext) Set_switch_sent(v ISwitch_sentContext) { s._switch_sent = v }

func (s *Instruccion_dentroContext) Set_while_true(v IWhile_trueContext) { s._while_true = v }

func (s *Instruccion_dentroContext) Set_lWhile(v ILWhileContext) { s._lWhile = v }

func (s *Instruccion_dentroContext) Set_lForin(v ILForinContext) { s._lForin = v }

func (s *Instruccion_dentroContext) Set_lBreak(v ILBreakContext) { s._lBreak = v }

func (s *Instruccion_dentroContext) Set_lContinue(v ILContinueContext) { s._lContinue = v }

func (s *Instruccion_dentroContext) Set_callFunction(v ICallFunctionContext) { s._callFunction = v }

func (s *Instruccion_dentroContext) Set_returnFun(v IReturnFunContext) { s._returnFun = v }

func (s *Instruccion_dentroContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Instruccion_dentroContext) GetInstr() interfaces.Instruction { return s.instr }

func (s *Instruccion_dentroContext) SetInstr(v interfaces.Instruction) { s.instr = v }

func (s *Instruccion_dentroContext) Printconsola() IPrintconsolaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrintconsolaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrintconsolaContext)
}

func (s *Instruccion_dentroContext) Declaracion() IDeclaracionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaracionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaracionContext)
}

func (s *Instruccion_dentroContext) Asignacion() IAsignacionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsignacionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsignacionContext)
}

func (s *Instruccion_dentroContext) AppendVec() IAppendVecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAppendVecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAppendVecContext)
}

func (s *Instruccion_dentroContext) If_sent() IIf_sentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_sentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_sentContext)
}

func (s *Instruccion_dentroContext) Switch_sent() ISwitch_sentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitch_sentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitch_sentContext)
}

func (s *Instruccion_dentroContext) While_true() IWhile_trueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhile_trueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhile_trueContext)
}

func (s *Instruccion_dentroContext) LWhile() ILWhileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILWhileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILWhileContext)
}

func (s *Instruccion_dentroContext) LForin() ILForinContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILForinContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILForinContext)
}

func (s *Instruccion_dentroContext) LBreak() ILBreakContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILBreakContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILBreakContext)
}

func (s *Instruccion_dentroContext) LContinue() ILContinueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILContinueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILContinueContext)
}

func (s *Instruccion_dentroContext) CallFunction() ICallFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallFunctionContext)
}

func (s *Instruccion_dentroContext) ReturnFun() IReturnFunContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnFunContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnFunContext)
}

func (s *Instruccion_dentroContext) ID() antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, 0)
}

func (s *Instruccion_dentroContext) PUNTO() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPUNTO, 0)
}

func (s *Instruccion_dentroContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(swiftgrammarREMOVE, 0)
}

func (s *Instruccion_dentroContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARIZQ, 0)
}

func (s *Instruccion_dentroContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Instruccion_dentroContext) PARDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARDER, 0)
}

func (s *Instruccion_dentroContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instruccion_dentroContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Instruccion_dentroContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterInstruccion_dentro(s)
	}
}

func (s *Instruccion_dentroContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitInstruccion_dentro(s)
	}
}

func (p *swiftgrammar) Instruccion_dentro() (localctx IInstruccion_dentroContext) {
	localctx = NewInstruccion_dentroContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, swiftgrammarRULE_instruccion_dentro)
	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(332)

			var _x = p.Printconsola()

			localctx.(*Instruccion_dentroContext)._printconsola = _x
		}
		localctx.(*Instruccion_dentroContext).instr = localctx.(*Instruccion_dentroContext).Get_printconsola().GetInstr()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(335)

			var _x = p.Declaracion()

			localctx.(*Instruccion_dentroContext)._declaracion = _x
		}
		localctx.(*Instruccion_dentroContext).instr = localctx.(*Instruccion_dentroContext).Get_declaracion().GetInstr()

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(338)

			var _x = p.Asignacion()

			localctx.(*Instruccion_dentroContext)._asignacion = _x
		}
		localctx.(*Instruccion_dentroContext).instr = localctx.(*Instruccion_dentroContext).Get_asignacion().GetInstr()

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(341)

			var _x = p.AppendVec()

			localctx.(*Instruccion_dentroContext)._appendVec = _x
		}
		localctx.(*Instruccion_dentroContext).instr = localctx.(*Instruccion_dentroContext).Get_appendVec().GetInstr()

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(344)

			var _x = p.If_sent()

			localctx.(*Instruccion_dentroContext)._if_sent = _x
		}
		localctx.(*Instruccion_dentroContext).instr = localctx.(*Instruccion_dentroContext).Get_if_sent().GetInstr()

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(347)

			var _x = p.Switch_sent()

			localctx.(*Instruccion_dentroContext)._switch_sent = _x
		}
		localctx.(*Instruccion_dentroContext).instr = localctx.(*Instruccion_dentroContext).Get_switch_sent().GetInstr()

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(350)

			var _x = p.While_true()

			localctx.(*Instruccion_dentroContext)._while_true = _x
		}
		localctx.(*Instruccion_dentroContext).instr = localctx.(*Instruccion_dentroContext).Get_while_true().GetLop()

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(353)

			var _x = p.LWhile()

			localctx.(*Instruccion_dentroContext)._lWhile = _x
		}
		localctx.(*Instruccion_dentroContext).instr = localctx.(*Instruccion_dentroContext).Get_lWhile().GetLwh()

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(356)

			var _x = p.LForin()

			localctx.(*Instruccion_dentroContext)._lForin = _x
		}
		localctx.(*Instruccion_dentroContext).instr = localctx.(*Instruccion_dentroContext).Get_lForin().GetLfor()

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(359)

			var _x = p.LBreak()

			localctx.(*Instruccion_dentroContext)._lBreak = _x
		}
		localctx.(*Instruccion_dentroContext).instr = localctx.(*Instruccion_dentroContext).Get_lBreak().GetBr()

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(362)

			var _x = p.LContinue()

			localctx.(*Instruccion_dentroContext)._lContinue = _x
		}
		localctx.(*Instruccion_dentroContext).instr = localctx.(*Instruccion_dentroContext).Get_lContinue().GetCn()

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(365)

			var _x = p.CallFunction()

			localctx.(*Instruccion_dentroContext)._callFunction = _x
		}
		localctx.(*Instruccion_dentroContext).instr = localctx.(*Instruccion_dentroContext).Get_callFunction().GetInstr()

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(368)

			var _x = p.ReturnFun()

			localctx.(*Instruccion_dentroContext)._returnFun = _x
		}
		localctx.(*Instruccion_dentroContext).instr = localctx.(*Instruccion_dentroContext).Get_returnFun().GetInstr()

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(371)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Instruccion_dentroContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(372)
			p.Match(swiftgrammarPUNTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(373)
			p.Match(swiftgrammarREMOVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(374)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(375)

			var _x = p.expression(0)

			localctx.(*Instruccion_dentroContext)._expression = _x
		}
		{
			p.SetState(376)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Instruccion_dentroContext).instr = instructionExpre.NewRemove((func() string {
			if localctx.(*Instruccion_dentroContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Instruccion_dentroContext).Get_ID().GetText()
			}
		}()), localctx.(*Instruccion_dentroContext).Get_expression().GetP(), (func() int {
			if localctx.(*Instruccion_dentroContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Instruccion_dentroContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*Instruccion_dentroContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Instruccion_dentroContext).Get_ID().GetColumn()
			}
		}()))

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAppendVecContext is an interface to support dynamic dispatch.
type IAppendVecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// GetVal returns the val rule contexts.
	GetVal() IExpressionContext

	// GetVal1 returns the val1 rule contexts.
	GetVal1() IExpressionContext

	// GetVal2 returns the val2 rule contexts.
	GetVal2() IExpressionContext

	// SetVal sets the val rule contexts.
	SetVal(IExpressionContext)

	// SetVal1 sets the val1 rule contexts.
	SetVal1(IExpressionContext)

	// SetVal2 sets the val2 rule contexts.
	SetVal2(IExpressionContext)

	// GetInstr returns the instr attribute.
	GetInstr() interfaces.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(interfaces.Instruction)

	// Getter signatures
	ID() antlr.TerminalNode
	PUNTO() antlr.TerminalNode
	APPEND() antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	PARDER() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	INSERT() antlr.TerminalNode
	COMA() antlr.TerminalNode

	// IsAppendVecContext differentiates from other interfaces.
	IsAppendVecContext()
}

type AppendVecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	instr  interfaces.Instruction
	_ID    antlr.Token
	val    IExpressionContext
	val1   IExpressionContext
	val2   IExpressionContext
}

func NewEmptyAppendVecContext() *AppendVecContext {
	var p = new(AppendVecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_appendVec
	return p
}

func InitEmptyAppendVecContext(p *AppendVecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_appendVec
}

func (*AppendVecContext) IsAppendVecContext() {}

func NewAppendVecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AppendVecContext {
	var p = new(AppendVecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_appendVec

	return p
}

func (s *AppendVecContext) GetParser() antlr.Parser { return s.parser }

func (s *AppendVecContext) Get_ID() antlr.Token { return s._ID }

func (s *AppendVecContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *AppendVecContext) GetVal() IExpressionContext { return s.val }

func (s *AppendVecContext) GetVal1() IExpressionContext { return s.val1 }

func (s *AppendVecContext) GetVal2() IExpressionContext { return s.val2 }

func (s *AppendVecContext) SetVal(v IExpressionContext) { s.val = v }

func (s *AppendVecContext) SetVal1(v IExpressionContext) { s.val1 = v }

func (s *AppendVecContext) SetVal2(v IExpressionContext) { s.val2 = v }

func (s *AppendVecContext) GetInstr() interfaces.Instruction { return s.instr }

func (s *AppendVecContext) SetInstr(v interfaces.Instruction) { s.instr = v }

func (s *AppendVecContext) ID() antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, 0)
}

func (s *AppendVecContext) PUNTO() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPUNTO, 0)
}

func (s *AppendVecContext) APPEND() antlr.TerminalNode {
	return s.GetToken(swiftgrammarAPPEND, 0)
}

func (s *AppendVecContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARIZQ, 0)
}

func (s *AppendVecContext) PARDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARDER, 0)
}

func (s *AppendVecContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AppendVecContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AppendVecContext) INSERT() antlr.TerminalNode {
	return s.GetToken(swiftgrammarINSERT, 0)
}

func (s *AppendVecContext) COMA() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCOMA, 0)
}

func (s *AppendVecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AppendVecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AppendVecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterAppendVec(s)
	}
}

func (s *AppendVecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitAppendVec(s)
	}
}

func (p *swiftgrammar) AppendVec() (localctx IAppendVecContext) {
	localctx = NewAppendVecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, swiftgrammarRULE_appendVec)
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(381)

			var _m = p.Match(swiftgrammarID)

			localctx.(*AppendVecContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(382)
			p.Match(swiftgrammarPUNTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(383)
			p.Match(swiftgrammarAPPEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(384)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(385)

			var _x = p.expression(0)

			localctx.(*AppendVecContext).val = _x
		}
		{
			p.SetState(386)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*AppendVecContext).instr = instruction.NewPush((func() string {
			if localctx.(*AppendVecContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*AppendVecContext).Get_ID().GetText()
			}
		}()), localctx.(*AppendVecContext).GetVal().GetP(), (func() int {
			if localctx.(*AppendVecContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*AppendVecContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*AppendVecContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*AppendVecContext).Get_ID().GetColumn()
			}
		}()))

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(389)

			var _m = p.Match(swiftgrammarID)

			localctx.(*AppendVecContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(390)
			p.Match(swiftgrammarPUNTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(391)
			p.Match(swiftgrammarINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(392)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(393)

			var _x = p.expression(0)

			localctx.(*AppendVecContext).val1 = _x
		}
		{
			p.SetState(394)
			p.Match(swiftgrammarCOMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(395)

			var _x = p.expression(0)

			localctx.(*AppendVecContext).val2 = _x
		}
		{
			p.SetState(396)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*AppendVecContext).instr = instruction.NewInsert((func() string {
			if localctx.(*AppendVecContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*AppendVecContext).Get_ID().GetText()
			}
		}()), localctx.(*AppendVecContext).GetVal1().GetP(), localctx.(*AppendVecContext).GetVal2().GetP(), (func() int {
			if localctx.(*AppendVecContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*AppendVecContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*AppendVecContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*AppendVecContext).Get_ID().GetColumn()
			}
		}()))

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INewStructContext is an interface to support dynamic dispatch.
type INewStructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_STRUCT returns the _STRUCT token.
	Get_STRUCT() antlr.Token

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_STRUCT sets the _STRUCT token.
	Set_STRUCT(antlr.Token)

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_lista_struct returns the _lista_struct rule contexts.
	Get_lista_struct() ILista_structContext

	// Set_lista_struct sets the _lista_struct rule contexts.
	Set_lista_struct(ILista_structContext)

	// GetStr returns the str attribute.
	GetStr() interfaces.Instruction

	// SetStr sets the str attribute.
	SetStr(interfaces.Instruction)

	// Getter signatures
	STRUCT() antlr.TerminalNode
	ID() antlr.TerminalNode
	LLAVEIZQ() antlr.TerminalNode
	Lista_struct() ILista_structContext
	LLAVEDER() antlr.TerminalNode

	// IsNewStructContext differentiates from other interfaces.
	IsNewStructContext()
}

type NewStructContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	str           interfaces.Instruction
	_STRUCT       antlr.Token
	_ID           antlr.Token
	_lista_struct ILista_structContext
}

func NewEmptyNewStructContext() *NewStructContext {
	var p = new(NewStructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_newStruct
	return p
}

func InitEmptyNewStructContext(p *NewStructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_newStruct
}

func (*NewStructContext) IsNewStructContext() {}

func NewNewStructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NewStructContext {
	var p = new(NewStructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_newStruct

	return p
}

func (s *NewStructContext) GetParser() antlr.Parser { return s.parser }

func (s *NewStructContext) Get_STRUCT() antlr.Token { return s._STRUCT }

func (s *NewStructContext) Get_ID() antlr.Token { return s._ID }

func (s *NewStructContext) Set_STRUCT(v antlr.Token) { s._STRUCT = v }

func (s *NewStructContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *NewStructContext) Get_lista_struct() ILista_structContext { return s._lista_struct }

func (s *NewStructContext) Set_lista_struct(v ILista_structContext) { s._lista_struct = v }

func (s *NewStructContext) GetStr() interfaces.Instruction { return s.str }

func (s *NewStructContext) SetStr(v interfaces.Instruction) { s.str = v }

func (s *NewStructContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(swiftgrammarSTRUCT, 0)
}

func (s *NewStructContext) ID() antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, 0)
}

func (s *NewStructContext) LLAVEIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarLLAVEIZQ, 0)
}

func (s *NewStructContext) Lista_struct() ILista_structContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILista_structContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILista_structContext)
}

func (s *NewStructContext) LLAVEDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarLLAVEDER, 0)
}

func (s *NewStructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewStructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NewStructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterNewStruct(s)
	}
}

func (s *NewStructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitNewStruct(s)
	}
}

func (p *swiftgrammar) NewStruct() (localctx INewStructContext) {
	localctx = NewNewStructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, swiftgrammarRULE_newStruct)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(401)

		var _m = p.Match(swiftgrammarSTRUCT)

		localctx.(*NewStructContext)._STRUCT = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(402)

		var _m = p.Match(swiftgrammarID)

		localctx.(*NewStructContext)._ID = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(403)
		p.Match(swiftgrammarLLAVEIZQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(404)

		var _x = p.lista_struct(0)

		localctx.(*NewStructContext)._lista_struct = _x
	}
	{
		p.SetState(405)
		p.Match(swiftgrammarLLAVEDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*NewStructContext).str = instructionExpre.NewStruct((func() string {
		if localctx.(*NewStructContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*NewStructContext).Get_ID().GetText()
		}
	}()), localctx.(*NewStructContext).Get_lista_struct().GetL(), (func() int {
		if localctx.(*NewStructContext).Get_STRUCT() == nil {
			return 0
		} else {
			return localctx.(*NewStructContext).Get_STRUCT().GetLine()
		}
	}()), (func() int {
		if localctx.(*NewStructContext).Get_STRUCT() == nil {
			return 0
		} else {
			return localctx.(*NewStructContext).Get_STRUCT().GetColumn()
		}
	}()))

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILista_structContext is an interface to support dynamic dispatch.
type ILista_structContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetId returns the id token.
	GetId() antlr.Token

	// GetIdstru returns the idstru token.
	GetIdstru() antlr.Token

	// SetId sets the id token.
	SetId(antlr.Token)

	// SetIdstru sets the idstru token.
	SetIdstru(antlr.Token)

	// GetList returns the list rule contexts.
	GetList() ILista_structContext

	// Get_tipos_var returns the _tipos_var rule contexts.
	Get_tipos_var() ITipos_varContext

	// SetList sets the list rule contexts.
	SetList(ILista_structContext)

	// Set_tipos_var sets the _tipos_var rule contexts.
	Set_tipos_var(ITipos_varContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// Getter signatures
	MUT() antlr.TerminalNode
	DPUNTO2() antlr.TerminalNode
	Tipos_var() ITipos_varContext
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	LET() antlr.TerminalNode
	Lista_struct() ILista_structContext

	// IsLista_structContext differentiates from other interfaces.
	IsLista_structContext()
}

type Lista_structContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	l          *arrayList.List
	list       ILista_structContext
	id         antlr.Token
	_tipos_var ITipos_varContext
	idstru     antlr.Token
}

func NewEmptyLista_structContext() *Lista_structContext {
	var p = new(Lista_structContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_lista_struct
	return p
}

func InitEmptyLista_structContext(p *Lista_structContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_lista_struct
}

func (*Lista_structContext) IsLista_structContext() {}

func NewLista_structContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lista_structContext {
	var p = new(Lista_structContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_lista_struct

	return p
}

func (s *Lista_structContext) GetParser() antlr.Parser { return s.parser }

func (s *Lista_structContext) GetId() antlr.Token { return s.id }

func (s *Lista_structContext) GetIdstru() antlr.Token { return s.idstru }

func (s *Lista_structContext) SetId(v antlr.Token) { s.id = v }

func (s *Lista_structContext) SetIdstru(v antlr.Token) { s.idstru = v }

func (s *Lista_structContext) GetList() ILista_structContext { return s.list }

func (s *Lista_structContext) Get_tipos_var() ITipos_varContext { return s._tipos_var }

func (s *Lista_structContext) SetList(v ILista_structContext) { s.list = v }

func (s *Lista_structContext) Set_tipos_var(v ITipos_varContext) { s._tipos_var = v }

func (s *Lista_structContext) GetL() *arrayList.List { return s.l }

func (s *Lista_structContext) SetL(v *arrayList.List) { s.l = v }

func (s *Lista_structContext) MUT() antlr.TerminalNode {
	return s.GetToken(swiftgrammarMUT, 0)
}

func (s *Lista_structContext) DPUNTO2() antlr.TerminalNode {
	return s.GetToken(swiftgrammarDPUNTO2, 0)
}

func (s *Lista_structContext) Tipos_var() ITipos_varContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipos_varContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipos_varContext)
}

func (s *Lista_structContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(swiftgrammarID)
}

func (s *Lista_structContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, i)
}

func (s *Lista_structContext) LET() antlr.TerminalNode {
	return s.GetToken(swiftgrammarLET, 0)
}

func (s *Lista_structContext) Lista_struct() ILista_structContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILista_structContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILista_structContext)
}

func (s *Lista_structContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lista_structContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lista_structContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterLista_struct(s)
	}
}

func (s *Lista_structContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitLista_struct(s)
	}
}

func (p *swiftgrammar) Lista_struct() (localctx ILista_structContext) {
	return p.lista_struct(0)
}

func (p *swiftgrammar) lista_struct(_p int) (localctx ILista_structContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewLista_structContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILista_structContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 26
	p.EnterRecursionRule(localctx, 26, swiftgrammarRULE_lista_struct, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(409)
			p.Match(swiftgrammarMUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(410)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Lista_structContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(411)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(412)

			var _x = p.Tipos_var()

			localctx.(*Lista_structContext)._tipos_var = _x
		}

		Str_atrib := interfaces.NewStructType((func() string {
			if localctx.(*Lista_structContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*Lista_structContext).GetId().GetText()
			}
		}()), localctx.(*Lista_structContext).Get_tipos_var().GetTipo(), "")
		localctx.(*Lista_structContext).SetL(arrayList.New())
		localctx.(*Lista_structContext).l.Add(Str_atrib)

	case 2:
		{
			p.SetState(415)
			p.Match(swiftgrammarMUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(416)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Lista_structContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(417)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(418)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Lista_structContext).idstru = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		Str_atrib := interfaces.NewStructType((func() string {
			if localctx.(*Lista_structContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*Lista_structContext).GetId().GetText()
			}
		}()), interfaces.NULL, (func() string {
			if localctx.(*Lista_structContext).GetIdstru() == nil {
				return ""
			} else {
				return localctx.(*Lista_structContext).GetIdstru().GetText()
			}
		}()))
		localctx.(*Lista_structContext).SetL(arrayList.New())
		localctx.(*Lista_structContext).l.Add(Str_atrib)

	case 3:
		{
			p.SetState(420)
			p.Match(swiftgrammarLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(421)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Lista_structContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(422)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(423)

			var _x = p.Tipos_var()

			localctx.(*Lista_structContext)._tipos_var = _x
		}

		Str_atrib := interfaces.NewStructType((func() string {
			if localctx.(*Lista_structContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*Lista_structContext).GetId().GetText()
			}
		}()), localctx.(*Lista_structContext).Get_tipos_var().GetTipo(), "")
		localctx.(*Lista_structContext).SetL(arrayList.New())
		localctx.(*Lista_structContext).l.Add(Str_atrib)

	case 4:
		{
			p.SetState(426)
			p.Match(swiftgrammarLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(427)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Lista_structContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(428)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(429)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Lista_structContext).idstru = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		Str_atrib := interfaces.NewStructType((func() string {
			if localctx.(*Lista_structContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*Lista_structContext).GetId().GetText()
			}
		}()), interfaces.NULL, (func() string {
			if localctx.(*Lista_structContext).GetIdstru() == nil {
				return ""
			} else {
				return localctx.(*Lista_structContext).GetIdstru().GetText()
			}
		}()))
		localctx.(*Lista_structContext).SetL(arrayList.New())
		localctx.(*Lista_structContext).l.Add(Str_atrib)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(459)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLista_structContext(p, _parentctx, _parentState)
				localctx.(*Lista_structContext).list = _prevctx
				p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_lista_struct)
				p.SetState(433)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(434)
					p.Match(swiftgrammarMUT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(435)

					var _m = p.Match(swiftgrammarID)

					localctx.(*Lista_structContext).id = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(436)
					p.Match(swiftgrammarDPUNTO2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(437)

					var _x = p.Tipos_var()

					localctx.(*Lista_structContext)._tipos_var = _x
				}

				Str_atrib := interfaces.NewStructType((func() string {
					if localctx.(*Lista_structContext).GetId() == nil {
						return ""
					} else {
						return localctx.(*Lista_structContext).GetId().GetText()
					}
				}()), localctx.(*Lista_structContext).Get_tipos_var().GetTipo(), "")
				localctx.(*Lista_structContext).GetList().GetL().Add(Str_atrib)
				localctx.(*Lista_structContext).SetL(localctx.(*Lista_structContext).GetList().GetL())

			case 2:
				localctx = NewLista_structContext(p, _parentctx, _parentState)
				localctx.(*Lista_structContext).list = _prevctx
				p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_lista_struct)
				p.SetState(440)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(441)
					p.Match(swiftgrammarMUT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(442)

					var _m = p.Match(swiftgrammarID)

					localctx.(*Lista_structContext).id = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(443)
					p.Match(swiftgrammarDPUNTO2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(444)

					var _m = p.Match(swiftgrammarID)

					localctx.(*Lista_structContext).idstru = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				Str_atrib := interfaces.NewStructType((func() string {
					if localctx.(*Lista_structContext).GetId() == nil {
						return ""
					} else {
						return localctx.(*Lista_structContext).GetId().GetText()
					}
				}()), interfaces.NULL, (func() string {
					if localctx.(*Lista_structContext).GetIdstru() == nil {
						return ""
					} else {
						return localctx.(*Lista_structContext).GetIdstru().GetText()
					}
				}()))
				localctx.(*Lista_structContext).GetList().GetL().Add(Str_atrib)
				localctx.(*Lista_structContext).SetL(localctx.(*Lista_structContext).GetList().GetL())

			case 3:
				localctx = NewLista_structContext(p, _parentctx, _parentState)
				localctx.(*Lista_structContext).list = _prevctx
				p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_lista_struct)
				p.SetState(446)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(447)
					p.Match(swiftgrammarLET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(448)

					var _m = p.Match(swiftgrammarID)

					localctx.(*Lista_structContext).id = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(449)
					p.Match(swiftgrammarDPUNTO2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(450)

					var _x = p.Tipos_var()

					localctx.(*Lista_structContext)._tipos_var = _x
				}

				Str_atrib := interfaces.NewStructType((func() string {
					if localctx.(*Lista_structContext).GetId() == nil {
						return ""
					} else {
						return localctx.(*Lista_structContext).GetId().GetText()
					}
				}()), localctx.(*Lista_structContext).Get_tipos_var().GetTipo(), "")
				localctx.(*Lista_structContext).GetList().GetL().Add(Str_atrib)
				localctx.(*Lista_structContext).SetL(localctx.(*Lista_structContext).GetList().GetL())

			case 4:
				localctx = NewLista_structContext(p, _parentctx, _parentState)
				localctx.(*Lista_structContext).list = _prevctx
				p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_lista_struct)
				p.SetState(453)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(454)
					p.Match(swiftgrammarLET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(455)

					var _m = p.Match(swiftgrammarID)

					localctx.(*Lista_structContext).id = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(456)
					p.Match(swiftgrammarDPUNTO2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(457)

					var _m = p.Match(swiftgrammarID)

					localctx.(*Lista_structContext).idstru = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				Str_atrib := interfaces.NewStructType((func() string {
					if localctx.(*Lista_structContext).GetId() == nil {
						return ""
					} else {
						return localctx.(*Lista_structContext).GetId().GetText()
					}
				}()), interfaces.NULL, (func() string {
					if localctx.(*Lista_structContext).GetIdstru() == nil {
						return ""
					} else {
						return localctx.(*Lista_structContext).GetIdstru().GetText()
					}
				}()))
				localctx.(*Lista_structContext).GetList().GetL().Add(Str_atrib)
				localctx.(*Lista_structContext).SetL(localctx.(*Lista_structContext).GetList().GetL())

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(463)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallFunctionContext is an interface to support dynamic dispatch.
type ICallFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_listParamsCall returns the _listParamsCall rule contexts.
	Get_listParamsCall() IListParamsCallContext

	// Set_listParamsCall sets the _listParamsCall rule contexts.
	Set_listParamsCall(IListParamsCallContext)

	// GetInstr returns the instr attribute.
	GetInstr() interfaces.Instruction

	// GetP returns the p attribute.
	GetP() interfaces.Expresion

	// SetInstr sets the instr attribute.
	SetInstr(interfaces.Instruction)

	// SetP sets the p attribute.
	SetP(interfaces.Expresion)

	// Getter signatures
	ID() antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	PARDER() antlr.TerminalNode
	ListParamsCall() IListParamsCallContext

	// IsCallFunctionContext differentiates from other interfaces.
	IsCallFunctionContext()
}

type CallFunctionContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	instr           interfaces.Instruction
	p               interfaces.Expresion
	_ID             antlr.Token
	_listParamsCall IListParamsCallContext
}

func NewEmptyCallFunctionContext() *CallFunctionContext {
	var p = new(CallFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_callFunction
	return p
}

func InitEmptyCallFunctionContext(p *CallFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_callFunction
}

func (*CallFunctionContext) IsCallFunctionContext() {}

func NewCallFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallFunctionContext {
	var p = new(CallFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_callFunction

	return p
}

func (s *CallFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CallFunctionContext) Get_ID() antlr.Token { return s._ID }

func (s *CallFunctionContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *CallFunctionContext) Get_listParamsCall() IListParamsCallContext { return s._listParamsCall }

func (s *CallFunctionContext) Set_listParamsCall(v IListParamsCallContext) { s._listParamsCall = v }

func (s *CallFunctionContext) GetInstr() interfaces.Instruction { return s.instr }

func (s *CallFunctionContext) GetP() interfaces.Expresion { return s.p }

func (s *CallFunctionContext) SetInstr(v interfaces.Instruction) { s.instr = v }

func (s *CallFunctionContext) SetP(v interfaces.Expresion) { s.p = v }

func (s *CallFunctionContext) ID() antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, 0)
}

func (s *CallFunctionContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARIZQ, 0)
}

func (s *CallFunctionContext) PARDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARDER, 0)
}

func (s *CallFunctionContext) ListParamsCall() IListParamsCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListParamsCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListParamsCallContext)
}

func (s *CallFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterCallFunction(s)
	}
}

func (s *CallFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitCallFunction(s)
	}
}

func (p *swiftgrammar) CallFunction() (localctx ICallFunctionContext) {
	localctx = NewCallFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, swiftgrammarRULE_callFunction)
	p.SetState(474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(464)

			var _m = p.Match(swiftgrammarID)

			localctx.(*CallFunctionContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(465)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(466)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*CallFunctionContext).instr = instructionExpre.NewCallFunction((func() string {
			if localctx.(*CallFunctionContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*CallFunctionContext).Get_ID().GetText()
			}
		}()), arrayList.New(), (func() int {
			if localctx.(*CallFunctionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*CallFunctionContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*CallFunctionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*CallFunctionContext).Get_ID().GetColumn()
			}
		}()))
		localctx.(*CallFunctionContext).p = instructionExpre.NewCallFunction((func() string {
			if localctx.(*CallFunctionContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*CallFunctionContext).Get_ID().GetText()
			}
		}()), arrayList.New(), (func() int {
			if localctx.(*CallFunctionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*CallFunctionContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*CallFunctionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*CallFunctionContext).Get_ID().GetColumn()
			}
		}()))

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(468)

			var _m = p.Match(swiftgrammarID)

			localctx.(*CallFunctionContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(469)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(470)

			var _x = p.listParamsCall(0)

			localctx.(*CallFunctionContext)._listParamsCall = _x
		}
		{
			p.SetState(471)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*CallFunctionContext).instr = instructionExpre.NewCallFunction((func() string {
			if localctx.(*CallFunctionContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*CallFunctionContext).Get_ID().GetText()
			}
		}()), localctx.(*CallFunctionContext).Get_listParamsCall().GetL_e(), (func() int {
			if localctx.(*CallFunctionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*CallFunctionContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*CallFunctionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*CallFunctionContext).Get_ID().GetColumn()
			}
		}()))
		localctx.(*CallFunctionContext).p = instructionExpre.NewCallFunction((func() string {
			if localctx.(*CallFunctionContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*CallFunctionContext).Get_ID().GetText()
			}
		}()), localctx.(*CallFunctionContext).Get_listParamsCall().GetL_e(), (func() int {
			if localctx.(*CallFunctionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*CallFunctionContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*CallFunctionContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*CallFunctionContext).Get_ID().GetColumn()
			}
		}()))

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnFunContext is an interface to support dynamic dispatch.
type IReturnFunContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_RETURN returns the _RETURN token.
	Get_RETURN() antlr.Token

	// Set_RETURN sets the _RETURN token.
	Set_RETURN(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetInstr returns the instr attribute.
	GetInstr() interfaces.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(interfaces.Instruction)

	// Getter signatures
	RETURN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsReturnFunContext differentiates from other interfaces.
	IsReturnFunContext()
}

type ReturnFunContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	instr       interfaces.Instruction
	_RETURN     antlr.Token
	_expression IExpressionContext
}

func NewEmptyReturnFunContext() *ReturnFunContext {
	var p = new(ReturnFunContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_returnFun
	return p
}

func InitEmptyReturnFunContext(p *ReturnFunContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_returnFun
}

func (*ReturnFunContext) IsReturnFunContext() {}

func NewReturnFunContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnFunContext {
	var p = new(ReturnFunContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_returnFun

	return p
}

func (s *ReturnFunContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnFunContext) Get_RETURN() antlr.Token { return s._RETURN }

func (s *ReturnFunContext) Set_RETURN(v antlr.Token) { s._RETURN = v }

func (s *ReturnFunContext) Get_expression() IExpressionContext { return s._expression }

func (s *ReturnFunContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *ReturnFunContext) GetInstr() interfaces.Instruction { return s.instr }

func (s *ReturnFunContext) SetInstr(v interfaces.Instruction) { s.instr = v }

func (s *ReturnFunContext) RETURN() antlr.TerminalNode {
	return s.GetToken(swiftgrammarRETURN, 0)
}

func (s *ReturnFunContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnFunContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnFunContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnFunContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterReturnFun(s)
	}
}

func (s *ReturnFunContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitReturnFun(s)
	}
}

func (p *swiftgrammar) ReturnFun() (localctx IReturnFunContext) {
	localctx = NewReturnFunContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, swiftgrammarRULE_returnFun)
	p.SetState(482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(476)

			var _m = p.Match(swiftgrammarRETURN)

			localctx.(*ReturnFunContext)._RETURN = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ReturnFunContext).instr = instructionExpre.NewReturn(nil, (func() int {
			if localctx.(*ReturnFunContext).Get_RETURN() == nil {
				return 0
			} else {
				return localctx.(*ReturnFunContext).Get_RETURN().GetLine()
			}
		}()), (func() int {
			if localctx.(*ReturnFunContext).Get_RETURN() == nil {
				return 0
			} else {
				return localctx.(*ReturnFunContext).Get_RETURN().GetColumn()
			}
		}()))

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(478)

			var _m = p.Match(swiftgrammarRETURN)

			localctx.(*ReturnFunContext)._RETURN = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(479)

			var _x = p.expression(0)

			localctx.(*ReturnFunContext)._expression = _x
		}
		localctx.(*ReturnFunContext).instr = instructionExpre.NewReturn(localctx.(*ReturnFunContext).Get_expression().GetP(), (func() int {
			if localctx.(*ReturnFunContext).Get_RETURN() == nil {
				return 0
			} else {
				return localctx.(*ReturnFunContext).Get_RETURN().GetLine()
			}
		}()), (func() int {
			if localctx.(*ReturnFunContext).Get_RETURN() == nil {
				return 0
			} else {
				return localctx.(*ReturnFunContext).Get_RETURN().GetColumn()
			}
		}()))

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrintconsolaContext is an interface to support dynamic dispatch.
type IPrintconsolaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_PRINT_CON returns the _PRINT_CON token.
	Get_PRINT_CON() antlr.Token

	// Set_PRINT_CON sets the _PRINT_CON token.
	Set_PRINT_CON(antlr.Token)

	// Get_listParams returns the _listParams rule contexts.
	Get_listParams() IListParamsContext

	// Set_listParams sets the _listParams rule contexts.
	Set_listParams(IListParamsContext)

	// GetInstr returns the instr attribute.
	GetInstr() interfaces.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(interfaces.Instruction)

	// Getter signatures
	PRINT_CON() antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	ListParams() IListParamsContext
	PARDER() antlr.TerminalNode

	// IsPrintconsolaContext differentiates from other interfaces.
	IsPrintconsolaContext()
}

type PrintconsolaContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	instr       interfaces.Instruction
	_PRINT_CON  antlr.Token
	_listParams IListParamsContext
}

func NewEmptyPrintconsolaContext() *PrintconsolaContext {
	var p = new(PrintconsolaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_printconsola
	return p
}

func InitEmptyPrintconsolaContext(p *PrintconsolaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_printconsola
}

func (*PrintconsolaContext) IsPrintconsolaContext() {}

func NewPrintconsolaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrintconsolaContext {
	var p = new(PrintconsolaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_printconsola

	return p
}

func (s *PrintconsolaContext) GetParser() antlr.Parser { return s.parser }

func (s *PrintconsolaContext) Get_PRINT_CON() antlr.Token { return s._PRINT_CON }

func (s *PrintconsolaContext) Set_PRINT_CON(v antlr.Token) { s._PRINT_CON = v }

func (s *PrintconsolaContext) Get_listParams() IListParamsContext { return s._listParams }

func (s *PrintconsolaContext) Set_listParams(v IListParamsContext) { s._listParams = v }

func (s *PrintconsolaContext) GetInstr() interfaces.Instruction { return s.instr }

func (s *PrintconsolaContext) SetInstr(v interfaces.Instruction) { s.instr = v }

func (s *PrintconsolaContext) PRINT_CON() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPRINT_CON, 0)
}

func (s *PrintconsolaContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARIZQ, 0)
}

func (s *PrintconsolaContext) ListParams() IListParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListParamsContext)
}

func (s *PrintconsolaContext) PARDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARDER, 0)
}

func (s *PrintconsolaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintconsolaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrintconsolaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterPrintconsola(s)
	}
}

func (s *PrintconsolaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitPrintconsola(s)
	}
}

func (p *swiftgrammar) Printconsola() (localctx IPrintconsolaContext) {
	localctx = NewPrintconsolaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, swiftgrammarRULE_printconsola)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(484)

		var _m = p.Match(swiftgrammarPRINT_CON)

		localctx.(*PrintconsolaContext)._PRINT_CON = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(485)
		p.Match(swiftgrammarPARIZQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(486)

		var _x = p.listParams(0)

		localctx.(*PrintconsolaContext)._listParams = _x
	}
	{
		p.SetState(487)
		p.Match(swiftgrammarPARDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*PrintconsolaContext).instr = instruction.NewImprimir(localctx.(*PrintconsolaContext).Get_listParams().GetL_e(), (func() int {
		if localctx.(*PrintconsolaContext).Get_PRINT_CON() == nil {
			return 0
		} else {
			return localctx.(*PrintconsolaContext).Get_PRINT_CON().GetLine()
		}
	}()), localctx.(*PrintconsolaContext).Get_PRINT_CON().GetColumn())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhile_trueContext is an interface to support dynamic dispatch.
type IWhile_trueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_WHILE returns the _WHILE token.
	Get_WHILE() antlr.Token

	// Set_WHILE sets the _WHILE token.
	Set_WHILE(antlr.Token)

	// Get_bloque_inst returns the _bloque_inst rule contexts.
	Get_bloque_inst() IBloque_instContext

	// Set_bloque_inst sets the _bloque_inst rule contexts.
	Set_bloque_inst(IBloque_instContext)

	// GetLop returns the lop attribute.
	GetLop() interfaces.Instruction

	// GetP returns the p attribute.
	GetP() interfaces.Expresion

	// SetLop sets the lop attribute.
	SetLop(interfaces.Instruction)

	// SetP sets the p attribute.
	SetP(interfaces.Expresion)

	// Getter signatures
	WHILE() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	Bloque_inst() IBloque_instContext

	// IsWhile_trueContext differentiates from other interfaces.
	IsWhile_trueContext()
}

type While_trueContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	lop          interfaces.Instruction
	p            interfaces.Expresion
	_WHILE       antlr.Token
	_bloque_inst IBloque_instContext
}

func NewEmptyWhile_trueContext() *While_trueContext {
	var p = new(While_trueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_while_true
	return p
}

func InitEmptyWhile_trueContext(p *While_trueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_while_true
}

func (*While_trueContext) IsWhile_trueContext() {}

func NewWhile_trueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_trueContext {
	var p = new(While_trueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_while_true

	return p
}

func (s *While_trueContext) GetParser() antlr.Parser { return s.parser }

func (s *While_trueContext) Get_WHILE() antlr.Token { return s._WHILE }

func (s *While_trueContext) Set_WHILE(v antlr.Token) { s._WHILE = v }

func (s *While_trueContext) Get_bloque_inst() IBloque_instContext { return s._bloque_inst }

func (s *While_trueContext) Set_bloque_inst(v IBloque_instContext) { s._bloque_inst = v }

func (s *While_trueContext) GetLop() interfaces.Instruction { return s.lop }

func (s *While_trueContext) GetP() interfaces.Expresion { return s.p }

func (s *While_trueContext) SetLop(v interfaces.Instruction) { s.lop = v }

func (s *While_trueContext) SetP(v interfaces.Expresion) { s.p = v }

func (s *While_trueContext) WHILE() antlr.TerminalNode {
	return s.GetToken(swiftgrammarWHILE, 0)
}

func (s *While_trueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(swiftgrammarTRUE, 0)
}

func (s *While_trueContext) Bloque_inst() IBloque_instContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBloque_instContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBloque_instContext)
}

func (s *While_trueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_trueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *While_trueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterWhile_true(s)
	}
}

func (s *While_trueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitWhile_true(s)
	}
}

func (p *swiftgrammar) While_true() (localctx IWhile_trueContext) {
	localctx = NewWhile_trueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, swiftgrammarRULE_while_true)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(490)

		var _m = p.Match(swiftgrammarWHILE)

		localctx.(*While_trueContext)._WHILE = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(491)
		p.Match(swiftgrammarTRUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(492)

		var _x = p.Bloque_inst()

		localctx.(*While_trueContext)._bloque_inst = _x
	}

	localctx.(*While_trueContext).lop = instructionExpre.NewLoop(localctx.(*While_trueContext).Get_bloque_inst().GetL(), (func() int {
		if localctx.(*While_trueContext).Get_WHILE() == nil {
			return 0
		} else {
			return localctx.(*While_trueContext).Get_WHILE().GetLine()
		}
	}()), (func() int {
		if localctx.(*While_trueContext).Get_WHILE() == nil {
			return 0
		} else {
			return localctx.(*While_trueContext).Get_WHILE().GetColumn()
		}
	}()))
	localctx.(*While_trueContext).p = instructionExpre.NewLoop(localctx.(*While_trueContext).Get_bloque_inst().GetL(), (func() int {
		if localctx.(*While_trueContext).Get_WHILE() == nil {
			return 0
		} else {
			return localctx.(*While_trueContext).Get_WHILE().GetLine()
		}
	}()), (func() int {
		if localctx.(*While_trueContext).Get_WHILE() == nil {
			return 0
		} else {
			return localctx.(*While_trueContext).Get_WHILE().GetColumn()
		}
	}()))

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILWhileContext is an interface to support dynamic dispatch.
type ILWhileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_WHILE returns the _WHILE token.
	Get_WHILE() antlr.Token

	// Set_WHILE sets the _WHILE token.
	Set_WHILE(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_bloque_inst returns the _bloque_inst rule contexts.
	Get_bloque_inst() IBloque_instContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_bloque_inst sets the _bloque_inst rule contexts.
	Set_bloque_inst(IBloque_instContext)

	// GetLwh returns the lwh attribute.
	GetLwh() interfaces.Instruction

	// SetLwh sets the lwh attribute.
	SetLwh(interfaces.Instruction)

	// Getter signatures
	WHILE() antlr.TerminalNode
	Expression() IExpressionContext
	Bloque_inst() IBloque_instContext

	// IsLWhileContext differentiates from other interfaces.
	IsLWhileContext()
}

type LWhileContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	lwh          interfaces.Instruction
	_WHILE       antlr.Token
	_expression  IExpressionContext
	_bloque_inst IBloque_instContext
}

func NewEmptyLWhileContext() *LWhileContext {
	var p = new(LWhileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_lWhile
	return p
}

func InitEmptyLWhileContext(p *LWhileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_lWhile
}

func (*LWhileContext) IsLWhileContext() {}

func NewLWhileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LWhileContext {
	var p = new(LWhileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_lWhile

	return p
}

func (s *LWhileContext) GetParser() antlr.Parser { return s.parser }

func (s *LWhileContext) Get_WHILE() antlr.Token { return s._WHILE }

func (s *LWhileContext) Set_WHILE(v antlr.Token) { s._WHILE = v }

func (s *LWhileContext) Get_expression() IExpressionContext { return s._expression }

func (s *LWhileContext) Get_bloque_inst() IBloque_instContext { return s._bloque_inst }

func (s *LWhileContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *LWhileContext) Set_bloque_inst(v IBloque_instContext) { s._bloque_inst = v }

func (s *LWhileContext) GetLwh() interfaces.Instruction { return s.lwh }

func (s *LWhileContext) SetLwh(v interfaces.Instruction) { s.lwh = v }

func (s *LWhileContext) WHILE() antlr.TerminalNode {
	return s.GetToken(swiftgrammarWHILE, 0)
}

func (s *LWhileContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LWhileContext) Bloque_inst() IBloque_instContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBloque_instContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBloque_instContext)
}

func (s *LWhileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LWhileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LWhileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterLWhile(s)
	}
}

func (s *LWhileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitLWhile(s)
	}
}

func (p *swiftgrammar) LWhile() (localctx ILWhileContext) {
	localctx = NewLWhileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, swiftgrammarRULE_lWhile)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(495)

		var _m = p.Match(swiftgrammarWHILE)

		localctx.(*LWhileContext)._WHILE = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(496)

		var _x = p.expression(0)

		localctx.(*LWhileContext)._expression = _x
	}
	{
		p.SetState(497)

		var _x = p.Bloque_inst()

		localctx.(*LWhileContext)._bloque_inst = _x
	}
	localctx.(*LWhileContext).lwh = instruction.NewWhile(localctx.(*LWhileContext).Get_expression().GetP(), localctx.(*LWhileContext).Get_bloque_inst().GetL(), (func() int {
		if localctx.(*LWhileContext).Get_WHILE() == nil {
			return 0
		} else {
			return localctx.(*LWhileContext).Get_WHILE().GetLine()
		}
	}()), (func() int {
		if localctx.(*LWhileContext).Get_WHILE() == nil {
			return 0
		} else {
			return localctx.(*LWhileContext).Get_WHILE().GetColumn()
		}
	}()))

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILForinContext is an interface to support dynamic dispatch.
type ILForinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_FOR returns the _FOR token.
	Get_FOR() antlr.Token

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_FOR sets the _FOR token.
	Set_FOR(antlr.Token)

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_bloque_inst returns the _bloque_inst rule contexts.
	Get_bloque_inst() IBloque_instContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_bloque_inst sets the _bloque_inst rule contexts.
	Set_bloque_inst(IBloque_instContext)

	// GetLfor returns the lfor attribute.
	GetLfor() interfaces.Instruction

	// SetLfor sets the lfor attribute.
	SetLfor(interfaces.Instruction)

	// Getter signatures
	FOR() antlr.TerminalNode
	ID() antlr.TerminalNode
	IN() antlr.TerminalNode
	Expression() IExpressionContext
	Bloque_inst() IBloque_instContext

	// IsLForinContext differentiates from other interfaces.
	IsLForinContext()
}

type LForinContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	lfor         interfaces.Instruction
	_FOR         antlr.Token
	_ID          antlr.Token
	_expression  IExpressionContext
	_bloque_inst IBloque_instContext
}

func NewEmptyLForinContext() *LForinContext {
	var p = new(LForinContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_lForin
	return p
}

func InitEmptyLForinContext(p *LForinContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_lForin
}

func (*LForinContext) IsLForinContext() {}

func NewLForinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LForinContext {
	var p = new(LForinContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_lForin

	return p
}

func (s *LForinContext) GetParser() antlr.Parser { return s.parser }

func (s *LForinContext) Get_FOR() antlr.Token { return s._FOR }

func (s *LForinContext) Get_ID() antlr.Token { return s._ID }

func (s *LForinContext) Set_FOR(v antlr.Token) { s._FOR = v }

func (s *LForinContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *LForinContext) Get_expression() IExpressionContext { return s._expression }

func (s *LForinContext) Get_bloque_inst() IBloque_instContext { return s._bloque_inst }

func (s *LForinContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *LForinContext) Set_bloque_inst(v IBloque_instContext) { s._bloque_inst = v }

func (s *LForinContext) GetLfor() interfaces.Instruction { return s.lfor }

func (s *LForinContext) SetLfor(v interfaces.Instruction) { s.lfor = v }

func (s *LForinContext) FOR() antlr.TerminalNode {
	return s.GetToken(swiftgrammarFOR, 0)
}

func (s *LForinContext) ID() antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, 0)
}

func (s *LForinContext) IN() antlr.TerminalNode {
	return s.GetToken(swiftgrammarIN, 0)
}

func (s *LForinContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LForinContext) Bloque_inst() IBloque_instContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBloque_instContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBloque_instContext)
}

func (s *LForinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LForinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LForinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterLForin(s)
	}
}

func (s *LForinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitLForin(s)
	}
}

func (p *swiftgrammar) LForin() (localctx ILForinContext) {
	localctx = NewLForinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, swiftgrammarRULE_lForin)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(500)

		var _m = p.Match(swiftgrammarFOR)

		localctx.(*LForinContext)._FOR = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(501)

		var _m = p.Match(swiftgrammarID)

		localctx.(*LForinContext)._ID = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(502)
		p.Match(swiftgrammarIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(503)

		var _x = p.expression(0)

		localctx.(*LForinContext)._expression = _x
	}
	{
		p.SetState(504)

		var _x = p.Bloque_inst()

		localctx.(*LForinContext)._bloque_inst = _x
	}
	localctx.(*LForinContext).lfor = instruction.NewForIn((func() string {
		if localctx.(*LForinContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*LForinContext).Get_ID().GetText()
		}
	}()), localctx.(*LForinContext).Get_expression().GetP(), localctx.(*LForinContext).Get_bloque_inst().GetL(), (func() int {
		if localctx.(*LForinContext).Get_FOR() == nil {
			return 0
		} else {
			return localctx.(*LForinContext).Get_FOR().GetLine()
		}
	}()), (func() int {
		if localctx.(*LForinContext).Get_FOR() == nil {
			return 0
		} else {
			return localctx.(*LForinContext).Get_FOR().GetColumn()
		}
	}()))

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILBreakContext is an interface to support dynamic dispatch.
type ILBreakContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_BREAK returns the _BREAK token.
	Get_BREAK() antlr.Token

	// Set_BREAK sets the _BREAK token.
	Set_BREAK(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetBr returns the br attribute.
	GetBr() interfaces.Instruction

	// SetBr sets the br attribute.
	SetBr(interfaces.Instruction)

	// Getter signatures
	BREAK() antlr.TerminalNode
	Expression() IExpressionContext

	// IsLBreakContext differentiates from other interfaces.
	IsLBreakContext()
}

type LBreakContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	br          interfaces.Instruction
	_BREAK      antlr.Token
	_expression IExpressionContext
}

func NewEmptyLBreakContext() *LBreakContext {
	var p = new(LBreakContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_lBreak
	return p
}

func InitEmptyLBreakContext(p *LBreakContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_lBreak
}

func (*LBreakContext) IsLBreakContext() {}

func NewLBreakContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LBreakContext {
	var p = new(LBreakContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_lBreak

	return p
}

func (s *LBreakContext) GetParser() antlr.Parser { return s.parser }

func (s *LBreakContext) Get_BREAK() antlr.Token { return s._BREAK }

func (s *LBreakContext) Set_BREAK(v antlr.Token) { s._BREAK = v }

func (s *LBreakContext) Get_expression() IExpressionContext { return s._expression }

func (s *LBreakContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *LBreakContext) GetBr() interfaces.Instruction { return s.br }

func (s *LBreakContext) SetBr(v interfaces.Instruction) { s.br = v }

func (s *LBreakContext) BREAK() antlr.TerminalNode {
	return s.GetToken(swiftgrammarBREAK, 0)
}

func (s *LBreakContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LBreakContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LBreakContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LBreakContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterLBreak(s)
	}
}

func (s *LBreakContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitLBreak(s)
	}
}

func (p *swiftgrammar) LBreak() (localctx ILBreakContext) {
	localctx = NewLBreakContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, swiftgrammarRULE_lBreak)
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(507)

			var _m = p.Match(swiftgrammarBREAK)

			localctx.(*LBreakContext)._BREAK = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*LBreakContext).br = instructionExpre.NewBreak(nil, (func() int {
			if localctx.(*LBreakContext).Get_BREAK() == nil {
				return 0
			} else {
				return localctx.(*LBreakContext).Get_BREAK().GetLine()
			}
		}()), (func() int {
			if localctx.(*LBreakContext).Get_BREAK() == nil {
				return 0
			} else {
				return localctx.(*LBreakContext).Get_BREAK().GetColumn()
			}
		}()))

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(509)

			var _m = p.Match(swiftgrammarBREAK)

			localctx.(*LBreakContext)._BREAK = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(510)

			var _x = p.expression(0)

			localctx.(*LBreakContext)._expression = _x
		}
		localctx.(*LBreakContext).br = instructionExpre.NewBreak(localctx.(*LBreakContext).Get_expression().GetP(), (func() int {
			if localctx.(*LBreakContext).Get_BREAK() == nil {
				return 0
			} else {
				return localctx.(*LBreakContext).Get_BREAK().GetLine()
			}
		}()), (func() int {
			if localctx.(*LBreakContext).Get_BREAK() == nil {
				return 0
			} else {
				return localctx.(*LBreakContext).Get_BREAK().GetColumn()
			}
		}()))

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILContinueContext is an interface to support dynamic dispatch.
type ILContinueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_CONTINUE returns the _CONTINUE token.
	Get_CONTINUE() antlr.Token

	// Set_CONTINUE sets the _CONTINUE token.
	Set_CONTINUE(antlr.Token)

	// GetCn returns the cn attribute.
	GetCn() interfaces.Instruction

	// SetCn sets the cn attribute.
	SetCn(interfaces.Instruction)

	// Getter signatures
	CONTINUE() antlr.TerminalNode

	// IsLContinueContext differentiates from other interfaces.
	IsLContinueContext()
}

type LContinueContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	cn        interfaces.Instruction
	_CONTINUE antlr.Token
}

func NewEmptyLContinueContext() *LContinueContext {
	var p = new(LContinueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_lContinue
	return p
}

func InitEmptyLContinueContext(p *LContinueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_lContinue
}

func (*LContinueContext) IsLContinueContext() {}

func NewLContinueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LContinueContext {
	var p = new(LContinueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_lContinue

	return p
}

func (s *LContinueContext) GetParser() antlr.Parser { return s.parser }

func (s *LContinueContext) Get_CONTINUE() antlr.Token { return s._CONTINUE }

func (s *LContinueContext) Set_CONTINUE(v antlr.Token) { s._CONTINUE = v }

func (s *LContinueContext) GetCn() interfaces.Instruction { return s.cn }

func (s *LContinueContext) SetCn(v interfaces.Instruction) { s.cn = v }

func (s *LContinueContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCONTINUE, 0)
}

func (s *LContinueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LContinueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LContinueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterLContinue(s)
	}
}

func (s *LContinueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitLContinue(s)
	}
}

func (p *swiftgrammar) LContinue() (localctx ILContinueContext) {
	localctx = NewLContinueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, swiftgrammarRULE_lContinue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(515)

		var _m = p.Match(swiftgrammarCONTINUE)

		localctx.(*LContinueContext)._CONTINUE = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*LContinueContext).cn = instructionExpre.NewContinue((func() int {
		if localctx.(*LContinueContext).Get_CONTINUE() == nil {
			return 0
		} else {
			return localctx.(*LContinueContext).Get_CONTINUE().GetLine()
		}
	}()), (func() int {
		if localctx.(*LContinueContext).Get_CONTINUE() == nil {
			return 0
		} else {
			return localctx.(*LContinueContext).Get_CONTINUE().GetColumn()
		}
	}()))

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListParamsContext is an interface to support dynamic dispatch.
type IListParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetList returns the list rule contexts.
	GetList() IListParamsContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// SetList sets the list rule contexts.
	SetList(IListParamsContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetL_e returns the l_e attribute.
	GetL_e() *arrayList.List

	// SetL_e sets the l_e attribute.
	SetL_e(*arrayList.List)

	// Getter signatures
	Expression() IExpressionContext
	COMA() antlr.TerminalNode
	ListParams() IListParamsContext

	// IsListParamsContext differentiates from other interfaces.
	IsListParamsContext()
}

type ListParamsContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	l_e         *arrayList.List
	list        IListParamsContext
	_expression IExpressionContext
}

func NewEmptyListParamsContext() *ListParamsContext {
	var p = new(ListParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_listParams
	return p
}

func InitEmptyListParamsContext(p *ListParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_listParams
}

func (*ListParamsContext) IsListParamsContext() {}

func NewListParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListParamsContext {
	var p = new(ListParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_listParams

	return p
}

func (s *ListParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *ListParamsContext) GetList() IListParamsContext { return s.list }

func (s *ListParamsContext) Get_expression() IExpressionContext { return s._expression }

func (s *ListParamsContext) SetList(v IListParamsContext) { s.list = v }

func (s *ListParamsContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *ListParamsContext) GetL_e() *arrayList.List { return s.l_e }

func (s *ListParamsContext) SetL_e(v *arrayList.List) { s.l_e = v }

func (s *ListParamsContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListParamsContext) COMA() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCOMA, 0)
}

func (s *ListParamsContext) ListParams() IListParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListParamsContext)
}

func (s *ListParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterListParams(s)
	}
}

func (s *ListParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitListParams(s)
	}
}

func (p *swiftgrammar) ListParams() (localctx IListParamsContext) {
	return p.listParams(0)
}

func (p *swiftgrammar) listParams(_p int) (localctx IListParamsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewListParamsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListParamsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 44
	p.EnterRecursionRule(localctx, 44, swiftgrammarRULE_listParams, _p)

	localctx.(*ListParamsContext).l_e = arrayList.New()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(519)

		var _x = p.expression(0)

		localctx.(*ListParamsContext)._expression = _x
	}
	localctx.(*ListParamsContext).l_e.Add(localctx.(*ListParamsContext).Get_expression().GetP())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListParamsContext(p, _parentctx, _parentState)
			localctx.(*ListParamsContext).list = _prevctx
			p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_listParams)
			p.SetState(522)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(523)
				p.Match(swiftgrammarCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(524)

				var _x = p.expression(0)

				localctx.(*ListParamsContext)._expression = _x
			}

			localctx.(*ListParamsContext).GetList().GetL_e().Add(localctx.(*ListParamsContext).Get_expression().GetP())
			localctx.(*ListParamsContext).l_e = localctx.(*ListParamsContext).GetList().GetL_e()

		}
		p.SetState(531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListParamsCallContext is an interface to support dynamic dispatch.
type IListParamsCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetList returns the list rule contexts.
	GetList() IListParamsCallContext

	// Get_es_referencia returns the _es_referencia rule contexts.
	Get_es_referencia() IEs_referenciaContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// SetList sets the list rule contexts.
	SetList(IListParamsCallContext)

	// Set_es_referencia sets the _es_referencia rule contexts.
	Set_es_referencia(IEs_referenciaContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetL_e returns the l_e attribute.
	GetL_e() *arrayList.List

	// SetL_e sets the l_e attribute.
	SetL_e(*arrayList.List)

	// Getter signatures
	Es_referencia() IEs_referenciaContext
	Expression() IExpressionContext
	COMA() antlr.TerminalNode
	ListParamsCall() IListParamsCallContext

	// IsListParamsCallContext differentiates from other interfaces.
	IsListParamsCallContext()
}

type ListParamsCallContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	l_e            *arrayList.List
	list           IListParamsCallContext
	_es_referencia IEs_referenciaContext
	_expression    IExpressionContext
}

func NewEmptyListParamsCallContext() *ListParamsCallContext {
	var p = new(ListParamsCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_listParamsCall
	return p
}

func InitEmptyListParamsCallContext(p *ListParamsCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_listParamsCall
}

func (*ListParamsCallContext) IsListParamsCallContext() {}

func NewListParamsCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListParamsCallContext {
	var p = new(ListParamsCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_listParamsCall

	return p
}

func (s *ListParamsCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ListParamsCallContext) GetList() IListParamsCallContext { return s.list }

func (s *ListParamsCallContext) Get_es_referencia() IEs_referenciaContext { return s._es_referencia }

func (s *ListParamsCallContext) Get_expression() IExpressionContext { return s._expression }

func (s *ListParamsCallContext) SetList(v IListParamsCallContext) { s.list = v }

func (s *ListParamsCallContext) Set_es_referencia(v IEs_referenciaContext) { s._es_referencia = v }

func (s *ListParamsCallContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *ListParamsCallContext) GetL_e() *arrayList.List { return s.l_e }

func (s *ListParamsCallContext) SetL_e(v *arrayList.List) { s.l_e = v }

func (s *ListParamsCallContext) Es_referencia() IEs_referenciaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEs_referenciaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEs_referenciaContext)
}

func (s *ListParamsCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListParamsCallContext) COMA() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCOMA, 0)
}

func (s *ListParamsCallContext) ListParamsCall() IListParamsCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListParamsCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListParamsCallContext)
}

func (s *ListParamsCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListParamsCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListParamsCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterListParamsCall(s)
	}
}

func (s *ListParamsCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitListParamsCall(s)
	}
}

func (p *swiftgrammar) ListParamsCall() (localctx IListParamsCallContext) {
	return p.listParamsCall(0)
}

func (p *swiftgrammar) listParamsCall(_p int) (localctx IListParamsCallContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewListParamsCallContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListParamsCallContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 46
	p.EnterRecursionRule(localctx, 46, swiftgrammarRULE_listParamsCall, _p)

	localctx.(*ListParamsCallContext).l_e = arrayList.New()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(533)

		var _x = p.Es_referencia()

		localctx.(*ListParamsCallContext)._es_referencia = _x
	}
	{
		p.SetState(534)

		var _x = p.expression(0)

		localctx.(*ListParamsCallContext)._expression = _x
	}
	ref := instructionExpre.NewParameterBy(localctx.(*ListParamsCallContext).Get_expression().GetP(), localctx.(*ListParamsCallContext).Get_es_referencia().GetRef())
	localctx.(*ListParamsCallContext).l_e.Add(ref)

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListParamsCallContext(p, _parentctx, _parentState)
			localctx.(*ListParamsCallContext).list = _prevctx
			p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_listParamsCall)
			p.SetState(537)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(538)
				p.Match(swiftgrammarCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(539)

				var _x = p.Es_referencia()

				localctx.(*ListParamsCallContext)._es_referencia = _x
			}
			{
				p.SetState(540)

				var _x = p.expression(0)

				localctx.(*ListParamsCallContext)._expression = _x
			}

			ref := instructionExpre.NewParameterBy(localctx.(*ListParamsCallContext).Get_expression().GetP(), localctx.(*ListParamsCallContext).Get_es_referencia().GetRef())
			localctx.(*ListParamsCallContext).GetList().GetL_e().Add(ref)
			localctx.(*ListParamsCallContext).l_e = localctx.(*ListParamsCallContext).GetList().GetL_e()

		}
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEs_referenciaContext is an interface to support dynamic dispatch.
type IEs_referenciaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRef returns the ref attribute.
	GetRef() bool

	// SetRef sets the ref attribute.
	SetRef(bool)

	// Getter signatures
	AMP() antlr.TerminalNode

	// IsEs_referenciaContext differentiates from other interfaces.
	IsEs_referenciaContext()
}

type Es_referenciaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	ref    bool
}

func NewEmptyEs_referenciaContext() *Es_referenciaContext {
	var p = new(Es_referenciaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_es_referencia
	return p
}

func InitEmptyEs_referenciaContext(p *Es_referenciaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_es_referencia
}

func (*Es_referenciaContext) IsEs_referenciaContext() {}

func NewEs_referenciaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Es_referenciaContext {
	var p = new(Es_referenciaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_es_referencia

	return p
}

func (s *Es_referenciaContext) GetParser() antlr.Parser { return s.parser }

func (s *Es_referenciaContext) GetRef() bool { return s.ref }

func (s *Es_referenciaContext) SetRef(v bool) { s.ref = v }

func (s *Es_referenciaContext) AMP() antlr.TerminalNode {
	return s.GetToken(swiftgrammarAMP, 0)
}

func (s *Es_referenciaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Es_referenciaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Es_referenciaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterEs_referencia(s)
	}
}

func (s *Es_referenciaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitEs_referencia(s)
	}
}

func (p *swiftgrammar) Es_referencia() (localctx IEs_referenciaContext) {
	localctx = NewEs_referenciaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, swiftgrammarRULE_es_referencia)
	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(548)
			p.Match(swiftgrammarAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Es_referenciaContext).ref = true

	case 2:
		p.EnterOuterAlt(localctx, 2)
		localctx.(*Es_referenciaContext).ref = false

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclaracionContext is an interface to support dynamic dispatch.
type IDeclaracionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetId returns the id token.
	GetId() antlr.Token

	// GetAsig returns the asig token.
	GetAsig() antlr.Token

	// GetIdob returns the idob token.
	GetIdob() antlr.Token

	// SetId sets the id token.
	SetId(antlr.Token)

	// SetAsig sets the asig token.
	SetAsig(antlr.Token)

	// SetIdob sets the idob token.
	SetIdob(antlr.Token)

	// GetIsVar returns the isVar rule contexts.
	GetIsVar() IEs_varrContext

	// Get_tipos_var returns the _tipos_var rule contexts.
	Get_tipos_var() ITipos_varContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_vector_types returns the _vector_types rule contexts.
	Get_vector_types() IVector_typesContext

	// SetIsVar sets the isVar rule contexts.
	SetIsVar(IEs_varrContext)

	// Set_tipos_var sets the _tipos_var rule contexts.
	Set_tipos_var(ITipos_varContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_vector_types sets the _vector_types rule contexts.
	Set_vector_types(IVector_typesContext)

	// GetInstr returns the instr attribute.
	GetInstr() interfaces.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(interfaces.Instruction)

	// Getter signatures
	DPUNTO2() antlr.TerminalNode
	Tipos_var() ITipos_varContext
	Expression() IExpressionContext
	Es_varr() IEs_varrContext
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	ASIGNACION() antlr.TerminalNode
	Letid() ILetidContext
	Vector_types() IVector_typesContext
	AllCORIZQ() []antlr.TerminalNode
	CORIZQ(i int) antlr.TerminalNode
	AllCORDER() []antlr.TerminalNode
	CORDER(i int) antlr.TerminalNode

	// IsDeclaracionContext differentiates from other interfaces.
	IsDeclaracionContext()
}

type DeclaracionContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	instr         interfaces.Instruction
	isVar         IEs_varrContext
	id            antlr.Token
	_tipos_var    ITipos_varContext
	asig          antlr.Token
	_expression   IExpressionContext
	_vector_types IVector_typesContext
	idob          antlr.Token
}

func NewEmptyDeclaracionContext() *DeclaracionContext {
	var p = new(DeclaracionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_declaracion
	return p
}

func InitEmptyDeclaracionContext(p *DeclaracionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_declaracion
}

func (*DeclaracionContext) IsDeclaracionContext() {}

func NewDeclaracionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaracionContext {
	var p = new(DeclaracionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_declaracion

	return p
}

func (s *DeclaracionContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaracionContext) GetId() antlr.Token { return s.id }

func (s *DeclaracionContext) GetAsig() antlr.Token { return s.asig }

func (s *DeclaracionContext) GetIdob() antlr.Token { return s.idob }

func (s *DeclaracionContext) SetId(v antlr.Token) { s.id = v }

func (s *DeclaracionContext) SetAsig(v antlr.Token) { s.asig = v }

func (s *DeclaracionContext) SetIdob(v antlr.Token) { s.idob = v }

func (s *DeclaracionContext) GetIsVar() IEs_varrContext { return s.isVar }

func (s *DeclaracionContext) Get_tipos_var() ITipos_varContext { return s._tipos_var }

func (s *DeclaracionContext) Get_expression() IExpressionContext { return s._expression }

func (s *DeclaracionContext) Get_vector_types() IVector_typesContext { return s._vector_types }

func (s *DeclaracionContext) SetIsVar(v IEs_varrContext) { s.isVar = v }

func (s *DeclaracionContext) Set_tipos_var(v ITipos_varContext) { s._tipos_var = v }

func (s *DeclaracionContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *DeclaracionContext) Set_vector_types(v IVector_typesContext) { s._vector_types = v }

func (s *DeclaracionContext) GetInstr() interfaces.Instruction { return s.instr }

func (s *DeclaracionContext) SetInstr(v interfaces.Instruction) { s.instr = v }

func (s *DeclaracionContext) DPUNTO2() antlr.TerminalNode {
	return s.GetToken(swiftgrammarDPUNTO2, 0)
}

func (s *DeclaracionContext) Tipos_var() ITipos_varContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipos_varContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipos_varContext)
}

func (s *DeclaracionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeclaracionContext) Es_varr() IEs_varrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEs_varrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEs_varrContext)
}

func (s *DeclaracionContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(swiftgrammarID)
}

func (s *DeclaracionContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, i)
}

func (s *DeclaracionContext) ASIGNACION() antlr.TerminalNode {
	return s.GetToken(swiftgrammarASIGNACION, 0)
}

func (s *DeclaracionContext) Letid() ILetidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetidContext)
}

func (s *DeclaracionContext) Vector_types() IVector_typesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVector_typesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVector_typesContext)
}

func (s *DeclaracionContext) AllCORIZQ() []antlr.TerminalNode {
	return s.GetTokens(swiftgrammarCORIZQ)
}

func (s *DeclaracionContext) CORIZQ(i int) antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORIZQ, i)
}

func (s *DeclaracionContext) AllCORDER() []antlr.TerminalNode {
	return s.GetTokens(swiftgrammarCORDER)
}

func (s *DeclaracionContext) CORDER(i int) antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORDER, i)
}

func (s *DeclaracionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaracionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaracionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterDeclaracion(s)
	}
}

func (s *DeclaracionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitDeclaracion(s)
	}
}

func (p *swiftgrammar) Declaracion() (localctx IDeclaracionContext) {
	localctx = NewDeclaracionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, swiftgrammarRULE_declaracion)
	p.SetState(616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(553)

			var _x = p.Es_varr()

			localctx.(*DeclaracionContext).isVar = _x
		}
		{
			p.SetState(554)

			var _m = p.Match(swiftgrammarID)

			localctx.(*DeclaracionContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(555)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(556)

			var _x = p.Tipos_var()

			localctx.(*DeclaracionContext)._tipos_var = _x
		}
		{
			p.SetState(557)

			var _m = p.Match(swiftgrammarASIGNACION)

			localctx.(*DeclaracionContext).asig = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(558)

			var _x = p.expression(0)

			localctx.(*DeclaracionContext)._expression = _x
		}

		localctx.(*DeclaracionContext).instr = instruction.NewDeclaration((func() string {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DeclaracionContext).GetId().GetText()
			}
		}()), localctx.(*DeclaracionContext).Get_tipos_var().GetTipo(), localctx.(*DeclaracionContext).Get_expression().GetP(), localctx.(*DeclaracionContext).GetIsVar().GetMut(), (func() int {
			if localctx.(*DeclaracionContext).GetAsig() == nil {
				return 0
			} else {
				return localctx.(*DeclaracionContext).GetAsig().GetLine()
			}
		}()), localctx.(*DeclaracionContext).GetAsig().GetColumn())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(561)

			var _x = p.Es_varr()

			localctx.(*DeclaracionContext).isVar = _x
		}
		{
			p.SetState(562)

			var _m = p.Match(swiftgrammarID)

			localctx.(*DeclaracionContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(563)
			p.Letid()
		}
		{
			p.SetState(564)

			var _m = p.Match(swiftgrammarASIGNACION)

			localctx.(*DeclaracionContext).asig = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(565)

			var _x = p.expression(0)

			localctx.(*DeclaracionContext)._expression = _x
		}

		localctx.(*DeclaracionContext).instr = instruction.NewDeclaration((func() string {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DeclaracionContext).GetId().GetText()
			}
		}()), interfaces.NULL, localctx.(*DeclaracionContext).Get_expression().GetP(), localctx.(*DeclaracionContext).GetIsVar().GetMut(), (func() int {
			if localctx.(*DeclaracionContext).GetAsig() == nil {
				return 0
			} else {
				return localctx.(*DeclaracionContext).GetAsig().GetLine()
			}
		}()), localctx.(*DeclaracionContext).GetAsig().GetColumn())

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(568)

			var _x = p.Es_varr()

			localctx.(*DeclaracionContext).isVar = _x
		}
		{
			p.SetState(569)

			var _m = p.Match(swiftgrammarID)

			localctx.(*DeclaracionContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(570)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(571)

			var _x = p.Vector_types()

			localctx.(*DeclaracionContext)._vector_types = _x
		}
		{
			p.SetState(572)
			p.Match(swiftgrammarASIGNACION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(573)
			p.Match(swiftgrammarCORIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(574)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*DeclaracionContext).instr = instruction.NewVectorDeclaration((func() string {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DeclaracionContext).GetId().GetText()
			}
		}()), localctx.(*DeclaracionContext).Get_vector_types().GetTipo(), nil, localctx.(*DeclaracionContext).GetIsVar().GetMut(), (func() int {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*DeclaracionContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*DeclaracionContext).GetId().GetColumn()
			}
		}()), nil, "")

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(577)

			var _x = p.Es_varr()

			localctx.(*DeclaracionContext).isVar = _x
		}
		{
			p.SetState(578)

			var _m = p.Match(swiftgrammarID)

			localctx.(*DeclaracionContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(579)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(580)

			var _x = p.Vector_types()

			localctx.(*DeclaracionContext)._vector_types = _x
		}
		{
			p.SetState(581)
			p.Match(swiftgrammarASIGNACION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(582)

			var _x = p.expression(0)

			localctx.(*DeclaracionContext)._expression = _x
		}

		localctx.(*DeclaracionContext).instr = instruction.NewVectorDeclaration((func() string {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DeclaracionContext).GetId().GetText()
			}
		}()), localctx.(*DeclaracionContext).Get_vector_types().GetTipo(), nil, localctx.(*DeclaracionContext).GetIsVar().GetMut(), (func() int {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*DeclaracionContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*DeclaracionContext).GetId().GetColumn()
			}
		}()), localctx.(*DeclaracionContext).Get_expression().GetP(), "")

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(585)

			var _x = p.Es_varr()

			localctx.(*DeclaracionContext).isVar = _x
		}
		{
			p.SetState(586)

			var _m = p.Match(swiftgrammarID)

			localctx.(*DeclaracionContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(587)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(588)
			p.Match(swiftgrammarCORIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(589)

			var _m = p.Match(swiftgrammarID)

			localctx.(*DeclaracionContext).idob = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(590)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(591)
			p.Match(swiftgrammarASIGNACION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(592)
			p.Match(swiftgrammarCORIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(593)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*DeclaracionContext).instr = instruction.NewVectorDeclaration((func() string {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DeclaracionContext).GetId().GetText()
			}
		}()), interfaces.STRUCT, nil, localctx.(*DeclaracionContext).GetIsVar().GetMut(), (func() int {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*DeclaracionContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*DeclaracionContext).GetId().GetColumn()
			}
		}()), nil, (func() string {
			if localctx.(*DeclaracionContext).GetIdob() == nil {
				return ""
			} else {
				return localctx.(*DeclaracionContext).GetIdob().GetText()
			}
		}()))

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(596)

			var _x = p.Es_varr()

			localctx.(*DeclaracionContext).isVar = _x
		}
		{
			p.SetState(597)

			var _m = p.Match(swiftgrammarID)

			localctx.(*DeclaracionContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(598)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(599)
			p.Match(swiftgrammarCORIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(600)

			var _m = p.Match(swiftgrammarID)

			localctx.(*DeclaracionContext).idob = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(601)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(602)
			p.Match(swiftgrammarASIGNACION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(603)

			var _x = p.expression(0)

			localctx.(*DeclaracionContext)._expression = _x
		}

		localctx.(*DeclaracionContext).instr = instruction.NewVectorDeclaration((func() string {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DeclaracionContext).GetId().GetText()
			}
		}()), interfaces.NULL, nil, localctx.(*DeclaracionContext).GetIsVar().GetMut(), (func() int {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*DeclaracionContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*DeclaracionContext).GetId().GetColumn()
			}
		}()), localctx.(*DeclaracionContext).Get_expression().GetP(), (func() string {
			if localctx.(*DeclaracionContext).GetIdob() == nil {
				return ""
			} else {
				return localctx.(*DeclaracionContext).GetIdob().GetText()
			}
		}()))

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(606)

			var _x = p.Es_varr()

			localctx.(*DeclaracionContext).isVar = _x
		}
		{
			p.SetState(607)

			var _m = p.Match(swiftgrammarID)

			localctx.(*DeclaracionContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(608)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(609)
			p.Match(swiftgrammarCORIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(610)

			var _x = p.Tipos_var()

			localctx.(*DeclaracionContext)._tipos_var = _x
		}
		{
			p.SetState(611)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(612)
			p.Match(swiftgrammarASIGNACION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(613)

			var _x = p.expression(0)

			localctx.(*DeclaracionContext)._expression = _x
		}

		localctx.(*DeclaracionContext).instr = instruction.NewVectorDeclaration((func() string {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DeclaracionContext).GetId().GetText()
			}
		}()), localctx.(*DeclaracionContext).Get_tipos_var().GetTipo(), nil, localctx.(*DeclaracionContext).GetIsVar().GetMut(), (func() int {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*DeclaracionContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeclaracionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*DeclaracionContext).GetId().GetColumn()
			}
		}()), localctx.(*DeclaracionContext).Get_expression().GetP(), "")

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEs_varContext is an interface to support dynamic dispatch.
type IEs_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMut returns the mut attribute.
	GetMut() bool

	// SetMut sets the mut attribute.
	SetMut(bool)

	// Getter signatures
	MUT() antlr.TerminalNode

	// IsEs_varContext differentiates from other interfaces.
	IsEs_varContext()
}

type Es_varContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mut    bool
}

func NewEmptyEs_varContext() *Es_varContext {
	var p = new(Es_varContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_es_var
	return p
}

func InitEmptyEs_varContext(p *Es_varContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_es_var
}

func (*Es_varContext) IsEs_varContext() {}

func NewEs_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Es_varContext {
	var p = new(Es_varContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_es_var

	return p
}

func (s *Es_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Es_varContext) GetMut() bool { return s.mut }

func (s *Es_varContext) SetMut(v bool) { s.mut = v }

func (s *Es_varContext) MUT() antlr.TerminalNode {
	return s.GetToken(swiftgrammarMUT, 0)
}

func (s *Es_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Es_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Es_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterEs_var(s)
	}
}

func (s *Es_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitEs_var(s)
	}
}

func (p *swiftgrammar) Es_var() (localctx IEs_varContext) {
	localctx = NewEs_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, swiftgrammarRULE_es_var)
	p.SetState(621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case swiftgrammarMUT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(618)
			p.Match(swiftgrammarMUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Es_varContext).mut = true

	case swiftgrammarID:
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEs_varrContext is an interface to support dynamic dispatch.
type IEs_varrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMut returns the mut attribute.
	GetMut() bool

	// SetMut sets the mut attribute.
	SetMut(bool)

	// Getter signatures
	MUT() antlr.TerminalNode
	LET() antlr.TerminalNode

	// IsEs_varrContext differentiates from other interfaces.
	IsEs_varrContext()
}

type Es_varrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mut    bool
}

func NewEmptyEs_varrContext() *Es_varrContext {
	var p = new(Es_varrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_es_varr
	return p
}

func InitEmptyEs_varrContext(p *Es_varrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_es_varr
}

func (*Es_varrContext) IsEs_varrContext() {}

func NewEs_varrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Es_varrContext {
	var p = new(Es_varrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_es_varr

	return p
}

func (s *Es_varrContext) GetParser() antlr.Parser { return s.parser }

func (s *Es_varrContext) GetMut() bool { return s.mut }

func (s *Es_varrContext) SetMut(v bool) { s.mut = v }

func (s *Es_varrContext) MUT() antlr.TerminalNode {
	return s.GetToken(swiftgrammarMUT, 0)
}

func (s *Es_varrContext) LET() antlr.TerminalNode {
	return s.GetToken(swiftgrammarLET, 0)
}

func (s *Es_varrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Es_varrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Es_varrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterEs_varr(s)
	}
}

func (s *Es_varrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitEs_varr(s)
	}
}

func (p *swiftgrammar) Es_varr() (localctx IEs_varrContext) {
	localctx = NewEs_varrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, swiftgrammarRULE_es_varr)
	p.SetState(627)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case swiftgrammarMUT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(623)
			p.Match(swiftgrammarMUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Es_varrContext).mut = true

	case swiftgrammarLET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(625)
			p.Match(swiftgrammarLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Es_varrContext).mut = false

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetidContext is an interface to support dynamic dispatch.
type ILetidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DPUNTO2() antlr.TerminalNode
	ID() antlr.TerminalNode

	// IsLetidContext differentiates from other interfaces.
	IsLetidContext()
}

type LetidContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetidContext() *LetidContext {
	var p = new(LetidContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_letid
	return p
}

func InitEmptyLetidContext(p *LetidContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_letid
}

func (*LetidContext) IsLetidContext() {}

func NewLetidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetidContext {
	var p = new(LetidContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_letid

	return p
}

func (s *LetidContext) GetParser() antlr.Parser { return s.parser }

func (s *LetidContext) DPUNTO2() antlr.TerminalNode {
	return s.GetToken(swiftgrammarDPUNTO2, 0)
}

func (s *LetidContext) ID() antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, 0)
}

func (s *LetidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterLetid(s)
	}
}

func (s *LetidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitLetid(s)
	}
}

func (p *swiftgrammar) Letid() (localctx ILetidContext) {
	localctx = NewLetidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, swiftgrammarRULE_letid)
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case swiftgrammarDPUNTO2:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(629)
			p.Match(swiftgrammarDPUNTO2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(630)
			p.Match(swiftgrammarID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case swiftgrammarASIGNACION:
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVector_typesContext is an interface to support dynamic dispatch.
type IVector_typesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_tipos_var returns the _tipos_var rule contexts.
	Get_tipos_var() ITipos_varContext

	// Set_tipos_var sets the _tipos_var rule contexts.
	Set_tipos_var(ITipos_varContext)

	// GetTipo returns the tipo attribute.
	GetTipo() interfaces.TipoExpresion

	// SetTipo sets the tipo attribute.
	SetTipo(interfaces.TipoExpresion)

	// Getter signatures
	CORIZQ() antlr.TerminalNode
	Vector_types() IVector_typesContext
	CORDER() antlr.TerminalNode
	Tipos_var() ITipos_varContext

	// IsVector_typesContext differentiates from other interfaces.
	IsVector_typesContext()
}

type Vector_typesContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	tipo       interfaces.TipoExpresion
	_tipos_var ITipos_varContext
}

func NewEmptyVector_typesContext() *Vector_typesContext {
	var p = new(Vector_typesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_vector_types
	return p
}

func InitEmptyVector_typesContext(p *Vector_typesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_vector_types
}

func (*Vector_typesContext) IsVector_typesContext() {}

func NewVector_typesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Vector_typesContext {
	var p = new(Vector_typesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_vector_types

	return p
}

func (s *Vector_typesContext) GetParser() antlr.Parser { return s.parser }

func (s *Vector_typesContext) Get_tipos_var() ITipos_varContext { return s._tipos_var }

func (s *Vector_typesContext) Set_tipos_var(v ITipos_varContext) { s._tipos_var = v }

func (s *Vector_typesContext) GetTipo() interfaces.TipoExpresion { return s.tipo }

func (s *Vector_typesContext) SetTipo(v interfaces.TipoExpresion) { s.tipo = v }

func (s *Vector_typesContext) CORIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORIZQ, 0)
}

func (s *Vector_typesContext) Vector_types() IVector_typesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVector_typesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVector_typesContext)
}

func (s *Vector_typesContext) CORDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORDER, 0)
}

func (s *Vector_typesContext) Tipos_var() ITipos_varContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipos_varContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipos_varContext)
}

func (s *Vector_typesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Vector_typesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Vector_typesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterVector_types(s)
	}
}

func (s *Vector_typesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitVector_types(s)
	}
}

func (p *swiftgrammar) Vector_types() (localctx IVector_typesContext) {
	localctx = NewVector_typesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, swiftgrammarRULE_vector_types)
	p.SetState(644)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(634)
			p.Match(swiftgrammarCORIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(635)
			p.Vector_types()
		}
		{
			p.SetState(636)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Vector_typesContext).tipo = interfaces.VECTOR

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(639)
			p.Match(swiftgrammarCORIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(640)

			var _x = p.Tipos_var()

			localctx.(*Vector_typesContext)._tipos_var = _x
		}
		{
			p.SetState(641)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Vector_typesContext).tipo = localctx.(*Vector_typesContext).Get_tipos_var().GetTipo()

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArray_typeContext is an interface to support dynamic dispatch.
type IArray_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_CORIZQ returns the _CORIZQ token.
	Get_CORIZQ() antlr.Token

	// Set_CORIZQ sets the _CORIZQ token.
	Set_CORIZQ(antlr.Token)

	// Get_array_type returns the _array_type rule contexts.
	Get_array_type() IArray_typeContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_tipos_var returns the _tipos_var rule contexts.
	Get_tipos_var() ITipos_varContext

	// Set_array_type sets the _array_type rule contexts.
	Set_array_type(IArray_typeContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_tipos_var sets the _tipos_var rule contexts.
	Set_tipos_var(ITipos_varContext)

	// GetTy returns the ty attribute.
	GetTy() *arrayList.List

	// SetTy sets the ty attribute.
	SetTy(*arrayList.List)

	// Getter signatures
	CORIZQ() antlr.TerminalNode
	Array_type() IArray_typeContext
	PTCOMA() antlr.TerminalNode
	Expression() IExpressionContext
	CORDER() antlr.TerminalNode
	Tipos_var() ITipos_varContext

	// IsArray_typeContext differentiates from other interfaces.
	IsArray_typeContext()
}

type Array_typeContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	ty          *arrayList.List
	_CORIZQ     antlr.Token
	_array_type IArray_typeContext
	_expression IExpressionContext
	_tipos_var  ITipos_varContext
}

func NewEmptyArray_typeContext() *Array_typeContext {
	var p = new(Array_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_array_type
	return p
}

func InitEmptyArray_typeContext(p *Array_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_array_type
}

func (*Array_typeContext) IsArray_typeContext() {}

func NewArray_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_typeContext {
	var p = new(Array_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_array_type

	return p
}

func (s *Array_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_typeContext) Get_CORIZQ() antlr.Token { return s._CORIZQ }

func (s *Array_typeContext) Set_CORIZQ(v antlr.Token) { s._CORIZQ = v }

func (s *Array_typeContext) Get_array_type() IArray_typeContext { return s._array_type }

func (s *Array_typeContext) Get_expression() IExpressionContext { return s._expression }

func (s *Array_typeContext) Get_tipos_var() ITipos_varContext { return s._tipos_var }

func (s *Array_typeContext) Set_array_type(v IArray_typeContext) { s._array_type = v }

func (s *Array_typeContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Array_typeContext) Set_tipos_var(v ITipos_varContext) { s._tipos_var = v }

func (s *Array_typeContext) GetTy() *arrayList.List { return s.ty }

func (s *Array_typeContext) SetTy(v *arrayList.List) { s.ty = v }

func (s *Array_typeContext) CORIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORIZQ, 0)
}

func (s *Array_typeContext) Array_type() IArray_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_typeContext)
}

func (s *Array_typeContext) PTCOMA() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPTCOMA, 0)
}

func (s *Array_typeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Array_typeContext) CORDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORDER, 0)
}

func (s *Array_typeContext) Tipos_var() ITipos_varContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipos_varContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipos_varContext)
}

func (s *Array_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterArray_type(s)
	}
}

func (s *Array_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitArray_type(s)
	}
}

func (p *swiftgrammar) Array_type() (localctx IArray_typeContext) {
	localctx = NewArray_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, swiftgrammarRULE_array_type)

	localctx.(*Array_typeContext).ty = arrayList.New()

	p.SetState(665)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(646)

			var _m = p.Match(swiftgrammarCORIZQ)

			localctx.(*Array_typeContext)._CORIZQ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(647)

			var _x = p.Array_type()

			localctx.(*Array_typeContext)._array_type = _x
		}
		{
			p.SetState(648)
			p.Match(swiftgrammarPTCOMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(649)

			var _x = p.expression(0)

			localctx.(*Array_typeContext)._expression = _x
		}
		{
			p.SetState(650)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		nType := interfaces.NewArrayType(interfaces.ARRAY, localctx.(*Array_typeContext).Get_expression().GetP(), (func() int {
			if localctx.(*Array_typeContext).Get_CORIZQ() == nil {
				return 0
			} else {
				return localctx.(*Array_typeContext).Get_CORIZQ().GetLine()
			}
		}()), (func() int {
			if localctx.(*Array_typeContext).Get_CORIZQ() == nil {
				return 0
			} else {
				return localctx.(*Array_typeContext).Get_CORIZQ().GetColumn()
			}
		}()))
		localctx.(*Array_typeContext).Get_array_type().GetTy().Add(nType)
		localctx.(*Array_typeContext).ty = localctx.(*Array_typeContext).Get_array_type().GetTy()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(653)

			var _m = p.Match(swiftgrammarCORIZQ)

			localctx.(*Array_typeContext)._CORIZQ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(654)

			var _x = p.Tipos_var()

			localctx.(*Array_typeContext)._tipos_var = _x
		}
		{
			p.SetState(655)
			p.Match(swiftgrammarPTCOMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(656)

			var _x = p.expression(0)

			localctx.(*Array_typeContext)._expression = _x
		}
		{
			p.SetState(657)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		nType := interfaces.NewArrayType(localctx.(*Array_typeContext).Get_tipos_var().GetTipo(), localctx.(*Array_typeContext).Get_expression().GetP(), (func() int {
			if localctx.(*Array_typeContext).Get_CORIZQ() == nil {
				return 0
			} else {
				return localctx.(*Array_typeContext).Get_CORIZQ().GetLine()
			}
		}()), (func() int {
			if localctx.(*Array_typeContext).Get_CORIZQ() == nil {
				return 0
			} else {
				return localctx.(*Array_typeContext).Get_CORIZQ().GetColumn()
			}
		}()))
		localctx.(*Array_typeContext).ty.Add(nType)

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(660)

			var _m = p.Match(swiftgrammarCORIZQ)

			localctx.(*Array_typeContext)._CORIZQ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(661)

			var _x = p.Tipos_var()

			localctx.(*Array_typeContext)._tipos_var = _x
		}
		{
			p.SetState(662)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		nType := interfaces.NewArrayType(localctx.(*Array_typeContext).Get_tipos_var().GetTipo(), nil, (func() int {
			if localctx.(*Array_typeContext).Get_CORIZQ() == nil {
				return 0
			} else {
				return localctx.(*Array_typeContext).Get_CORIZQ().GetLine()
			}
		}()), (func() int {
			if localctx.(*Array_typeContext).Get_CORIZQ() == nil {
				return 0
			} else {
				return localctx.(*Array_typeContext).Get_CORIZQ().GetColumn()
			}
		}()))
		localctx.(*Array_typeContext).ty.Add(nType)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsignacionContext is an interface to support dynamic dispatch.
type IAsignacionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetId returns the id token.
	GetId() antlr.Token

	// SetId sets the id token.
	SetId(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_list_index returns the _list_index rule contexts.
	Get_list_index() IList_indexContext

	// Get_l_AccessStruct returns the _l_AccessStruct rule contexts.
	Get_l_AccessStruct() IL_AccessStructContext

	// GetIndex returns the index rule contexts.
	GetIndex() IExpressionContext

	// GetVal returns the val rule contexts.
	GetVal() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_list_index sets the _list_index rule contexts.
	Set_list_index(IList_indexContext)

	// Set_l_AccessStruct sets the _l_AccessStruct rule contexts.
	Set_l_AccessStruct(IL_AccessStructContext)

	// SetIndex sets the index rule contexts.
	SetIndex(IExpressionContext)

	// SetVal sets the val rule contexts.
	SetVal(IExpressionContext)

	// GetInstr returns the instr attribute.
	GetInstr() interfaces.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(interfaces.Instruction)

	// Getter signatures
	ASIGNACION() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	ID() antlr.TerminalNode
	List_index() IList_indexContext
	L_AccessStruct() IL_AccessStructContext
	CORIZQ() antlr.TerminalNode
	CORDER() antlr.TerminalNode
	PUNTO() antlr.TerminalNode
	ASIG() antlr.TerminalNode

	// IsAsignacionContext differentiates from other interfaces.
	IsAsignacionContext()
}

type AsignacionContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	instr           interfaces.Instruction
	id              antlr.Token
	_expression     IExpressionContext
	_list_index     IList_indexContext
	_l_AccessStruct IL_AccessStructContext
	index           IExpressionContext
	val             IExpressionContext
}

func NewEmptyAsignacionContext() *AsignacionContext {
	var p = new(AsignacionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_asignacion
	return p
}

func InitEmptyAsignacionContext(p *AsignacionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_asignacion
}

func (*AsignacionContext) IsAsignacionContext() {}

func NewAsignacionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsignacionContext {
	var p = new(AsignacionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_asignacion

	return p
}

func (s *AsignacionContext) GetParser() antlr.Parser { return s.parser }

func (s *AsignacionContext) GetId() antlr.Token { return s.id }

func (s *AsignacionContext) SetId(v antlr.Token) { s.id = v }

func (s *AsignacionContext) Get_expression() IExpressionContext { return s._expression }

func (s *AsignacionContext) Get_list_index() IList_indexContext { return s._list_index }

func (s *AsignacionContext) Get_l_AccessStruct() IL_AccessStructContext { return s._l_AccessStruct }

func (s *AsignacionContext) GetIndex() IExpressionContext { return s.index }

func (s *AsignacionContext) GetVal() IExpressionContext { return s.val }

func (s *AsignacionContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *AsignacionContext) Set_list_index(v IList_indexContext) { s._list_index = v }

func (s *AsignacionContext) Set_l_AccessStruct(v IL_AccessStructContext) { s._l_AccessStruct = v }

func (s *AsignacionContext) SetIndex(v IExpressionContext) { s.index = v }

func (s *AsignacionContext) SetVal(v IExpressionContext) { s.val = v }

func (s *AsignacionContext) GetInstr() interfaces.Instruction { return s.instr }

func (s *AsignacionContext) SetInstr(v interfaces.Instruction) { s.instr = v }

func (s *AsignacionContext) ASIGNACION() antlr.TerminalNode {
	return s.GetToken(swiftgrammarASIGNACION, 0)
}

func (s *AsignacionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AsignacionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AsignacionContext) ID() antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, 0)
}

func (s *AsignacionContext) List_index() IList_indexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_indexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_indexContext)
}

func (s *AsignacionContext) L_AccessStruct() IL_AccessStructContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IL_AccessStructContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IL_AccessStructContext)
}

func (s *AsignacionContext) CORIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORIZQ, 0)
}

func (s *AsignacionContext) CORDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORDER, 0)
}

func (s *AsignacionContext) PUNTO() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPUNTO, 0)
}

func (s *AsignacionContext) ASIG() antlr.TerminalNode {
	return s.GetToken(swiftgrammarASIG, 0)
}

func (s *AsignacionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsignacionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsignacionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterAsignacion(s)
	}
}

func (s *AsignacionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitAsignacion(s)
	}
}

func (p *swiftgrammar) Asignacion() (localctx IAsignacionContext) {
	localctx = NewAsignacionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, swiftgrammarRULE_asignacion)
	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(667)

			var _m = p.Match(swiftgrammarID)

			localctx.(*AsignacionContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(668)
			p.Match(swiftgrammarASIGNACION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(669)

			var _x = p.expression(0)

			localctx.(*AsignacionContext)._expression = _x
		}
		localctx.(*AsignacionContext).instr = instruction.NewAssignment((func() string {
			if localctx.(*AsignacionContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*AsignacionContext).GetId().GetText()
			}
		}()), localctx.(*AsignacionContext).Get_expression().GetP(), nil, (func() int {
			if localctx.(*AsignacionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*AsignacionContext).GetId().GetLine()
			}
		}()), localctx.(*AsignacionContext).GetId().GetColumn())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(672)

			var _m = p.Match(swiftgrammarID)

			localctx.(*AsignacionContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(673)

			var _x = p.list_index(0)

			localctx.(*AsignacionContext)._list_index = _x
		}
		{
			p.SetState(674)
			p.Match(swiftgrammarASIGNACION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(675)

			var _x = p.expression(0)

			localctx.(*AsignacionContext)._expression = _x
		}
		localctx.(*AsignacionContext).instr = instruction.NewAssignment((func() string {
			if localctx.(*AsignacionContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*AsignacionContext).GetId().GetText()
			}
		}()), localctx.(*AsignacionContext).Get_expression().GetP(), localctx.(*AsignacionContext).Get_list_index().GetLista(), (func() int {
			if localctx.(*AsignacionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*AsignacionContext).GetId().GetLine()
			}
		}()), localctx.(*AsignacionContext).GetId().GetColumn())

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(678)

			var _x = p.l_AccessStruct(0)

			localctx.(*AsignacionContext)._l_AccessStruct = _x
		}
		{
			p.SetState(679)
			p.Match(swiftgrammarASIGNACION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(680)

			var _x = p.expression(0)

			localctx.(*AsignacionContext)._expression = _x
		}
		localctx.(*AsignacionContext).instr = instruction.NewAssignmentStruct(localctx.(*AsignacionContext).Get_l_AccessStruct().GetL(), localctx.(*AsignacionContext).Get_expression().GetP(), (func() antlr.Token {
			if localctx.(*AsignacionContext).Get_l_AccessStruct() == nil {
				return nil
			} else {
				return localctx.(*AsignacionContext).Get_l_AccessStruct().GetStart()
			}
		}()).GetLine(), (func() antlr.Token {
			if localctx.(*AsignacionContext).Get_l_AccessStruct() == nil {
				return nil
			} else {
				return localctx.(*AsignacionContext).Get_l_AccessStruct().GetStart()
			}
		}()).GetColumn())

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(683)

			var _m = p.Match(swiftgrammarID)

			localctx.(*AsignacionContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(684)
			p.Match(swiftgrammarCORIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(685)

			var _x = p.expression(0)

			localctx.(*AsignacionContext).index = _x
		}
		{
			p.SetState(686)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(687)
			p.Match(swiftgrammarPUNTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(688)

			var _x = p.l_AccessStruct(0)

			localctx.(*AsignacionContext)._l_AccessStruct = _x
		}
		{
			p.SetState(689)
			p.Match(swiftgrammarASIGNACION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(690)

			var _x = p.expression(0)

			localctx.(*AsignacionContext).val = _x
		}
		localctx.(*AsignacionContext).instr = instruction.NewAssignmentVec((func() string {
			if localctx.(*AsignacionContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*AsignacionContext).GetId().GetText()
			}
		}()), localctx.(*AsignacionContext).GetIndex().GetP(), localctx.(*AsignacionContext).Get_l_AccessStruct().GetL(), localctx.(*AsignacionContext).GetVal().GetP(), (func() int {
			if localctx.(*AsignacionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*AsignacionContext).GetId().GetLine()
			}
		}()), localctx.(*AsignacionContext).GetId().GetColumn())

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(693)

			var _m = p.Match(swiftgrammarID)

			localctx.(*AsignacionContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(694)
			p.Match(swiftgrammarASIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(695)

			var _x = p.expression(0)

			localctx.(*AsignacionContext)._expression = _x
		}
		localctx.(*AsignacionContext).instr = instruction.NewIncrement((func() string {
			if localctx.(*AsignacionContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*AsignacionContext).GetId().GetText()
			}
		}()), localctx.(*AsignacionContext).Get_expression().GetP(), (func() int {
			if localctx.(*AsignacionContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*AsignacionContext).GetId().GetLine()
			}
		}()), localctx.(*AsignacionContext).GetId().GetColumn())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IL_AccessStructContext is an interface to support dynamic dispatch.
type IL_AccessStructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// GetList returns the list rule contexts.
	GetList() IL_AccessStructContext

	// SetList sets the list rule contexts.
	SetList(IL_AccessStructContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// Getter signatures
	ID() antlr.TerminalNode
	PUNTO() antlr.TerminalNode
	L_AccessStruct() IL_AccessStructContext

	// IsL_AccessStructContext differentiates from other interfaces.
	IsL_AccessStructContext()
}

type L_AccessStructContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	l      *arrayList.List
	list   IL_AccessStructContext
	_ID    antlr.Token
}

func NewEmptyL_AccessStructContext() *L_AccessStructContext {
	var p = new(L_AccessStructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_l_AccessStruct
	return p
}

func InitEmptyL_AccessStructContext(p *L_AccessStructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_l_AccessStruct
}

func (*L_AccessStructContext) IsL_AccessStructContext() {}

func NewL_AccessStructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *L_AccessStructContext {
	var p = new(L_AccessStructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_l_AccessStruct

	return p
}

func (s *L_AccessStructContext) GetParser() antlr.Parser { return s.parser }

func (s *L_AccessStructContext) Get_ID() antlr.Token { return s._ID }

func (s *L_AccessStructContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *L_AccessStructContext) GetList() IL_AccessStructContext { return s.list }

func (s *L_AccessStructContext) SetList(v IL_AccessStructContext) { s.list = v }

func (s *L_AccessStructContext) GetL() *arrayList.List { return s.l }

func (s *L_AccessStructContext) SetL(v *arrayList.List) { s.l = v }

func (s *L_AccessStructContext) ID() antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, 0)
}

func (s *L_AccessStructContext) PUNTO() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPUNTO, 0)
}

func (s *L_AccessStructContext) L_AccessStruct() IL_AccessStructContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IL_AccessStructContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IL_AccessStructContext)
}

func (s *L_AccessStructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *L_AccessStructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *L_AccessStructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterL_AccessStruct(s)
	}
}

func (s *L_AccessStructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitL_AccessStruct(s)
	}
}

func (p *swiftgrammar) L_AccessStruct() (localctx IL_AccessStructContext) {
	return p.l_AccessStruct(0)
}

func (p *swiftgrammar) l_AccessStruct(_p int) (localctx IL_AccessStructContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewL_AccessStructContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IL_AccessStructContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 64
	p.EnterRecursionRule(localctx, 64, swiftgrammarRULE_l_AccessStruct, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(701)

		var _m = p.Match(swiftgrammarID)

		localctx.(*L_AccessStructContext)._ID = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	localctx.(*L_AccessStructContext).l = arrayList.New()
	localctx.(*L_AccessStructContext).l.Add((func() string {
		if localctx.(*L_AccessStructContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*L_AccessStructContext).Get_ID().GetText()
		}
	}()))

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewL_AccessStructContext(p, _parentctx, _parentState)
			localctx.(*L_AccessStructContext).list = _prevctx
			p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_l_AccessStruct)
			p.SetState(704)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(705)
				p.Match(swiftgrammarPUNTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(706)

				var _m = p.Match(swiftgrammarID)

				localctx.(*L_AccessStructContext)._ID = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			localctx.(*L_AccessStructContext).GetList().GetL().Add((func() string {
				if localctx.(*L_AccessStructContext).Get_ID() == nil {
					return ""
				} else {
					return localctx.(*L_AccessStructContext).Get_ID().GetText()
				}
			}()))
			localctx.(*L_AccessStructContext).l = localctx.(*L_AccessStructContext).GetList().GetL()

		}
		p.SetState(712)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IList_indexContext is an interface to support dynamic dispatch.
type IList_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetListi returns the listi rule contexts.
	GetListi() IList_indexContext

	// Get_index_array returns the _index_array rule contexts.
	Get_index_array() IIndex_arrayContext

	// SetListi sets the listi rule contexts.
	SetListi(IList_indexContext)

	// Set_index_array sets the _index_array rule contexts.
	Set_index_array(IIndex_arrayContext)

	// GetLista returns the lista attribute.
	GetLista() *arrayList.List

	// SetLista sets the lista attribute.
	SetLista(*arrayList.List)

	// Getter signatures
	Index_array() IIndex_arrayContext
	List_index() IList_indexContext

	// IsList_indexContext differentiates from other interfaces.
	IsList_indexContext()
}

type List_indexContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	lista        *arrayList.List
	listi        IList_indexContext
	_index_array IIndex_arrayContext
}

func NewEmptyList_indexContext() *List_indexContext {
	var p = new(List_indexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_list_index
	return p
}

func InitEmptyList_indexContext(p *List_indexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_list_index
}

func (*List_indexContext) IsList_indexContext() {}

func NewList_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_indexContext {
	var p = new(List_indexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_list_index

	return p
}

func (s *List_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *List_indexContext) GetListi() IList_indexContext { return s.listi }

func (s *List_indexContext) Get_index_array() IIndex_arrayContext { return s._index_array }

func (s *List_indexContext) SetListi(v IList_indexContext) { s.listi = v }

func (s *List_indexContext) Set_index_array(v IIndex_arrayContext) { s._index_array = v }

func (s *List_indexContext) GetLista() *arrayList.List { return s.lista }

func (s *List_indexContext) SetLista(v *arrayList.List) { s.lista = v }

func (s *List_indexContext) Index_array() IIndex_arrayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_arrayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_arrayContext)
}

func (s *List_indexContext) List_index() IList_indexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_indexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_indexContext)
}

func (s *List_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterList_index(s)
	}
}

func (s *List_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitList_index(s)
	}
}

func (p *swiftgrammar) List_index() (localctx IList_indexContext) {
	return p.list_index(0)
}

func (p *swiftgrammar) list_index(_p int) (localctx IList_indexContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewList_indexContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IList_indexContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 66
	p.EnterRecursionRule(localctx, 66, swiftgrammarRULE_list_index, _p)

	localctx.(*List_indexContext).lista = arrayList.New()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(714)

		var _x = p.Index_array()

		localctx.(*List_indexContext)._index_array = _x
	}
	localctx.(*List_indexContext).lista.Add(localctx.(*List_indexContext).Get_index_array().GetIndex())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(723)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewList_indexContext(p, _parentctx, _parentState)
			localctx.(*List_indexContext).listi = _prevctx
			p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_list_index)
			p.SetState(717)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(718)

				var _x = p.Index_array()

				localctx.(*List_indexContext)._index_array = _x
			}

			localctx.(*List_indexContext).GetListi().GetLista().Add(localctx.(*List_indexContext).Get_index_array().GetIndex())
			localctx.(*List_indexContext).lista = localctx.(*List_indexContext).GetListi().GetLista()

		}
		p.SetState(725)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_arrayContext is an interface to support dynamic dispatch.
type IIndex_arrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetIndex returns the index attribute.
	GetIndex() interfaces.Expresion

	// SetIndex sets the index attribute.
	SetIndex(interfaces.Expresion)

	// Getter signatures
	CORIZQ() antlr.TerminalNode
	Expression() IExpressionContext
	CORDER() antlr.TerminalNode

	// IsIndex_arrayContext differentiates from other interfaces.
	IsIndex_arrayContext()
}

type Index_arrayContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	index       interfaces.Expresion
	_expression IExpressionContext
}

func NewEmptyIndex_arrayContext() *Index_arrayContext {
	var p = new(Index_arrayContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_index_array
	return p
}

func InitEmptyIndex_arrayContext(p *Index_arrayContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_index_array
}

func (*Index_arrayContext) IsIndex_arrayContext() {}

func NewIndex_arrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_arrayContext {
	var p = new(Index_arrayContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_index_array

	return p
}

func (s *Index_arrayContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_arrayContext) Get_expression() IExpressionContext { return s._expression }

func (s *Index_arrayContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Index_arrayContext) GetIndex() interfaces.Expresion { return s.index }

func (s *Index_arrayContext) SetIndex(v interfaces.Expresion) { s.index = v }

func (s *Index_arrayContext) CORIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORIZQ, 0)
}

func (s *Index_arrayContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Index_arrayContext) CORDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORDER, 0)
}

func (s *Index_arrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_arrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_arrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterIndex_array(s)
	}
}

func (s *Index_arrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitIndex_array(s)
	}
}

func (p *swiftgrammar) Index_array() (localctx IIndex_arrayContext) {
	localctx = NewIndex_arrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, swiftgrammarRULE_index_array)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(726)
		p.Match(swiftgrammarCORIZQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(727)

		var _x = p.expression(0)

		localctx.(*Index_arrayContext)._expression = _x
	}
	{
		p.SetState(728)
		p.Match(swiftgrammarCORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*Index_arrayContext).index = localctx.(*Index_arrayContext).Get_expression().GetP()

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_sentContext is an interface to support dynamic dispatch.
type IIf_sentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_IF returns the _IF token.
	Get_IF() antlr.Token

	// Set_IF sets the _IF token.
	Set_IF(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_bloque_inst returns the _bloque_inst rule contexts.
	Get_bloque_inst() IBloque_instContext

	// GetBprin returns the bprin rule contexts.
	GetBprin() IBloque_instContext

	// GetBelse returns the belse rule contexts.
	GetBelse() IBloque_instContext

	// Get_list_elseif returns the _list_elseif rule contexts.
	Get_list_elseif() IList_elseifContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_bloque_inst sets the _bloque_inst rule contexts.
	Set_bloque_inst(IBloque_instContext)

	// SetBprin sets the bprin rule contexts.
	SetBprin(IBloque_instContext)

	// SetBelse sets the belse rule contexts.
	SetBelse(IBloque_instContext)

	// Set_list_elseif sets the _list_elseif rule contexts.
	Set_list_elseif(IList_elseifContext)

	// GetInstr returns the instr attribute.
	GetInstr() interfaces.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(interfaces.Instruction)

	// Getter signatures
	IF() antlr.TerminalNode
	Expression() IExpressionContext
	AllBloque_inst() []IBloque_instContext
	Bloque_inst(i int) IBloque_instContext
	ELSE() antlr.TerminalNode
	List_elseif() IList_elseifContext

	// IsIf_sentContext differentiates from other interfaces.
	IsIf_sentContext()
}

type If_sentContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	instr        interfaces.Instruction
	_IF          antlr.Token
	_expression  IExpressionContext
	_bloque_inst IBloque_instContext
	bprin        IBloque_instContext
	belse        IBloque_instContext
	_list_elseif IList_elseifContext
}

func NewEmptyIf_sentContext() *If_sentContext {
	var p = new(If_sentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_if_sent
	return p
}

func InitEmptyIf_sentContext(p *If_sentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_if_sent
}

func (*If_sentContext) IsIf_sentContext() {}

func NewIf_sentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_sentContext {
	var p = new(If_sentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_if_sent

	return p
}

func (s *If_sentContext) GetParser() antlr.Parser { return s.parser }

func (s *If_sentContext) Get_IF() antlr.Token { return s._IF }

func (s *If_sentContext) Set_IF(v antlr.Token) { s._IF = v }

func (s *If_sentContext) Get_expression() IExpressionContext { return s._expression }

func (s *If_sentContext) Get_bloque_inst() IBloque_instContext { return s._bloque_inst }

func (s *If_sentContext) GetBprin() IBloque_instContext { return s.bprin }

func (s *If_sentContext) GetBelse() IBloque_instContext { return s.belse }

func (s *If_sentContext) Get_list_elseif() IList_elseifContext { return s._list_elseif }

func (s *If_sentContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *If_sentContext) Set_bloque_inst(v IBloque_instContext) { s._bloque_inst = v }

func (s *If_sentContext) SetBprin(v IBloque_instContext) { s.bprin = v }

func (s *If_sentContext) SetBelse(v IBloque_instContext) { s.belse = v }

func (s *If_sentContext) Set_list_elseif(v IList_elseifContext) { s._list_elseif = v }

func (s *If_sentContext) GetInstr() interfaces.Instruction { return s.instr }

func (s *If_sentContext) SetInstr(v interfaces.Instruction) { s.instr = v }

func (s *If_sentContext) IF() antlr.TerminalNode {
	return s.GetToken(swiftgrammarIF, 0)
}

func (s *If_sentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *If_sentContext) AllBloque_inst() []IBloque_instContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBloque_instContext); ok {
			len++
		}
	}

	tst := make([]IBloque_instContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBloque_instContext); ok {
			tst[i] = t.(IBloque_instContext)
			i++
		}
	}

	return tst
}

func (s *If_sentContext) Bloque_inst(i int) IBloque_instContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBloque_instContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBloque_instContext)
}

func (s *If_sentContext) ELSE() antlr.TerminalNode {
	return s.GetToken(swiftgrammarELSE, 0)
}

func (s *If_sentContext) List_elseif() IList_elseifContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_elseifContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_elseifContext)
}

func (s *If_sentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_sentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_sentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterIf_sent(s)
	}
}

func (s *If_sentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitIf_sent(s)
	}
}

func (p *swiftgrammar) If_sent() (localctx IIf_sentContext) {
	localctx = NewIf_sentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, swiftgrammarRULE_if_sent)
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(731)

			var _m = p.Match(swiftgrammarIF)

			localctx.(*If_sentContext)._IF = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(732)

			var _x = p.expression(0)

			localctx.(*If_sentContext)._expression = _x
		}
		{
			p.SetState(733)

			var _x = p.Bloque_inst()

			localctx.(*If_sentContext)._bloque_inst = _x
		}
		localctx.(*If_sentContext).instr = instruction.NewIf(localctx.(*If_sentContext).Get_expression().GetP(), localctx.(*If_sentContext).Get_bloque_inst().GetL(), nil, nil, (func() int {
			if localctx.(*If_sentContext).Get_IF() == nil {
				return 0
			} else {
				return localctx.(*If_sentContext).Get_IF().GetLine()
			}
		}()), localctx.(*If_sentContext).Get_IF().GetColumn())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(736)

			var _m = p.Match(swiftgrammarIF)

			localctx.(*If_sentContext)._IF = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(737)

			var _x = p.expression(0)

			localctx.(*If_sentContext)._expression = _x
		}
		{
			p.SetState(738)

			var _x = p.Bloque_inst()

			localctx.(*If_sentContext).bprin = _x
		}
		{
			p.SetState(739)
			p.Match(swiftgrammarELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(740)

			var _x = p.Bloque_inst()

			localctx.(*If_sentContext).belse = _x
		}
		localctx.(*If_sentContext).instr = instruction.NewIf(localctx.(*If_sentContext).Get_expression().GetP(), localctx.(*If_sentContext).GetBprin().GetL(), nil, localctx.(*If_sentContext).GetBelse().GetL(), (func() int {
			if localctx.(*If_sentContext).Get_IF() == nil {
				return 0
			} else {
				return localctx.(*If_sentContext).Get_IF().GetLine()
			}
		}()), localctx.(*If_sentContext).Get_IF().GetColumn())

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(743)

			var _m = p.Match(swiftgrammarIF)

			localctx.(*If_sentContext)._IF = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(744)

			var _x = p.expression(0)

			localctx.(*If_sentContext)._expression = _x
		}
		{
			p.SetState(745)

			var _x = p.Bloque_inst()

			localctx.(*If_sentContext).bprin = _x
		}
		{
			p.SetState(746)

			var _x = p.List_elseif()

			localctx.(*If_sentContext)._list_elseif = _x
		}
		localctx.(*If_sentContext).instr = instruction.NewIf(localctx.(*If_sentContext).Get_expression().GetP(), localctx.(*If_sentContext).GetBprin().GetL(), localctx.(*If_sentContext).Get_list_elseif().GetLista(), nil, (func() int {
			if localctx.(*If_sentContext).Get_IF() == nil {
				return 0
			} else {
				return localctx.(*If_sentContext).Get_IF().GetLine()
			}
		}()), localctx.(*If_sentContext).Get_IF().GetColumn())

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(749)

			var _m = p.Match(swiftgrammarIF)

			localctx.(*If_sentContext)._IF = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(750)

			var _x = p.expression(0)

			localctx.(*If_sentContext)._expression = _x
		}
		{
			p.SetState(751)

			var _x = p.Bloque_inst()

			localctx.(*If_sentContext).bprin = _x
		}
		{
			p.SetState(752)

			var _x = p.List_elseif()

			localctx.(*If_sentContext)._list_elseif = _x
		}
		{
			p.SetState(753)
			p.Match(swiftgrammarELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(754)

			var _x = p.Bloque_inst()

			localctx.(*If_sentContext).belse = _x
		}
		localctx.(*If_sentContext).instr = instruction.NewIf(localctx.(*If_sentContext).Get_expression().GetP(), localctx.(*If_sentContext).GetBprin().GetL(), localctx.(*If_sentContext).Get_list_elseif().GetLista(), localctx.(*If_sentContext).GetBelse().GetL(), (func() int {
			if localctx.(*If_sentContext).Get_IF() == nil {
				return 0
			} else {
				return localctx.(*If_sentContext).Get_IF().GetLine()
			}
		}()), localctx.(*If_sentContext).Get_IF().GetColumn())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_expContext is an interface to support dynamic dispatch.
type IIf_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_IF returns the _IF token.
	Get_IF() antlr.Token

	// Set_IF sets the _IF token.
	Set_IF(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// GetBprin_e returns the bprin_e rule contexts.
	GetBprin_e() IBloque_expContext

	// GetBelse_e returns the belse_e rule contexts.
	GetBelse_e() IBloque_expContext

	// Get_list_elseif_exp returns the _list_elseif_exp rule contexts.
	Get_list_elseif_exp() IList_elseif_expContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// SetBprin_e sets the bprin_e rule contexts.
	SetBprin_e(IBloque_expContext)

	// SetBelse_e sets the belse_e rule contexts.
	SetBelse_e(IBloque_expContext)

	// Set_list_elseif_exp sets the _list_elseif_exp rule contexts.
	Set_list_elseif_exp(IList_elseif_expContext)

	// GetP returns the p attribute.
	GetP() interfaces.Expresion

	// SetP sets the p attribute.
	SetP(interfaces.Expresion)

	// Getter signatures
	IF() antlr.TerminalNode
	Expression() IExpressionContext
	ELSE() antlr.TerminalNode
	AllBloque_exp() []IBloque_expContext
	Bloque_exp(i int) IBloque_expContext
	List_elseif_exp() IList_elseif_expContext

	// IsIf_expContext differentiates from other interfaces.
	IsIf_expContext()
}

type If_expContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	p                interfaces.Expresion
	_IF              antlr.Token
	_expression      IExpressionContext
	bprin_e          IBloque_expContext
	belse_e          IBloque_expContext
	_list_elseif_exp IList_elseif_expContext
}

func NewEmptyIf_expContext() *If_expContext {
	var p = new(If_expContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_if_exp
	return p
}

func InitEmptyIf_expContext(p *If_expContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_if_exp
}

func (*If_expContext) IsIf_expContext() {}

func NewIf_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_expContext {
	var p = new(If_expContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_if_exp

	return p
}

func (s *If_expContext) GetParser() antlr.Parser { return s.parser }

func (s *If_expContext) Get_IF() antlr.Token { return s._IF }

func (s *If_expContext) Set_IF(v antlr.Token) { s._IF = v }

func (s *If_expContext) Get_expression() IExpressionContext { return s._expression }

func (s *If_expContext) GetBprin_e() IBloque_expContext { return s.bprin_e }

func (s *If_expContext) GetBelse_e() IBloque_expContext { return s.belse_e }

func (s *If_expContext) Get_list_elseif_exp() IList_elseif_expContext { return s._list_elseif_exp }

func (s *If_expContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *If_expContext) SetBprin_e(v IBloque_expContext) { s.bprin_e = v }

func (s *If_expContext) SetBelse_e(v IBloque_expContext) { s.belse_e = v }

func (s *If_expContext) Set_list_elseif_exp(v IList_elseif_expContext) { s._list_elseif_exp = v }

func (s *If_expContext) GetP() interfaces.Expresion { return s.p }

func (s *If_expContext) SetP(v interfaces.Expresion) { s.p = v }

func (s *If_expContext) IF() antlr.TerminalNode {
	return s.GetToken(swiftgrammarIF, 0)
}

func (s *If_expContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *If_expContext) ELSE() antlr.TerminalNode {
	return s.GetToken(swiftgrammarELSE, 0)
}

func (s *If_expContext) AllBloque_exp() []IBloque_expContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBloque_expContext); ok {
			len++
		}
	}

	tst := make([]IBloque_expContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBloque_expContext); ok {
			tst[i] = t.(IBloque_expContext)
			i++
		}
	}

	return tst
}

func (s *If_expContext) Bloque_exp(i int) IBloque_expContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBloque_expContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBloque_expContext)
}

func (s *If_expContext) List_elseif_exp() IList_elseif_expContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_elseif_expContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_elseif_expContext)
}

func (s *If_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterIf_exp(s)
	}
}

func (s *If_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitIf_exp(s)
	}
}

func (p *swiftgrammar) If_exp() (localctx IIf_expContext) {
	localctx = NewIf_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, swiftgrammarRULE_if_exp)
	p.SetState(774)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(759)

			var _m = p.Match(swiftgrammarIF)

			localctx.(*If_expContext)._IF = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(760)

			var _x = p.expression(0)

			localctx.(*If_expContext)._expression = _x
		}
		{
			p.SetState(761)

			var _x = p.Bloque_exp()

			localctx.(*If_expContext).bprin_e = _x
		}
		{
			p.SetState(762)
			p.Match(swiftgrammarELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(763)

			var _x = p.Bloque_exp()

			localctx.(*If_expContext).belse_e = _x
		}
		localctx.(*If_expContext).p = instruction.NewIfExpre(localctx.(*If_expContext).Get_expression().GetP(), nil, nil, nil, (func() int {
			if localctx.(*If_expContext).Get_IF() == nil {
				return 0
			} else {
				return localctx.(*If_expContext).Get_IF().GetLine()
			}
		}()), localctx.(*If_expContext).Get_IF().GetColumn(), true, localctx.(*If_expContext).GetBprin_e().GetP(), nil, localctx.(*If_expContext).GetBelse_e().GetP())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(766)

			var _m = p.Match(swiftgrammarIF)

			localctx.(*If_expContext)._IF = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(767)

			var _x = p.expression(0)

			localctx.(*If_expContext)._expression = _x
		}
		{
			p.SetState(768)

			var _x = p.Bloque_exp()

			localctx.(*If_expContext).bprin_e = _x
		}
		{
			p.SetState(769)

			var _x = p.List_elseif_exp()

			localctx.(*If_expContext)._list_elseif_exp = _x
		}
		{
			p.SetState(770)
			p.Match(swiftgrammarELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(771)

			var _x = p.Bloque_exp()

			localctx.(*If_expContext).belse_e = _x
		}

		localctx.(*If_expContext).p = instruction.NewIfExpre(localctx.(*If_expContext).Get_expression().GetP(), nil, nil, nil, (func() int {
			if localctx.(*If_expContext).Get_IF() == nil {
				return 0
			} else {
				return localctx.(*If_expContext).Get_IF().GetLine()
			}
		}()), localctx.(*If_expContext).Get_IF().GetColumn(), true, localctx.(*If_expContext).GetBprin_e().GetP(), localctx.(*If_expContext).Get_list_elseif_exp().GetLista(), localctx.(*If_expContext).GetBelse_e().GetP())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IList_elseifContext is an interface to support dynamic dispatch.
type IList_elseifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_else_if returns the _else_if rule contexts.
	Get_else_if() IElse_ifContext

	// Set_else_if sets the _else_if rule contexts.
	Set_else_if(IElse_ifContext)

	// GetList returns the list rule context list.
	GetList() []IElse_ifContext

	// SetList sets the list rule context list.
	SetList([]IElse_ifContext)

	// GetLista returns the lista attribute.
	GetLista() *arrayList.List

	// SetLista sets the lista attribute.
	SetLista(*arrayList.List)

	// Getter signatures
	AllElse_if() []IElse_ifContext
	Else_if(i int) IElse_ifContext

	// IsList_elseifContext differentiates from other interfaces.
	IsList_elseifContext()
}

type List_elseifContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	lista    *arrayList.List
	_else_if IElse_ifContext
	list     []IElse_ifContext
}

func NewEmptyList_elseifContext() *List_elseifContext {
	var p = new(List_elseifContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_list_elseif
	return p
}

func InitEmptyList_elseifContext(p *List_elseifContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_list_elseif
}

func (*List_elseifContext) IsList_elseifContext() {}

func NewList_elseifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_elseifContext {
	var p = new(List_elseifContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_list_elseif

	return p
}

func (s *List_elseifContext) GetParser() antlr.Parser { return s.parser }

func (s *List_elseifContext) Get_else_if() IElse_ifContext { return s._else_if }

func (s *List_elseifContext) Set_else_if(v IElse_ifContext) { s._else_if = v }

func (s *List_elseifContext) GetList() []IElse_ifContext { return s.list }

func (s *List_elseifContext) SetList(v []IElse_ifContext) { s.list = v }

func (s *List_elseifContext) GetLista() *arrayList.List { return s.lista }

func (s *List_elseifContext) SetLista(v *arrayList.List) { s.lista = v }

func (s *List_elseifContext) AllElse_if() []IElse_ifContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElse_ifContext); ok {
			len++
		}
	}

	tst := make([]IElse_ifContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElse_ifContext); ok {
			tst[i] = t.(IElse_ifContext)
			i++
		}
	}

	return tst
}

func (s *List_elseifContext) Else_if(i int) IElse_ifContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElse_ifContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElse_ifContext)
}

func (s *List_elseifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_elseifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_elseifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterList_elseif(s)
	}
}

func (s *List_elseifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitList_elseif(s)
	}
}

func (p *swiftgrammar) List_elseif() (localctx IList_elseifContext) {
	localctx = NewList_elseifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, swiftgrammarRULE_list_elseif)
	localctx.(*List_elseifContext).lista = arrayList.New()
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(777)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		//goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(776)

				var _x = p.Else_if()

				localctx.(*List_elseifContext)._else_if = _x
			}
			localctx.(*List_elseifContext).list = append(localctx.(*List_elseifContext).list, localctx.(*List_elseifContext)._else_if)

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			///goto errorExit
		}

		p.SetState(779)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext())
		if p.HasError() {
		//	goto errorExit
		}
	}

	listInt := localctx.(*List_elseifContext).GetList()
	for _, e := range listInt {
		localctx.(*List_elseifContext).lista.Add(e.GetInstr())
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IList_elseif_expContext is an interface to support dynamic dispatch.
type IList_elseif_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_else_if_exp returns the _else_if_exp rule contexts.
	Get_else_if_exp() IElse_if_expContext

	// Set_else_if_exp sets the _else_if_exp rule contexts.
	Set_else_if_exp(IElse_if_expContext)

	// GetList returns the list rule context list.
	GetList() []IElse_if_expContext

	// SetList sets the list rule context list.
	SetList([]IElse_if_expContext)

	// GetLista returns the lista attribute.
	GetLista() *arrayList.List

	// SetLista sets the lista attribute.
	SetLista(*arrayList.List)

	// Getter signatures
	AllElse_if_exp() []IElse_if_expContext
	Else_if_exp(i int) IElse_if_expContext

	// IsList_elseif_expContext differentiates from other interfaces.
	IsList_elseif_expContext()
}

type List_elseif_expContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	lista        *arrayList.List
	_else_if_exp IElse_if_expContext
	list         []IElse_if_expContext
}

func NewEmptyList_elseif_expContext() *List_elseif_expContext {
	var p = new(List_elseif_expContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_list_elseif_exp
	return p
}

func InitEmptyList_elseif_expContext(p *List_elseif_expContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_list_elseif_exp
}

func (*List_elseif_expContext) IsList_elseif_expContext() {}

func NewList_elseif_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_elseif_expContext {
	var p = new(List_elseif_expContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_list_elseif_exp

	return p
}

func (s *List_elseif_expContext) GetParser() antlr.Parser { return s.parser }

func (s *List_elseif_expContext) Get_else_if_exp() IElse_if_expContext { return s._else_if_exp }

func (s *List_elseif_expContext) Set_else_if_exp(v IElse_if_expContext) { s._else_if_exp = v }

func (s *List_elseif_expContext) GetList() []IElse_if_expContext { return s.list }

func (s *List_elseif_expContext) SetList(v []IElse_if_expContext) { s.list = v }

func (s *List_elseif_expContext) GetLista() *arrayList.List { return s.lista }

func (s *List_elseif_expContext) SetLista(v *arrayList.List) { s.lista = v }

func (s *List_elseif_expContext) AllElse_if_exp() []IElse_if_expContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElse_if_expContext); ok {
			len++
		}
	}

	tst := make([]IElse_if_expContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElse_if_expContext); ok {
			tst[i] = t.(IElse_if_expContext)
			i++
		}
	}

	return tst
}

func (s *List_elseif_expContext) Else_if_exp(i int) IElse_if_expContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElse_if_expContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElse_if_expContext)
}

func (s *List_elseif_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_elseif_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_elseif_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterList_elseif_exp(s)
	}
}

func (s *List_elseif_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitList_elseif_exp(s)
	}
}

func (p *swiftgrammar) List_elseif_exp() (localctx IList_elseif_expContext) {
	localctx = NewList_elseif_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, swiftgrammarRULE_list_elseif_exp)
	localctx.(*List_elseif_expContext).lista = arrayList.New()
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
	//	goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(783)

				var _x = p.Else_if_exp()

				localctx.(*List_elseif_expContext)._else_if_exp = _x
			}
			localctx.(*List_elseif_expContext).list = append(localctx.(*List_elseif_expContext).list, localctx.(*List_elseif_expContext)._else_if_exp)

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		//	goto errorExit
		}

		p.SetState(786)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
		if p.HasError() {
		//	goto errorExit
		}
	}

	listInt := localctx.(*List_elseif_expContext).GetList()
	for _, e := range listInt {
		localctx.(*List_elseif_expContext).lista.Add(e.GetP())
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElse_ifContext is an interface to support dynamic dispatch.
type IElse_ifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ELSE returns the _ELSE token.
	Get_ELSE() antlr.Token

	// Set_ELSE sets the _ELSE token.
	Set_ELSE(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_bloque_inst returns the _bloque_inst rule contexts.
	Get_bloque_inst() IBloque_instContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_bloque_inst sets the _bloque_inst rule contexts.
	Set_bloque_inst(IBloque_instContext)

	// GetInstr returns the instr attribute.
	GetInstr() interfaces.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(interfaces.Instruction)

	// Getter signatures
	ELSE() antlr.TerminalNode
	IF() antlr.TerminalNode
	Expression() IExpressionContext
	Bloque_inst() IBloque_instContext

	// IsElse_ifContext differentiates from other interfaces.
	IsElse_ifContext()
}

type Else_ifContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	instr        interfaces.Instruction
	_ELSE        antlr.Token
	_expression  IExpressionContext
	_bloque_inst IBloque_instContext
}

func NewEmptyElse_ifContext() *Else_ifContext {
	var p = new(Else_ifContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_else_if
	return p
}

func InitEmptyElse_ifContext(p *Else_ifContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_else_if
}

func (*Else_ifContext) IsElse_ifContext() {}

func NewElse_ifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_ifContext {
	var p = new(Else_ifContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_else_if

	return p
}

func (s *Else_ifContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_ifContext) Get_ELSE() antlr.Token { return s._ELSE }

func (s *Else_ifContext) Set_ELSE(v antlr.Token) { s._ELSE = v }

func (s *Else_ifContext) Get_expression() IExpressionContext { return s._expression }

func (s *Else_ifContext) Get_bloque_inst() IBloque_instContext { return s._bloque_inst }

func (s *Else_ifContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Else_ifContext) Set_bloque_inst(v IBloque_instContext) { s._bloque_inst = v }

func (s *Else_ifContext) GetInstr() interfaces.Instruction { return s.instr }

func (s *Else_ifContext) SetInstr(v interfaces.Instruction) { s.instr = v }

func (s *Else_ifContext) ELSE() antlr.TerminalNode {
	return s.GetToken(swiftgrammarELSE, 0)
}

func (s *Else_ifContext) IF() antlr.TerminalNode {
	return s.GetToken(swiftgrammarIF, 0)
}

func (s *Else_ifContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Else_ifContext) Bloque_inst() IBloque_instContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBloque_instContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBloque_instContext)
}

func (s *Else_ifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_ifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_ifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterElse_if(s)
	}
}

func (s *Else_ifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitElse_if(s)
	}
}

func (p *swiftgrammar) Else_if() (localctx IElse_ifContext) {
	localctx = NewElse_ifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, swiftgrammarRULE_else_if)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(790)

		var _m = p.Match(swiftgrammarELSE)

		localctx.(*Else_ifContext)._ELSE = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(791)
		p.Match(swiftgrammarIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(792)

		var _x = p.expression(0)

		localctx.(*Else_ifContext)._expression = _x
	}
	{
		p.SetState(793)

		var _x = p.Bloque_inst()

		localctx.(*Else_ifContext)._bloque_inst = _x
	}
	localctx.(*Else_ifContext).instr = instruction.NewIf(localctx.(*Else_ifContext).Get_expression().GetP(), localctx.(*Else_ifContext).Get_bloque_inst().GetL(), nil, nil, (func() int {
		if localctx.(*Else_ifContext).Get_ELSE() == nil {
			return 0
		} else {
			return localctx.(*Else_ifContext).Get_ELSE().GetLine()
		}
	}()), localctx.(*Else_ifContext).Get_ELSE().GetColumn())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElse_if_expContext is an interface to support dynamic dispatch.
type IElse_if_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ELSE returns the _ELSE token.
	Get_ELSE() antlr.Token

	// Set_ELSE sets the _ELSE token.
	Set_ELSE(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_bloque_exp returns the _bloque_exp rule contexts.
	Get_bloque_exp() IBloque_expContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_bloque_exp sets the _bloque_exp rule contexts.
	Set_bloque_exp(IBloque_expContext)

	// GetP returns the p attribute.
	GetP() interfaces.Expresion

	// SetP sets the p attribute.
	SetP(interfaces.Expresion)

	// Getter signatures
	ELSE() antlr.TerminalNode
	IF() antlr.TerminalNode
	Expression() IExpressionContext
	Bloque_exp() IBloque_expContext

	// IsElse_if_expContext differentiates from other interfaces.
	IsElse_if_expContext()
}

type Else_if_expContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	p           interfaces.Expresion
	_ELSE       antlr.Token
	_expression IExpressionContext
	_bloque_exp IBloque_expContext
}

func NewEmptyElse_if_expContext() *Else_if_expContext {
	var p = new(Else_if_expContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_else_if_exp
	return p
}

func InitEmptyElse_if_expContext(p *Else_if_expContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_else_if_exp
}

func (*Else_if_expContext) IsElse_if_expContext() {}

func NewElse_if_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_if_expContext {
	var p = new(Else_if_expContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_else_if_exp

	return p
}

func (s *Else_if_expContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_if_expContext) Get_ELSE() antlr.Token { return s._ELSE }

func (s *Else_if_expContext) Set_ELSE(v antlr.Token) { s._ELSE = v }

func (s *Else_if_expContext) Get_expression() IExpressionContext { return s._expression }

func (s *Else_if_expContext) Get_bloque_exp() IBloque_expContext { return s._bloque_exp }

func (s *Else_if_expContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Else_if_expContext) Set_bloque_exp(v IBloque_expContext) { s._bloque_exp = v }

func (s *Else_if_expContext) GetP() interfaces.Expresion { return s.p }

func (s *Else_if_expContext) SetP(v interfaces.Expresion) { s.p = v }

func (s *Else_if_expContext) ELSE() antlr.TerminalNode {
	return s.GetToken(swiftgrammarELSE, 0)
}

func (s *Else_if_expContext) IF() antlr.TerminalNode {
	return s.GetToken(swiftgrammarIF, 0)
}

func (s *Else_if_expContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Else_if_expContext) Bloque_exp() IBloque_expContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBloque_expContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBloque_expContext)
}

func (s *Else_if_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_if_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_if_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterElse_if_exp(s)
	}
}

func (s *Else_if_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitElse_if_exp(s)
	}
}

func (p *swiftgrammar) Else_if_exp() (localctx IElse_if_expContext) {
	localctx = NewElse_if_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, swiftgrammarRULE_else_if_exp)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(796)

		var _m = p.Match(swiftgrammarELSE)

		localctx.(*Else_if_expContext)._ELSE = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(797)
		p.Match(swiftgrammarIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(798)

		var _x = p.expression(0)

		localctx.(*Else_if_expContext)._expression = _x
	}
	{
		p.SetState(799)

		var _x = p.Bloque_exp()

		localctx.(*Else_if_expContext)._bloque_exp = _x
	}
	localctx.(*Else_if_expContext).p = instruction.NewIfExpre(localctx.(*Else_if_expContext).Get_expression().GetP(), nil, nil, nil, (func() int {
		if localctx.(*Else_if_expContext).Get_ELSE() == nil {
			return 0
		} else {
			return localctx.(*Else_if_expContext).Get_ELSE().GetLine()
		}
	}()), localctx.(*Else_if_expContext).Get_ELSE().GetColumn(), true, localctx.(*Else_if_expContext).Get_bloque_exp().GetP(), nil, nil)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitch_sentContext is an interface to support dynamic dispatch.
type ISwitch_sentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_SWITCH returns the _SWITCH token.
	Get_SWITCH() antlr.Token

	// GetTh returns the th token.
	GetTh() antlr.Token

	// Set_SWITCH sets the _SWITCH token.
	Set_SWITCH(antlr.Token)

	// SetTh sets the th token.
	SetTh(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// GetBrazos returns the brazos rule contexts.
	GetBrazos() IMatch_brazosContext

	// Get_bloque_inst returns the _bloque_inst rule contexts.
	Get_bloque_inst() IBloque_instContext

	// Get_instruccion_dentro returns the _instruccion_dentro rule contexts.
	Get_instruccion_dentro() IInstruccion_dentroContext

	// GetExp returns the exp rule contexts.
	GetExp() IExpressionContext

	// GetBrazosexp returns the brazosexp rule contexts.
	GetBrazosexp() IMatch_brazos_expContext

	// GetExp_ returns the exp_ rule contexts.
	GetExp_() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// SetBrazos sets the brazos rule contexts.
	SetBrazos(IMatch_brazosContext)

	// Set_bloque_inst sets the _bloque_inst rule contexts.
	Set_bloque_inst(IBloque_instContext)

	// Set_instruccion_dentro sets the _instruccion_dentro rule contexts.
	Set_instruccion_dentro(IInstruccion_dentroContext)

	// SetExp sets the exp rule contexts.
	SetExp(IExpressionContext)

	// SetBrazosexp sets the brazosexp rule contexts.
	SetBrazosexp(IMatch_brazos_expContext)

	// SetExp_ sets the exp_ rule contexts.
	SetExp_(IExpressionContext)

	// GetInstr returns the instr attribute.
	GetInstr() interfaces.Instruction

	// GetP returns the p attribute.
	GetP() interfaces.Expresion

	// SetInstr sets the instr attribute.
	SetInstr(interfaces.Instruction)

	// SetP sets the p attribute.
	SetP(interfaces.Expresion)

	// Getter signatures
	SWITCH() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	LLAVEIZQ() antlr.TerminalNode
	LLAVEDER() antlr.TerminalNode
	Match_brazos() IMatch_brazosContext
	DEFAULT() antlr.TerminalNode
	Bloque_inst() IBloque_instContext
	DPUNTO2() antlr.TerminalNode
	Instruccion_dentro() IInstruccion_dentroContext
	Match_brazos_exp() IMatch_brazos_expContext

	// IsSwitch_sentContext differentiates from other interfaces.
	IsSwitch_sentContext()
}

type Switch_sentContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	instr               interfaces.Instruction
	p                   interfaces.Expresion
	_SWITCH             antlr.Token
	_expression         IExpressionContext
	brazos              IMatch_brazosContext
	th                  antlr.Token
	_bloque_inst        IBloque_instContext
	_instruccion_dentro IInstruccion_dentroContext
	exp                 IExpressionContext
	brazosexp           IMatch_brazos_expContext
	exp_                IExpressionContext
}

func NewEmptySwitch_sentContext() *Switch_sentContext {
	var p = new(Switch_sentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_switch_sent
	return p
}

func InitEmptySwitch_sentContext(p *Switch_sentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_switch_sent
}

func (*Switch_sentContext) IsSwitch_sentContext() {}

func NewSwitch_sentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Switch_sentContext {
	var p = new(Switch_sentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_switch_sent

	return p
}

func (s *Switch_sentContext) GetParser() antlr.Parser { return s.parser }

func (s *Switch_sentContext) Get_SWITCH() antlr.Token { return s._SWITCH }

func (s *Switch_sentContext) GetTh() antlr.Token { return s.th }

func (s *Switch_sentContext) Set_SWITCH(v antlr.Token) { s._SWITCH = v }

func (s *Switch_sentContext) SetTh(v antlr.Token) { s.th = v }

func (s *Switch_sentContext) Get_expression() IExpressionContext { return s._expression }

func (s *Switch_sentContext) GetBrazos() IMatch_brazosContext { return s.brazos }

func (s *Switch_sentContext) Get_bloque_inst() IBloque_instContext { return s._bloque_inst }

func (s *Switch_sentContext) Get_instruccion_dentro() IInstruccion_dentroContext {
	return s._instruccion_dentro
}

func (s *Switch_sentContext) GetExp() IExpressionContext { return s.exp }

func (s *Switch_sentContext) GetBrazosexp() IMatch_brazos_expContext { return s.brazosexp }

func (s *Switch_sentContext) GetExp_() IExpressionContext { return s.exp_ }

func (s *Switch_sentContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Switch_sentContext) SetBrazos(v IMatch_brazosContext) { s.brazos = v }

func (s *Switch_sentContext) Set_bloque_inst(v IBloque_instContext) { s._bloque_inst = v }

func (s *Switch_sentContext) Set_instruccion_dentro(v IInstruccion_dentroContext) {
	s._instruccion_dentro = v
}

func (s *Switch_sentContext) SetExp(v IExpressionContext) { s.exp = v }

func (s *Switch_sentContext) SetBrazosexp(v IMatch_brazos_expContext) { s.brazosexp = v }

func (s *Switch_sentContext) SetExp_(v IExpressionContext) { s.exp_ = v }

func (s *Switch_sentContext) GetInstr() interfaces.Instruction { return s.instr }

func (s *Switch_sentContext) GetP() interfaces.Expresion { return s.p }

func (s *Switch_sentContext) SetInstr(v interfaces.Instruction) { s.instr = v }

func (s *Switch_sentContext) SetP(v interfaces.Expresion) { s.p = v }

func (s *Switch_sentContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(swiftgrammarSWITCH, 0)
}

func (s *Switch_sentContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Switch_sentContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Switch_sentContext) LLAVEIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarLLAVEIZQ, 0)
}

func (s *Switch_sentContext) LLAVEDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarLLAVEDER, 0)
}

func (s *Switch_sentContext) Match_brazos() IMatch_brazosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatch_brazosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatch_brazosContext)
}

func (s *Switch_sentContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(swiftgrammarDEFAULT, 0)
}

func (s *Switch_sentContext) Bloque_inst() IBloque_instContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBloque_instContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBloque_instContext)
}

func (s *Switch_sentContext) DPUNTO2() antlr.TerminalNode {
	return s.GetToken(swiftgrammarDPUNTO2, 0)
}

func (s *Switch_sentContext) Instruccion_dentro() IInstruccion_dentroContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstruccion_dentroContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstruccion_dentroContext)
}

func (s *Switch_sentContext) Match_brazos_exp() IMatch_brazos_expContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatch_brazos_expContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatch_brazos_expContext)
}

func (s *Switch_sentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Switch_sentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Switch_sentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterSwitch_sent(s)
	}
}

func (s *Switch_sentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitSwitch_sent(s)
	}
}

func (p *swiftgrammar) Switch_sent() (localctx ISwitch_sentContext) {
	localctx = NewSwitch_sentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, swiftgrammarRULE_switch_sent)
	p.SetState(846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(802)

			var _m = p.Match(swiftgrammarSWITCH)

			localctx.(*Switch_sentContext)._SWITCH = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(803)

			var _x = p.expression(0)

			localctx.(*Switch_sentContext)._expression = _x
		}
		{
			p.SetState(804)
			p.Match(swiftgrammarLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(805)

			var _x = p.match_brazos(0)

			localctx.(*Switch_sentContext).brazos = _x
		}
		{
			p.SetState(806)
			p.Match(swiftgrammarLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*Switch_sentContext).instr = instructionExpre.NewMatch(localctx.(*Switch_sentContext).Get_expression().GetP(), localctx.(*Switch_sentContext).GetBrazos().GetL_brazos(), nil, nil, (func() int {
			if localctx.(*Switch_sentContext).Get_SWITCH() == nil {
				return 0
			} else {
				return localctx.(*Switch_sentContext).Get_SWITCH().GetLine()
			}
		}()), localctx.(*Switch_sentContext).Get_SWITCH().GetColumn(), nil, false)

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(809)

			var _m = p.Match(swiftgrammarSWITCH)

			localctx.(*Switch_sentContext)._SWITCH = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(810)

			var _x = p.expression(0)

			localctx.(*Switch_sentContext)._expression = _x
		}
		{
			p.SetState(811)
			p.Match(swiftgrammarLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(812)

			var _x = p.match_brazos(0)

			localctx.(*Switch_sentContext).brazos = _x
		}
		{
			p.SetState(813)
			p.Match(swiftgrammarDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(814)

			var _m = p.Match(swiftgrammarDPUNTO2)

			localctx.(*Switch_sentContext).th = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(815)

			var _x = p.Bloque_inst()

			localctx.(*Switch_sentContext)._bloque_inst = _x
		}
		{
			p.SetState(816)
			p.Match(swiftgrammarLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*Switch_sentContext).instr = instructionExpre.NewMatch(localctx.(*Switch_sentContext).Get_expression().GetP(), localctx.(*Switch_sentContext).GetBrazos().GetL_brazos(), localctx.(*Switch_sentContext).Get_bloque_inst().GetL(), nil, (func() int {
			if localctx.(*Switch_sentContext).Get_SWITCH() == nil {
				return 0
			} else {
				return localctx.(*Switch_sentContext).Get_SWITCH().GetLine()
			}
		}()), localctx.(*Switch_sentContext).Get_SWITCH().GetColumn(), nil, false)

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(819)

			var _m = p.Match(swiftgrammarSWITCH)

			localctx.(*Switch_sentContext)._SWITCH = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(820)

			var _x = p.expression(0)

			localctx.(*Switch_sentContext)._expression = _x
		}
		{
			p.SetState(821)
			p.Match(swiftgrammarLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(822)

			var _x = p.match_brazos(0)

			localctx.(*Switch_sentContext).brazos = _x
		}
		{
			p.SetState(823)
			p.Match(swiftgrammarDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(824)

			var _m = p.Match(swiftgrammarDPUNTO2)

			localctx.(*Switch_sentContext).th = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(825)

			var _x = p.Instruccion_dentro()

			localctx.(*Switch_sentContext)._instruccion_dentro = _x
		}
		{
			p.SetState(826)
			p.Match(swiftgrammarLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*Switch_sentContext).instr = instructionExpre.NewMatch(localctx.(*Switch_sentContext).Get_expression().GetP(), localctx.(*Switch_sentContext).GetBrazos().GetL_brazos(), nil, localctx.(*Switch_sentContext).Get_instruccion_dentro().GetInstr(), (func() int {
			if localctx.(*Switch_sentContext).Get_SWITCH() == nil {
				return 0
			} else {
				return localctx.(*Switch_sentContext).Get_SWITCH().GetLine()
			}
		}()), localctx.(*Switch_sentContext).Get_SWITCH().GetColumn(), nil, false)

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(829)

			var _m = p.Match(swiftgrammarSWITCH)

			localctx.(*Switch_sentContext)._SWITCH = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(830)

			var _x = p.expression(0)

			localctx.(*Switch_sentContext).exp = _x
		}
		{
			p.SetState(831)
			p.Match(swiftgrammarLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(832)

			var _x = p.match_brazos_exp(0)

			localctx.(*Switch_sentContext).brazosexp = _x
		}
		{
			p.SetState(833)
			p.Match(swiftgrammarLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*Switch_sentContext).p = instructionExpre.NewMatch(localctx.(*Switch_sentContext).GetExp().GetP(), localctx.(*Switch_sentContext).GetBrazosexp().GetL_brazos(), nil, nil, (func() int {
			if localctx.(*Switch_sentContext).Get_SWITCH() == nil {
				return 0
			} else {
				return localctx.(*Switch_sentContext).Get_SWITCH().GetLine()
			}
		}()), localctx.(*Switch_sentContext).Get_SWITCH().GetColumn(), nil, true)

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(836)

			var _m = p.Match(swiftgrammarSWITCH)

			localctx.(*Switch_sentContext)._SWITCH = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(837)

			var _x = p.expression(0)

			localctx.(*Switch_sentContext).exp = _x
		}
		{
			p.SetState(838)
			p.Match(swiftgrammarLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(839)

			var _x = p.match_brazos_exp(0)

			localctx.(*Switch_sentContext).brazosexp = _x
		}
		{
			p.SetState(840)
			p.Match(swiftgrammarDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(841)

			var _m = p.Match(swiftgrammarDPUNTO2)

			localctx.(*Switch_sentContext).th = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(842)

			var _x = p.expression(0)

			localctx.(*Switch_sentContext).exp_ = _x
		}
		{
			p.SetState(843)
			p.Match(swiftgrammarLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*Switch_sentContext).p = instructionExpre.NewMatch(localctx.(*Switch_sentContext).GetExp().GetP(), localctx.(*Switch_sentContext).GetBrazosexp().GetL_brazos(), nil, nil, (func() int {
			if localctx.(*Switch_sentContext).Get_SWITCH() == nil {
				return 0
			} else {
				return localctx.(*Switch_sentContext).Get_SWITCH().GetLine()
			}
		}()), localctx.(*Switch_sentContext).Get_SWITCH().GetColumn(), localctx.(*Switch_sentContext).GetExp_().GetP(), true)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatch_brazosContext is an interface to support dynamic dispatch.
type IMatch_brazosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetListb returns the listb rule contexts.
	GetListb() IMatch_brazosContext

	// Get_matchbrazo returns the _matchbrazo rule contexts.
	Get_matchbrazo() IMatchbrazoContext

	// SetListb sets the listb rule contexts.
	SetListb(IMatch_brazosContext)

	// Set_matchbrazo sets the _matchbrazo rule contexts.
	Set_matchbrazo(IMatchbrazoContext)

	// GetL_brazos returns the l_brazos attribute.
	GetL_brazos() *arrayList.List

	// SetL_brazos sets the l_brazos attribute.
	SetL_brazos(*arrayList.List)

	// Getter signatures
	Matchbrazo() IMatchbrazoContext
	Match_brazos() IMatch_brazosContext

	// IsMatch_brazosContext differentiates from other interfaces.
	IsMatch_brazosContext()
}

type Match_brazosContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	l_brazos    *arrayList.List
	listb       IMatch_brazosContext
	_matchbrazo IMatchbrazoContext
}

func NewEmptyMatch_brazosContext() *Match_brazosContext {
	var p = new(Match_brazosContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_match_brazos
	return p
}

func InitEmptyMatch_brazosContext(p *Match_brazosContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_match_brazos
}

func (*Match_brazosContext) IsMatch_brazosContext() {}

func NewMatch_brazosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Match_brazosContext {
	var p = new(Match_brazosContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_match_brazos

	return p
}

func (s *Match_brazosContext) GetParser() antlr.Parser { return s.parser }

func (s *Match_brazosContext) GetListb() IMatch_brazosContext { return s.listb }

func (s *Match_brazosContext) Get_matchbrazo() IMatchbrazoContext { return s._matchbrazo }

func (s *Match_brazosContext) SetListb(v IMatch_brazosContext) { s.listb = v }

func (s *Match_brazosContext) Set_matchbrazo(v IMatchbrazoContext) { s._matchbrazo = v }

func (s *Match_brazosContext) GetL_brazos() *arrayList.List { return s.l_brazos }

func (s *Match_brazosContext) SetL_brazos(v *arrayList.List) { s.l_brazos = v }

func (s *Match_brazosContext) Matchbrazo() IMatchbrazoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchbrazoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchbrazoContext)
}

func (s *Match_brazosContext) Match_brazos() IMatch_brazosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatch_brazosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatch_brazosContext)
}

func (s *Match_brazosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Match_brazosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Match_brazosContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterMatch_brazos(s)
	}
}

func (s *Match_brazosContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitMatch_brazos(s)
	}
}

func (p *swiftgrammar) Match_brazos() (localctx IMatch_brazosContext) {
	return p.match_brazos(0)
}

func (p *swiftgrammar) match_brazos(_p int) (localctx IMatch_brazosContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewMatch_brazosContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMatch_brazosContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 84
	p.EnterRecursionRule(localctx, 84, swiftgrammarRULE_match_brazos, _p)

	localctx.(*Match_brazosContext).l_brazos = arrayList.New()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(849)

		var _x = p.Matchbrazo()

		localctx.(*Match_brazosContext)._matchbrazo = _x
	}
	localctx.(*Match_brazosContext).l_brazos.Add(localctx.(*Match_brazosContext).Get_matchbrazo().GetBrazo())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(858)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewMatch_brazosContext(p, _parentctx, _parentState)
			localctx.(*Match_brazosContext).listb = _prevctx
			p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_match_brazos)
			p.SetState(852)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(853)

				var _x = p.Matchbrazo()

				localctx.(*Match_brazosContext)._matchbrazo = _x
			}

			localctx.(*Match_brazosContext).GetListb().GetL_brazos().Add(localctx.(*Match_brazosContext).Get_matchbrazo().GetBrazo())
			localctx.(*Match_brazosContext).l_brazos = localctx.(*Match_brazosContext).GetListb().GetL_brazos()

		}
		p.SetState(860)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatch_brazos_expContext is an interface to support dynamic dispatch.
type IMatch_brazos_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetListb returns the listb rule contexts.
	GetListb() IMatch_brazos_expContext

	// Get_matchbrazo_exp returns the _matchbrazo_exp rule contexts.
	Get_matchbrazo_exp() IMatchbrazo_expContext

	// SetListb sets the listb rule contexts.
	SetListb(IMatch_brazos_expContext)

	// Set_matchbrazo_exp sets the _matchbrazo_exp rule contexts.
	Set_matchbrazo_exp(IMatchbrazo_expContext)

	// GetL_brazos returns the l_brazos attribute.
	GetL_brazos() *arrayList.List

	// SetL_brazos sets the l_brazos attribute.
	SetL_brazos(*arrayList.List)

	// Getter signatures
	Matchbrazo_exp() IMatchbrazo_expContext
	Match_brazos_exp() IMatch_brazos_expContext

	// IsMatch_brazos_expContext differentiates from other interfaces.
	IsMatch_brazos_expContext()
}

type Match_brazos_expContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	l_brazos        *arrayList.List
	listb           IMatch_brazos_expContext
	_matchbrazo_exp IMatchbrazo_expContext
}

func NewEmptyMatch_brazos_expContext() *Match_brazos_expContext {
	var p = new(Match_brazos_expContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_match_brazos_exp
	return p
}

func InitEmptyMatch_brazos_expContext(p *Match_brazos_expContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_match_brazos_exp
}

func (*Match_brazos_expContext) IsMatch_brazos_expContext() {}

func NewMatch_brazos_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Match_brazos_expContext {
	var p = new(Match_brazos_expContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_match_brazos_exp

	return p
}

func (s *Match_brazos_expContext) GetParser() antlr.Parser { return s.parser }

func (s *Match_brazos_expContext) GetListb() IMatch_brazos_expContext { return s.listb }

func (s *Match_brazos_expContext) Get_matchbrazo_exp() IMatchbrazo_expContext {
	return s._matchbrazo_exp
}

func (s *Match_brazos_expContext) SetListb(v IMatch_brazos_expContext) { s.listb = v }

func (s *Match_brazos_expContext) Set_matchbrazo_exp(v IMatchbrazo_expContext) { s._matchbrazo_exp = v }

func (s *Match_brazos_expContext) GetL_brazos() *arrayList.List { return s.l_brazos }

func (s *Match_brazos_expContext) SetL_brazos(v *arrayList.List) { s.l_brazos = v }

func (s *Match_brazos_expContext) Matchbrazo_exp() IMatchbrazo_expContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchbrazo_expContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchbrazo_expContext)
}

func (s *Match_brazos_expContext) Match_brazos_exp() IMatch_brazos_expContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatch_brazos_expContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatch_brazos_expContext)
}

func (s *Match_brazos_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Match_brazos_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Match_brazos_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterMatch_brazos_exp(s)
	}
}

func (s *Match_brazos_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitMatch_brazos_exp(s)
	}
}

func (p *swiftgrammar) Match_brazos_exp() (localctx IMatch_brazos_expContext) {
	return p.match_brazos_exp(0)
}

func (p *swiftgrammar) match_brazos_exp(_p int) (localctx IMatch_brazos_expContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewMatch_brazos_expContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMatch_brazos_expContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 86
	p.EnterRecursionRule(localctx, 86, swiftgrammarRULE_match_brazos_exp, _p)

	localctx.(*Match_brazos_expContext).l_brazos = arrayList.New()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(862)

		var _x = p.Matchbrazo_exp()

		localctx.(*Match_brazos_expContext)._matchbrazo_exp = _x
	}
	localctx.(*Match_brazos_expContext).l_brazos.Add(localctx.(*Match_brazos_expContext).Get_matchbrazo_exp().GetBrazo())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewMatch_brazos_expContext(p, _parentctx, _parentState)
			localctx.(*Match_brazos_expContext).listb = _prevctx
			p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_match_brazos_exp)
			p.SetState(865)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(866)

				var _x = p.Matchbrazo_exp()

				localctx.(*Match_brazos_expContext)._matchbrazo_exp = _x
			}

			localctx.(*Match_brazos_expContext).GetListb().GetL_brazos().Add(localctx.(*Match_brazos_expContext).Get_matchbrazo_exp().GetBrazo())
			localctx.(*Match_brazos_expContext).l_brazos = localctx.(*Match_brazos_expContext).GetListb().GetL_brazos()

		}
		p.SetState(873)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchbrazoContext is an interface to support dynamic dispatch.
type IMatchbrazoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTh returns the th token.
	GetTh() antlr.Token

	// SetTh sets the th token.
	SetTh(antlr.Token)

	// Get_listaOpciones returns the _listaOpciones rule contexts.
	Get_listaOpciones() IListaOpcionesContext

	// Get_bloque_inst returns the _bloque_inst rule contexts.
	Get_bloque_inst() IBloque_instContext

	// Get_instruccion_dentro returns the _instruccion_dentro rule contexts.
	Get_instruccion_dentro() IInstruccion_dentroContext

	// Set_listaOpciones sets the _listaOpciones rule contexts.
	Set_listaOpciones(IListaOpcionesContext)

	// Set_bloque_inst sets the _bloque_inst rule contexts.
	Set_bloque_inst(IBloque_instContext)

	// Set_instruccion_dentro sets the _instruccion_dentro rule contexts.
	Set_instruccion_dentro(IInstruccion_dentroContext)

	// GetBrazo returns the brazo attribute.
	GetBrazo() instructionExpre.BrazoMatch

	// SetBrazo sets the brazo attribute.
	SetBrazo(instructionExpre.BrazoMatch)

	// Getter signatures
	CASE() antlr.TerminalNode
	ListaOpciones() IListaOpcionesContext
	Bloque_inst() IBloque_instContext
	DPUNTO2() antlr.TerminalNode
	Instruccion_dentro() IInstruccion_dentroContext

	// IsMatchbrazoContext differentiates from other interfaces.
	IsMatchbrazoContext()
}

type MatchbrazoContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	brazo               instructionExpre.BrazoMatch
	_listaOpciones      IListaOpcionesContext
	th                  antlr.Token
	_bloque_inst        IBloque_instContext
	_instruccion_dentro IInstruccion_dentroContext
}

func NewEmptyMatchbrazoContext() *MatchbrazoContext {
	var p = new(MatchbrazoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_matchbrazo
	return p
}

func InitEmptyMatchbrazoContext(p *MatchbrazoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_matchbrazo
}

func (*MatchbrazoContext) IsMatchbrazoContext() {}

func NewMatchbrazoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchbrazoContext {
	var p = new(MatchbrazoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_matchbrazo

	return p
}

func (s *MatchbrazoContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchbrazoContext) GetTh() antlr.Token { return s.th }

func (s *MatchbrazoContext) SetTh(v antlr.Token) { s.th = v }

func (s *MatchbrazoContext) Get_listaOpciones() IListaOpcionesContext { return s._listaOpciones }

func (s *MatchbrazoContext) Get_bloque_inst() IBloque_instContext { return s._bloque_inst }

func (s *MatchbrazoContext) Get_instruccion_dentro() IInstruccion_dentroContext {
	return s._instruccion_dentro
}

func (s *MatchbrazoContext) Set_listaOpciones(v IListaOpcionesContext) { s._listaOpciones = v }

func (s *MatchbrazoContext) Set_bloque_inst(v IBloque_instContext) { s._bloque_inst = v }

func (s *MatchbrazoContext) Set_instruccion_dentro(v IInstruccion_dentroContext) {
	s._instruccion_dentro = v
}

func (s *MatchbrazoContext) GetBrazo() instructionExpre.BrazoMatch { return s.brazo }

func (s *MatchbrazoContext) SetBrazo(v instructionExpre.BrazoMatch) { s.brazo = v }

func (s *MatchbrazoContext) CASE() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCASE, 0)
}

func (s *MatchbrazoContext) ListaOpciones() IListaOpcionesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListaOpcionesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListaOpcionesContext)
}

func (s *MatchbrazoContext) Bloque_inst() IBloque_instContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBloque_instContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBloque_instContext)
}

func (s *MatchbrazoContext) DPUNTO2() antlr.TerminalNode {
	return s.GetToken(swiftgrammarDPUNTO2, 0)
}

func (s *MatchbrazoContext) Instruccion_dentro() IInstruccion_dentroContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstruccion_dentroContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstruccion_dentroContext)
}

func (s *MatchbrazoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchbrazoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchbrazoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterMatchbrazo(s)
	}
}

func (s *MatchbrazoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitMatchbrazo(s)
	}
}

func (p *swiftgrammar) Matchbrazo() (localctx IMatchbrazoContext) {
	localctx = NewMatchbrazoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, swiftgrammarRULE_matchbrazo)
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(874)
			p.Match(swiftgrammarCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(875)

			var _x = p.listaOpciones(0)

			localctx.(*MatchbrazoContext)._listaOpciones = _x
		}
		{
			p.SetState(876)

			var _m = p.Match(swiftgrammarDPUNTO2)

			localctx.(*MatchbrazoContext).th = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(877)

			var _x = p.Bloque_inst()

			localctx.(*MatchbrazoContext)._bloque_inst = _x
		}
		localctx.(*MatchbrazoContext).brazo = instructionExpre.NewBrazoMatch(localctx.(*MatchbrazoContext).Get_listaOpciones().GetLisop(), localctx.(*MatchbrazoContext).Get_bloque_inst().GetL(), nil, (func() int {
			if localctx.(*MatchbrazoContext).GetTh() == nil {
				return 0
			} else {
				return localctx.(*MatchbrazoContext).GetTh().GetLine()
			}
		}()), localctx.(*MatchbrazoContext).GetTh().GetColumn(), nil)

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(880)
			p.Match(swiftgrammarCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(881)

			var _x = p.listaOpciones(0)

			localctx.(*MatchbrazoContext)._listaOpciones = _x
		}
		{
			p.SetState(882)

			var _m = p.Match(swiftgrammarDPUNTO2)

			localctx.(*MatchbrazoContext).th = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(883)

			var _x = p.Instruccion_dentro()

			localctx.(*MatchbrazoContext)._instruccion_dentro = _x
		}
		localctx.(*MatchbrazoContext).brazo = instructionExpre.NewBrazoMatch(localctx.(*MatchbrazoContext).Get_listaOpciones().GetLisop(), nil, localctx.(*MatchbrazoContext).Get_instruccion_dentro().GetInstr(), (func() int {
			if localctx.(*MatchbrazoContext).GetTh() == nil {
				return 0
			} else {
				return localctx.(*MatchbrazoContext).GetTh().GetLine()
			}
		}()), localctx.(*MatchbrazoContext).GetTh().GetColumn(), nil)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchbrazo_expContext is an interface to support dynamic dispatch.
type IMatchbrazo_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTh returns the th token.
	GetTh() antlr.Token

	// SetTh sets the th token.
	SetTh(antlr.Token)

	// Get_listaOpciones returns the _listaOpciones rule contexts.
	Get_listaOpciones() IListaOpcionesContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_listaOpciones sets the _listaOpciones rule contexts.
	Set_listaOpciones(IListaOpcionesContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetBrazo returns the brazo attribute.
	GetBrazo() instructionExpre.BrazoMatch

	// SetBrazo sets the brazo attribute.
	SetBrazo(instructionExpre.BrazoMatch)

	// Getter signatures
	ListaOpciones() IListaOpcionesContext
	Expression() IExpressionContext
	DPUNTO2() antlr.TerminalNode

	// IsMatchbrazo_expContext differentiates from other interfaces.
	IsMatchbrazo_expContext()
}

type Matchbrazo_expContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	brazo          instructionExpre.BrazoMatch
	_listaOpciones IListaOpcionesContext
	th             antlr.Token
	_expression    IExpressionContext
}

func NewEmptyMatchbrazo_expContext() *Matchbrazo_expContext {
	var p = new(Matchbrazo_expContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_matchbrazo_exp
	return p
}

func InitEmptyMatchbrazo_expContext(p *Matchbrazo_expContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_matchbrazo_exp
}

func (*Matchbrazo_expContext) IsMatchbrazo_expContext() {}

func NewMatchbrazo_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Matchbrazo_expContext {
	var p = new(Matchbrazo_expContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_matchbrazo_exp

	return p
}

func (s *Matchbrazo_expContext) GetParser() antlr.Parser { return s.parser }

func (s *Matchbrazo_expContext) GetTh() antlr.Token { return s.th }

func (s *Matchbrazo_expContext) SetTh(v antlr.Token) { s.th = v }

func (s *Matchbrazo_expContext) Get_listaOpciones() IListaOpcionesContext { return s._listaOpciones }

func (s *Matchbrazo_expContext) Get_expression() IExpressionContext { return s._expression }

func (s *Matchbrazo_expContext) Set_listaOpciones(v IListaOpcionesContext) { s._listaOpciones = v }

func (s *Matchbrazo_expContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Matchbrazo_expContext) GetBrazo() instructionExpre.BrazoMatch { return s.brazo }

func (s *Matchbrazo_expContext) SetBrazo(v instructionExpre.BrazoMatch) { s.brazo = v }

func (s *Matchbrazo_expContext) ListaOpciones() IListaOpcionesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListaOpcionesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListaOpcionesContext)
}

func (s *Matchbrazo_expContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Matchbrazo_expContext) DPUNTO2() antlr.TerminalNode {
	return s.GetToken(swiftgrammarDPUNTO2, 0)
}

func (s *Matchbrazo_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Matchbrazo_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Matchbrazo_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterMatchbrazo_exp(s)
	}
}

func (s *Matchbrazo_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitMatchbrazo_exp(s)
	}
}

func (p *swiftgrammar) Matchbrazo_exp() (localctx IMatchbrazo_expContext) {
	localctx = NewMatchbrazo_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, swiftgrammarRULE_matchbrazo_exp)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(888)

		var _x = p.listaOpciones(0)

		localctx.(*Matchbrazo_expContext)._listaOpciones = _x
	}
	{
		p.SetState(889)

		var _m = p.Match(swiftgrammarDPUNTO2)

		localctx.(*Matchbrazo_expContext).th = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(890)

		var _x = p.expression(0)

		localctx.(*Matchbrazo_expContext)._expression = _x
	}
	localctx.(*Matchbrazo_expContext).brazo = instructionExpre.NewBrazoMatch(localctx.(*Matchbrazo_expContext).Get_listaOpciones().GetLisop(), nil, nil, (func() int {
		if localctx.(*Matchbrazo_expContext).GetTh() == nil {
			return 0
		} else {
			return localctx.(*Matchbrazo_expContext).GetTh().GetLine()
		}
	}()), localctx.(*Matchbrazo_expContext).GetTh().GetColumn(), localctx.(*Matchbrazo_expContext).Get_expression().GetP())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListaOpcionesContext is an interface to support dynamic dispatch.
type IListaOpcionesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetList returns the list rule contexts.
	GetList() IListaOpcionesContext

	// Get_primitivo returns the _primitivo rule contexts.
	Get_primitivo() IPrimitivoContext

	// SetList sets the list rule contexts.
	SetList(IListaOpcionesContext)

	// Set_primitivo sets the _primitivo rule contexts.
	Set_primitivo(IPrimitivoContext)

	// GetLisop returns the lisop attribute.
	GetLisop() *arrayList.List

	// SetLisop sets the lisop attribute.
	SetLisop(*arrayList.List)

	// Getter signatures
	Primitivo() IPrimitivoContext
	COMA() antlr.TerminalNode
	ListaOpciones() IListaOpcionesContext

	// IsListaOpcionesContext differentiates from other interfaces.
	IsListaOpcionesContext()
}

type ListaOpcionesContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	lisop      *arrayList.List
	list       IListaOpcionesContext
	_primitivo IPrimitivoContext
}

func NewEmptyListaOpcionesContext() *ListaOpcionesContext {
	var p = new(ListaOpcionesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_listaOpciones
	return p
}

func InitEmptyListaOpcionesContext(p *ListaOpcionesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_listaOpciones
}

func (*ListaOpcionesContext) IsListaOpcionesContext() {}

func NewListaOpcionesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListaOpcionesContext {
	var p = new(ListaOpcionesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_listaOpciones

	return p
}

func (s *ListaOpcionesContext) GetParser() antlr.Parser { return s.parser }

func (s *ListaOpcionesContext) GetList() IListaOpcionesContext { return s.list }

func (s *ListaOpcionesContext) Get_primitivo() IPrimitivoContext { return s._primitivo }

func (s *ListaOpcionesContext) SetList(v IListaOpcionesContext) { s.list = v }

func (s *ListaOpcionesContext) Set_primitivo(v IPrimitivoContext) { s._primitivo = v }

func (s *ListaOpcionesContext) GetLisop() *arrayList.List { return s.lisop }

func (s *ListaOpcionesContext) SetLisop(v *arrayList.List) { s.lisop = v }

func (s *ListaOpcionesContext) Primitivo() IPrimitivoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitivoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitivoContext)
}

func (s *ListaOpcionesContext) COMA() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCOMA, 0)
}

func (s *ListaOpcionesContext) ListaOpciones() IListaOpcionesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListaOpcionesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListaOpcionesContext)
}

func (s *ListaOpcionesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListaOpcionesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListaOpcionesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterListaOpciones(s)
	}
}

func (s *ListaOpcionesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitListaOpciones(s)
	}
}

func (p *swiftgrammar) ListaOpciones() (localctx IListaOpcionesContext) {
	return p.listaOpciones(0)
}

func (p *swiftgrammar) listaOpciones(_p int) (localctx IListaOpcionesContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewListaOpcionesContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListaOpcionesContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 92
	p.EnterRecursionRule(localctx, 92, swiftgrammarRULE_listaOpciones, _p)

	localctx.(*ListaOpcionesContext).lisop = arrayList.New()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(894)

		var _x = p.Primitivo()

		localctx.(*ListaOpcionesContext)._primitivo = _x
	}

	localctx.(*ListaOpcionesContext).lisop.Add(localctx.(*ListaOpcionesContext).Get_primitivo().GetP())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(904)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListaOpcionesContext(p, _parentctx, _parentState)
			localctx.(*ListaOpcionesContext).list = _prevctx
			p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_listaOpciones)
			p.SetState(897)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(898)
				p.Match(swiftgrammarCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(899)

				var _x = p.Primitivo()

				localctx.(*ListaOpcionesContext)._primitivo = _x
			}

			localctx.(*ListaOpcionesContext).GetList().GetLisop().Add(localctx.(*ListaOpcionesContext).Get_primitivo().GetP())
			localctx.(*ListaOpcionesContext).lisop = localctx.(*ListaOpcionesContext).GetList().GetLisop()

		}
		p.SetState(906)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBloque_instContext is an interface to support dynamic dispatch.
type IBloque_instContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_instrucciones returns the _instrucciones rule contexts.
	Get_instrucciones() IInstruccionesContext

	// Set_instrucciones sets the _instrucciones rule contexts.
	Set_instrucciones(IInstruccionesContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// Getter signatures
	LLAVEIZQ() antlr.TerminalNode
	Instrucciones() IInstruccionesContext
	LLAVEDER() antlr.TerminalNode

	// IsBloque_instContext differentiates from other interfaces.
	IsBloque_instContext()
}

type Bloque_instContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	l              *arrayList.List
	_instrucciones IInstruccionesContext
}

func NewEmptyBloque_instContext() *Bloque_instContext {
	var p = new(Bloque_instContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_bloque_inst
	return p
}

func InitEmptyBloque_instContext(p *Bloque_instContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_bloque_inst
}

func (*Bloque_instContext) IsBloque_instContext() {}

func NewBloque_instContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bloque_instContext {
	var p = new(Bloque_instContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_bloque_inst

	return p
}

func (s *Bloque_instContext) GetParser() antlr.Parser { return s.parser }

func (s *Bloque_instContext) Get_instrucciones() IInstruccionesContext { return s._instrucciones }

func (s *Bloque_instContext) Set_instrucciones(v IInstruccionesContext) { s._instrucciones = v }

func (s *Bloque_instContext) GetL() *arrayList.List { return s.l }

func (s *Bloque_instContext) SetL(v *arrayList.List) { s.l = v }

func (s *Bloque_instContext) LLAVEIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarLLAVEIZQ, 0)
}

func (s *Bloque_instContext) Instrucciones() IInstruccionesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstruccionesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstruccionesContext)
}

func (s *Bloque_instContext) LLAVEDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarLLAVEDER, 0)
}

func (s *Bloque_instContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bloque_instContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bloque_instContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterBloque_inst(s)
	}
}

func (s *Bloque_instContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitBloque_inst(s)
	}
}

func (p *swiftgrammar) Bloque_inst() (localctx IBloque_instContext) {
	localctx = NewBloque_instContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, swiftgrammarRULE_bloque_inst)
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(907)
			p.Match(swiftgrammarLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(908)

			var _x = p.Instrucciones()

			localctx.(*Bloque_instContext)._instrucciones = _x
		}
		{
			p.SetState(909)
			p.Match(swiftgrammarLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Bloque_instContext).l = localctx.(*Bloque_instContext).Get_instrucciones().GetL()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(912)
			p.Match(swiftgrammarLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(913)
			p.Match(swiftgrammarLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Bloque_instContext).l = arrayList.New()

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBloque_principContext is an interface to support dynamic dispatch.
type IBloque_principContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_instrucciones returns the _instrucciones rule contexts.
	Get_instrucciones() IInstruccionesContext

	// Set_instrucciones sets the _instrucciones rule contexts.
	Set_instrucciones(IInstruccionesContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// Getter signatures
	Instrucciones() IInstruccionesContext

	// IsBloque_principContext differentiates from other interfaces.
	IsBloque_principContext()
}

type Bloque_principContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	l              *arrayList.List
	_instrucciones IInstruccionesContext
}

func NewEmptyBloque_principContext() *Bloque_principContext {
	var p = new(Bloque_principContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_bloque_princip
	return p
}

func InitEmptyBloque_principContext(p *Bloque_principContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_bloque_princip
}

func (*Bloque_principContext) IsBloque_principContext() {}

func NewBloque_principContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bloque_principContext {
	var p = new(Bloque_principContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_bloque_princip

	return p
}

func (s *Bloque_principContext) GetParser() antlr.Parser { return s.parser }

func (s *Bloque_principContext) Get_instrucciones() IInstruccionesContext { return s._instrucciones }

func (s *Bloque_principContext) Set_instrucciones(v IInstruccionesContext) { s._instrucciones = v }

func (s *Bloque_principContext) GetL() *arrayList.List { return s.l }

func (s *Bloque_principContext) SetL(v *arrayList.List) { s.l = v }

func (s *Bloque_principContext) Instrucciones() IInstruccionesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstruccionesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstruccionesContext)
}

func (s *Bloque_principContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bloque_principContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bloque_principContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterBloque_princip(s)
	}
}

func (s *Bloque_principContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitBloque_princip(s)
	}
}

func (p *swiftgrammar) Bloque_princip() (localctx IBloque_principContext) {
	localctx = NewBloque_principContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, swiftgrammarRULE_bloque_princip)
	p.SetState(921)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(917)

			var _x = p.Instrucciones()

			localctx.(*Bloque_principContext)._instrucciones = _x
		}
		localctx.(*Bloque_principContext).l = localctx.(*Bloque_principContext).Get_instrucciones().GetL()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		localctx.(*Bloque_principContext).l = arrayList.New()

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBloque_expContext is an interface to support dynamic dispatch.
type IBloque_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetP returns the p attribute.
	GetP() interfaces.Expresion

	// SetP sets the p attribute.
	SetP(interfaces.Expresion)

	// Getter signatures
	LLAVEIZQ() antlr.TerminalNode
	Expression() IExpressionContext
	LLAVEDER() antlr.TerminalNode

	// IsBloque_expContext differentiates from other interfaces.
	IsBloque_expContext()
}

type Bloque_expContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	p           interfaces.Expresion
	_expression IExpressionContext
}

func NewEmptyBloque_expContext() *Bloque_expContext {
	var p = new(Bloque_expContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_bloque_exp
	return p
}

func InitEmptyBloque_expContext(p *Bloque_expContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_bloque_exp
}

func (*Bloque_expContext) IsBloque_expContext() {}

func NewBloque_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bloque_expContext {
	var p = new(Bloque_expContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_bloque_exp

	return p
}

func (s *Bloque_expContext) GetParser() antlr.Parser { return s.parser }

func (s *Bloque_expContext) Get_expression() IExpressionContext { return s._expression }

func (s *Bloque_expContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Bloque_expContext) GetP() interfaces.Expresion { return s.p }

func (s *Bloque_expContext) SetP(v interfaces.Expresion) { s.p = v }

func (s *Bloque_expContext) LLAVEIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarLLAVEIZQ, 0)
}

func (s *Bloque_expContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Bloque_expContext) LLAVEDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarLLAVEDER, 0)
}

func (s *Bloque_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bloque_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bloque_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterBloque_exp(s)
	}
}

func (s *Bloque_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitBloque_exp(s)
	}
}

func (p *swiftgrammar) Bloque_exp() (localctx IBloque_expContext) {
	localctx = NewBloque_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, swiftgrammarRULE_bloque_exp)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(923)
		p.Match(swiftgrammarLLAVEIZQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(924)

		var _x = p.expression(0)

		localctx.(*Bloque_expContext)._expression = _x
	}
	{
		p.SetState(925)
		p.Match(swiftgrammarLLAVEDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*Bloque_expContext).p = localctx.(*Bloque_expContext).Get_expression().GetP()

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITipos_varContext is an interface to support dynamic dispatch.
type ITipos_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTipo returns the tipo attribute.
	GetTipo() interfaces.TipoExpresion

	// SetTipo sets the tipo attribute.
	SetTipo(interfaces.TipoExpresion)

	// Getter signatures
	T_NUMBER() antlr.TerminalNode
	AllINTERROG() []antlr.TerminalNode
	INTERROG(i int) antlr.TerminalNode
	T_STRING() antlr.TerminalNode
	T_FLOAT() antlr.TerminalNode
	T_BOOL() antlr.TerminalNode
	T_STR() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	T_CHAT() antlr.TerminalNode
	T_ARRAY() antlr.TerminalNode
	T_VECTOR() antlr.TerminalNode

	// IsTipos_varContext differentiates from other interfaces.
	IsTipos_varContext()
}

type Tipos_varContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	tipo   interfaces.TipoExpresion
}

func NewEmptyTipos_varContext() *Tipos_varContext {
	var p = new(Tipos_varContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_tipos_var
	return p
}

func InitEmptyTipos_varContext(p *Tipos_varContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_tipos_var
}

func (*Tipos_varContext) IsTipos_varContext() {}

func NewTipos_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tipos_varContext {
	var p = new(Tipos_varContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_tipos_var

	return p
}

func (s *Tipos_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Tipos_varContext) GetTipo() interfaces.TipoExpresion { return s.tipo }

func (s *Tipos_varContext) SetTipo(v interfaces.TipoExpresion) { s.tipo = v }

func (s *Tipos_varContext) T_NUMBER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarT_NUMBER, 0)
}

func (s *Tipos_varContext) AllINTERROG() []antlr.TerminalNode {
	return s.GetTokens(swiftgrammarINTERROG)
}

func (s *Tipos_varContext) INTERROG(i int) antlr.TerminalNode {
	return s.GetToken(swiftgrammarINTERROG, i)
}

func (s *Tipos_varContext) T_STRING() antlr.TerminalNode {
	return s.GetToken(swiftgrammarT_STRING, 0)
}

func (s *Tipos_varContext) T_FLOAT() antlr.TerminalNode {
	return s.GetToken(swiftgrammarT_FLOAT, 0)
}

func (s *Tipos_varContext) T_BOOL() antlr.TerminalNode {
	return s.GetToken(swiftgrammarT_BOOL, 0)
}

func (s *Tipos_varContext) T_STR() antlr.TerminalNode {
	return s.GetToken(swiftgrammarT_STR, 0)
}

func (s *Tipos_varContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(swiftgrammarSTRUCT, 0)
}

func (s *Tipos_varContext) T_CHAT() antlr.TerminalNode {
	return s.GetToken(swiftgrammarT_CHAT, 0)
}

func (s *Tipos_varContext) T_ARRAY() antlr.TerminalNode {
	return s.GetToken(swiftgrammarT_ARRAY, 0)
}

func (s *Tipos_varContext) T_VECTOR() antlr.TerminalNode {
	return s.GetToken(swiftgrammarT_VECTOR, 0)
}

func (s *Tipos_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tipos_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tipos_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterTipos_var(s)
	}
}

func (s *Tipos_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitTipos_var(s)
	}
}

func (p *swiftgrammar) Tipos_var() (localctx ITipos_varContext) {
	localctx = NewTipos_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, swiftgrammarRULE_tipos_var)
	var _alt int

	p.SetState(1000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case swiftgrammarT_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(928)
			p.Match(swiftgrammarT_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(932)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(929)
					p.Match(swiftgrammarINTERROG)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(934)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		localctx.(*Tipos_varContext).tipo = interfaces.INTEGER

	case swiftgrammarT_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(936)
			p.Match(swiftgrammarT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(940)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(937)
					p.Match(swiftgrammarINTERROG)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(942)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		localctx.(*Tipos_varContext).tipo = interfaces.STRING

	case swiftgrammarT_FLOAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(944)
			p.Match(swiftgrammarT_FLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(948)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(945)
					p.Match(swiftgrammarINTERROG)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(950)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		localctx.(*Tipos_varContext).tipo = interfaces.FLOAT

	case swiftgrammarT_BOOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(952)
			p.Match(swiftgrammarT_BOOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(953)
					p.Match(swiftgrammarINTERROG)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(958)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		localctx.(*Tipos_varContext).tipo = interfaces.BOOLEAN

	case swiftgrammarT_STR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(960)
			p.Match(swiftgrammarT_STR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(961)
					p.Match(swiftgrammarINTERROG)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(966)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		localctx.(*Tipos_varContext).tipo = interfaces.STR

	case swiftgrammarSTRUCT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(968)
			p.Match(swiftgrammarSTRUCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(969)
					p.Match(swiftgrammarINTERROG)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(974)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		localctx.(*Tipos_varContext).tipo = interfaces.STRUCT

	case swiftgrammarT_CHAT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(976)
			p.Match(swiftgrammarT_CHAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(980)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(977)
					p.Match(swiftgrammarINTERROG)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(982)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		localctx.(*Tipos_varContext).tipo = interfaces.CHAR

	case swiftgrammarT_ARRAY:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(984)
			p.Match(swiftgrammarT_ARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(988)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(985)
					p.Match(swiftgrammarINTERROG)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(990)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		localctx.(*Tipos_varContext).tipo = interfaces.ARRAY

	case swiftgrammarT_VECTOR:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(992)
			p.Match(swiftgrammarT_VECTOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(996)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(993)
					p.Match(swiftgrammarINTERROG)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(998)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		localctx.(*Tipos_varContext).tipo = interfaces.VECTOR

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetE_ini returns the e_ini rule contexts.
	GetE_ini() IExpressionContext

	// Get_expr_arit returns the _expr_arit rule contexts.
	Get_expr_arit() IExpr_aritContext

	// GetE_fin returns the e_fin rule contexts.
	GetE_fin() IExpressionContext

	// SetE_ini sets the e_ini rule contexts.
	SetE_ini(IExpressionContext)

	// Set_expr_arit sets the _expr_arit rule contexts.
	Set_expr_arit(IExpr_aritContext)

	// SetE_fin sets the e_fin rule contexts.
	SetE_fin(IExpressionContext)

	// GetP returns the p attribute.
	GetP() interfaces.Expresion

	// SetP sets the p attribute.
	SetP(interfaces.Expresion)

	// Getter signatures
	Expr_arit() IExpr_aritContext
	AllPUNTO() []antlr.TerminalNode
	PUNTO(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	p          interfaces.Expresion
	e_ini      IExpressionContext
	_expr_arit IExpr_aritContext
	e_fin      IExpressionContext
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) GetE_ini() IExpressionContext { return s.e_ini }

func (s *ExpressionContext) Get_expr_arit() IExpr_aritContext { return s._expr_arit }

func (s *ExpressionContext) GetE_fin() IExpressionContext { return s.e_fin }

func (s *ExpressionContext) SetE_ini(v IExpressionContext) { s.e_ini = v }

func (s *ExpressionContext) Set_expr_arit(v IExpr_aritContext) { s._expr_arit = v }

func (s *ExpressionContext) SetE_fin(v IExpressionContext) { s.e_fin = v }

func (s *ExpressionContext) GetP() interfaces.Expresion { return s.p }

func (s *ExpressionContext) SetP(v interfaces.Expresion) { s.p = v }

func (s *ExpressionContext) Expr_arit() IExpr_aritContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_aritContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_aritContext)
}

func (s *ExpressionContext) AllPUNTO() []antlr.TerminalNode {
	return s.GetTokens(swiftgrammarPUNTO)
}

func (s *ExpressionContext) PUNTO(i int) antlr.TerminalNode {
	return s.GetToken(swiftgrammarPUNTO, i)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *swiftgrammar) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *swiftgrammar) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 102
	p.EnterRecursionRule(localctx, 102, swiftgrammarRULE_expression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1003)

		var _x = p.expr_arit(0)

		localctx.(*ExpressionContext)._expr_arit = _x
	}
	localctx.(*ExpressionContext).p = localctx.(*ExpressionContext).Get_expr_arit().GetP()

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1015)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewExpressionContext(p, _parentctx, _parentState)
			localctx.(*ExpressionContext).e_ini = _prevctx
			p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_expression)
			p.SetState(1006)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(1007)
				p.Match(swiftgrammarPUNTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1008)
				p.Match(swiftgrammarPUNTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1009)
				p.Match(swiftgrammarPUNTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1010)

				var _x = p.expression(2)

				localctx.(*ExpressionContext).e_fin = _x
			}
			localctx.(*ExpressionContext).p = expresion.NewRangeF(localctx.(*ExpressionContext).GetE_ini().GetP(), localctx.(*ExpressionContext).GetE_fin().GetP(), (func() antlr.Token {
				if localctx.(*ExpressionContext).GetE_ini() == nil {
					return nil
				} else {
					return localctx.(*ExpressionContext).GetE_ini().GetStart()
				}
			}()).GetLine(), (func() antlr.Token {
				if localctx.(*ExpressionContext).GetE_ini() == nil {
					return nil
				} else {
					return localctx.(*ExpressionContext).GetE_ini().GetStart()
				}
			}()).GetColumn())

		}
		p.SetState(1017)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_aritContext is an interface to support dynamic dispatch.
type IExpr_aritContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Get_CORIZQ returns the _CORIZQ token.
	Get_CORIZQ() antlr.Token

	// Get_IN returns the _IN token.
	Get_IN() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Set_CORIZQ sets the _CORIZQ token.
	Set_CORIZQ(antlr.Token)

	// Set_IN sets the _IN token.
	Set_IN(antlr.Token)

	// GetOpIz returns the opIz rule contexts.
	GetOpIz() IExpr_aritContext

	// GetOpU returns the opU rule contexts.
	GetOpU() IExpr_aritContext

	// GetExp returns the exp rule contexts.
	GetExp() IExpressionContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// GetTam returns the tam rule contexts.
	GetTam() IExpressionContext

	// GetLive returns the live rule contexts.
	GetLive() IListParamsContext

	// Get_l_StructExp returns the _l_StructExp rule contexts.
	Get_l_StructExp() IL_StructExpContext

	// Get_primitivo returns the _primitivo rule contexts.
	Get_primitivo() IPrimitivoContext

	// Get_casteo returns the _casteo rule contexts.
	Get_casteo() ICasteoContext

	// Get_if_exp returns the _if_exp rule contexts.
	Get_if_exp() IIf_expContext

	// Get_switch_sent returns the _switch_sent rule contexts.
	Get_switch_sent() ISwitch_sentContext

	// Get_while_true returns the _while_true rule contexts.
	Get_while_true() IWhile_trueContext

	// Get_callFunction returns the _callFunction rule contexts.
	Get_callFunction() ICallFunctionContext

	// GetOpDe returns the opDe rule contexts.
	GetOpDe() IExpr_aritContext

	// SetOpIz sets the opIz rule contexts.
	SetOpIz(IExpr_aritContext)

	// SetOpU sets the opU rule contexts.
	SetOpU(IExpr_aritContext)

	// SetExp sets the exp rule contexts.
	SetExp(IExpressionContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// SetTam sets the tam rule contexts.
	SetTam(IExpressionContext)

	// SetLive sets the live rule contexts.
	SetLive(IListParamsContext)

	// Set_l_StructExp sets the _l_StructExp rule contexts.
	Set_l_StructExp(IL_StructExpContext)

	// Set_primitivo sets the _primitivo rule contexts.
	Set_primitivo(IPrimitivoContext)

	// Set_casteo sets the _casteo rule contexts.
	Set_casteo(ICasteoContext)

	// Set_if_exp sets the _if_exp rule contexts.
	Set_if_exp(IIf_expContext)

	// Set_switch_sent sets the _switch_sent rule contexts.
	Set_switch_sent(ISwitch_sentContext)

	// Set_while_true sets the _while_true rule contexts.
	Set_while_true(IWhile_trueContext)

	// Set_callFunction sets the _callFunction rule contexts.
	Set_callFunction(ICallFunctionContext)

	// SetOpDe sets the opDe rule contexts.
	SetOpDe(IExpr_aritContext)

	// GetP returns the p attribute.
	GetP() interfaces.Expresion

	// SetP sets the p attribute.
	SetP(interfaces.Expresion)

	// Getter signatures
	SUB() antlr.TerminalNode
	AllExpr_arit() []IExpr_aritContext
	Expr_arit(i int) IExpr_aritContext
	NOT() antlr.TerminalNode
	T_STRING() antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	PARDER() antlr.TerminalNode
	ID() antlr.TerminalNode
	PUNTO() antlr.TerminalNode
	CAPF() antlr.TerminalNode
	CORIZQ() antlr.TerminalNode
	PTCOMA() antlr.TerminalNode
	CORDER() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	ListParams() IListParamsContext
	L_StructExp() IL_StructExpContext
	Primitivo() IPrimitivoContext
	Casteo() ICasteoContext
	If_exp() IIf_expContext
	Switch_sent() ISwitch_sentContext
	While_true() IWhile_trueContext
	CallFunction() ICallFunctionContext
	REMOVE() antlr.TerminalNode
	IN() antlr.TerminalNode
	MUL() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	ADD() antlr.TerminalNode
	MENOR() antlr.TerminalNode
	MENORIGUAL() antlr.TerminalNode
	MAYOR() antlr.TerminalNode
	MAYORIGUAL() antlr.TerminalNode
	IGUAL() antlr.TerminalNode
	DISTINTO() antlr.TerminalNode
	AND() antlr.TerminalNode
	OR() antlr.TerminalNode
	COUNT() antlr.TerminalNode

	// IsExpr_aritContext differentiates from other interfaces.
	IsExpr_aritContext()
}

type Expr_aritContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	p             interfaces.Expresion
	opIz          IExpr_aritContext
	op            antlr.Token
	opU           IExpr_aritContext
	_ID           antlr.Token
	_CORIZQ       antlr.Token
	exp           IExpressionContext
	_expression   IExpressionContext
	tam           IExpressionContext
	live          IListParamsContext
	_l_StructExp  IL_StructExpContext
	_primitivo    IPrimitivoContext
	_casteo       ICasteoContext
	_if_exp       IIf_expContext
	_switch_sent  ISwitch_sentContext
	_while_true   IWhile_trueContext
	_callFunction ICallFunctionContext
	_IN           antlr.Token
	opDe          IExpr_aritContext
}

func NewEmptyExpr_aritContext() *Expr_aritContext {
	var p = new(Expr_aritContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_expr_arit
	return p
}

func InitEmptyExpr_aritContext(p *Expr_aritContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_expr_arit
}

func (*Expr_aritContext) IsExpr_aritContext() {}

func NewExpr_aritContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_aritContext {
	var p = new(Expr_aritContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_expr_arit

	return p
}

func (s *Expr_aritContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_aritContext) GetOp() antlr.Token { return s.op }

func (s *Expr_aritContext) Get_ID() antlr.Token { return s._ID }

func (s *Expr_aritContext) Get_CORIZQ() antlr.Token { return s._CORIZQ }

func (s *Expr_aritContext) Get_IN() antlr.Token { return s._IN }

func (s *Expr_aritContext) SetOp(v antlr.Token) { s.op = v }

func (s *Expr_aritContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *Expr_aritContext) Set_CORIZQ(v antlr.Token) { s._CORIZQ = v }

func (s *Expr_aritContext) Set_IN(v antlr.Token) { s._IN = v }

func (s *Expr_aritContext) GetOpIz() IExpr_aritContext { return s.opIz }

func (s *Expr_aritContext) GetOpU() IExpr_aritContext { return s.opU }

func (s *Expr_aritContext) GetExp() IExpressionContext { return s.exp }

func (s *Expr_aritContext) Get_expression() IExpressionContext { return s._expression }

func (s *Expr_aritContext) GetTam() IExpressionContext { return s.tam }

func (s *Expr_aritContext) GetLive() IListParamsContext { return s.live }

func (s *Expr_aritContext) Get_l_StructExp() IL_StructExpContext { return s._l_StructExp }

func (s *Expr_aritContext) Get_primitivo() IPrimitivoContext { return s._primitivo }

func (s *Expr_aritContext) Get_casteo() ICasteoContext { return s._casteo }

func (s *Expr_aritContext) Get_if_exp() IIf_expContext { return s._if_exp }

func (s *Expr_aritContext) Get_switch_sent() ISwitch_sentContext { return s._switch_sent }

func (s *Expr_aritContext) Get_while_true() IWhile_trueContext { return s._while_true }

func (s *Expr_aritContext) Get_callFunction() ICallFunctionContext { return s._callFunction }

func (s *Expr_aritContext) GetOpDe() IExpr_aritContext { return s.opDe }

func (s *Expr_aritContext) SetOpIz(v IExpr_aritContext) { s.opIz = v }

func (s *Expr_aritContext) SetOpU(v IExpr_aritContext) { s.opU = v }

func (s *Expr_aritContext) SetExp(v IExpressionContext) { s.exp = v }

func (s *Expr_aritContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Expr_aritContext) SetTam(v IExpressionContext) { s.tam = v }

func (s *Expr_aritContext) SetLive(v IListParamsContext) { s.live = v }

func (s *Expr_aritContext) Set_l_StructExp(v IL_StructExpContext) { s._l_StructExp = v }

func (s *Expr_aritContext) Set_primitivo(v IPrimitivoContext) { s._primitivo = v }

func (s *Expr_aritContext) Set_casteo(v ICasteoContext) { s._casteo = v }

func (s *Expr_aritContext) Set_if_exp(v IIf_expContext) { s._if_exp = v }

func (s *Expr_aritContext) Set_switch_sent(v ISwitch_sentContext) { s._switch_sent = v }

func (s *Expr_aritContext) Set_while_true(v IWhile_trueContext) { s._while_true = v }

func (s *Expr_aritContext) Set_callFunction(v ICallFunctionContext) { s._callFunction = v }

func (s *Expr_aritContext) SetOpDe(v IExpr_aritContext) { s.opDe = v }

func (s *Expr_aritContext) GetP() interfaces.Expresion { return s.p }

func (s *Expr_aritContext) SetP(v interfaces.Expresion) { s.p = v }

func (s *Expr_aritContext) SUB() antlr.TerminalNode {
	return s.GetToken(swiftgrammarSUB, 0)
}

func (s *Expr_aritContext) AllExpr_arit() []IExpr_aritContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpr_aritContext); ok {
			len++
		}
	}

	tst := make([]IExpr_aritContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpr_aritContext); ok {
			tst[i] = t.(IExpr_aritContext)
			i++
		}
	}

	return tst
}

func (s *Expr_aritContext) Expr_arit(i int) IExpr_aritContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_aritContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_aritContext)
}

func (s *Expr_aritContext) NOT() antlr.TerminalNode {
	return s.GetToken(swiftgrammarNOT, 0)
}

func (s *Expr_aritContext) T_STRING() antlr.TerminalNode {
	return s.GetToken(swiftgrammarT_STRING, 0)
}

func (s *Expr_aritContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARIZQ, 0)
}

func (s *Expr_aritContext) PARDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARDER, 0)
}

func (s *Expr_aritContext) ID() antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, 0)
}

func (s *Expr_aritContext) PUNTO() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPUNTO, 0)
}

func (s *Expr_aritContext) CAPF() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCAPF, 0)
}

func (s *Expr_aritContext) CORIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORIZQ, 0)
}

func (s *Expr_aritContext) PTCOMA() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPTCOMA, 0)
}

func (s *Expr_aritContext) CORDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORDER, 0)
}

func (s *Expr_aritContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Expr_aritContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expr_aritContext) ListParams() IListParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListParamsContext)
}

func (s *Expr_aritContext) L_StructExp() IL_StructExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IL_StructExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IL_StructExpContext)
}

func (s *Expr_aritContext) Primitivo() IPrimitivoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitivoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitivoContext)
}

func (s *Expr_aritContext) Casteo() ICasteoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICasteoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICasteoContext)
}

func (s *Expr_aritContext) If_exp() IIf_expContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_expContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_expContext)
}

func (s *Expr_aritContext) Switch_sent() ISwitch_sentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitch_sentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitch_sentContext)
}

func (s *Expr_aritContext) While_true() IWhile_trueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhile_trueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhile_trueContext)
}

func (s *Expr_aritContext) CallFunction() ICallFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallFunctionContext)
}

func (s *Expr_aritContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(swiftgrammarREMOVE, 0)
}

func (s *Expr_aritContext) IN() antlr.TerminalNode {
	return s.GetToken(swiftgrammarIN, 0)
}

func (s *Expr_aritContext) MUL() antlr.TerminalNode {
	return s.GetToken(swiftgrammarMUL, 0)
}

func (s *Expr_aritContext) DIV() antlr.TerminalNode {
	return s.GetToken(swiftgrammarDIV, 0)
}

func (s *Expr_aritContext) MOD() antlr.TerminalNode {
	return s.GetToken(swiftgrammarMOD, 0)
}

func (s *Expr_aritContext) ADD() antlr.TerminalNode {
	return s.GetToken(swiftgrammarADD, 0)
}

func (s *Expr_aritContext) MENOR() antlr.TerminalNode {
	return s.GetToken(swiftgrammarMENOR, 0)
}

func (s *Expr_aritContext) MENORIGUAL() antlr.TerminalNode {
	return s.GetToken(swiftgrammarMENORIGUAL, 0)
}

func (s *Expr_aritContext) MAYOR() antlr.TerminalNode {
	return s.GetToken(swiftgrammarMAYOR, 0)
}

func (s *Expr_aritContext) MAYORIGUAL() antlr.TerminalNode {
	return s.GetToken(swiftgrammarMAYORIGUAL, 0)
}

func (s *Expr_aritContext) IGUAL() antlr.TerminalNode {
	return s.GetToken(swiftgrammarIGUAL, 0)
}

func (s *Expr_aritContext) DISTINTO() antlr.TerminalNode {
	return s.GetToken(swiftgrammarDISTINTO, 0)
}

func (s *Expr_aritContext) AND() antlr.TerminalNode {
	return s.GetToken(swiftgrammarAND, 0)
}

func (s *Expr_aritContext) OR() antlr.TerminalNode {
	return s.GetToken(swiftgrammarOR, 0)
}

func (s *Expr_aritContext) COUNT() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCOUNT, 0)
}

func (s *Expr_aritContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_aritContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_aritContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterExpr_arit(s)
	}
}

func (s *Expr_aritContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitExpr_arit(s)
	}
}

func (p *swiftgrammar) Expr_arit() (localctx IExpr_aritContext) {
	return p.expr_arit(0)
}

func (p *swiftgrammar) expr_arit(_p int) (localctx IExpr_aritContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpr_aritContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpr_aritContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 104
	p.EnterRecursionRule(localctx, 104, swiftgrammarRULE_expr_arit, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1090)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1019)

			var _m = p.Match(swiftgrammarSUB)

			localctx.(*Expr_aritContext).op = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1020)

			var _x = p.expr_arit(22)

			localctx.(*Expr_aritContext).opU = _x
		}
		localctx.(*Expr_aritContext).p = expresion.NewOperacion(localctx.(*Expr_aritContext).GetOpU().GetP(), "-", nil, true, (func() int {
			if localctx.(*Expr_aritContext).GetOp() == nil {
				return 0
			} else {
				return localctx.(*Expr_aritContext).GetOp().GetLine()
			}
		}()), localctx.(*Expr_aritContext).GetOp().GetColumn())

	case 2:
		{
			p.SetState(1023)

			var _m = p.Match(swiftgrammarNOT)

			localctx.(*Expr_aritContext).op = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1024)

			var _x = p.expr_arit(17)

			localctx.(*Expr_aritContext).opU = _x
		}
		localctx.(*Expr_aritContext).p = expresion.NewOperacion(localctx.(*Expr_aritContext).GetOpU().GetP(), "!", nil, true, (func() int {
			if localctx.(*Expr_aritContext).GetOp() == nil {
				return 0
			} else {
				return localctx.(*Expr_aritContext).GetOp().GetLine()
			}
		}()), localctx.(*Expr_aritContext).GetOp().GetColumn())

	case 3:
		{
			p.SetState(1027)
			p.Match(swiftgrammarT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1028)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1029)

			var _x = p.expr_arit(0)

			localctx.(*Expr_aritContext).opIz = _x
		}
		{
			p.SetState(1030)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Expr_aritContext).p = expresion.NewToString(localctx.(*Expr_aritContext).GetOpIz().GetP(), (func() antlr.Token {
			if localctx.(*Expr_aritContext).GetOpIz() == nil {
				return nil
			} else {
				return localctx.(*Expr_aritContext).GetOpIz().GetStart()
			}
		}()).GetLine(), (func() antlr.Token {
			if localctx.(*Expr_aritContext).GetOpIz() == nil {
				return nil
			} else {
				return localctx.(*Expr_aritContext).GetOpIz().GetStart()
			}
		}()).GetColumn())

	case 4:
		{
			p.SetState(1033)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Expr_aritContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1034)
			p.Match(swiftgrammarPUNTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1035)
			p.Match(swiftgrammarCAPF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Expr_aritContext).p = expresion.NewCapacity((func() string {
			if localctx.(*Expr_aritContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Expr_aritContext).Get_ID().GetText()
			}
		}()), (func() int {
			if localctx.(*Expr_aritContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Expr_aritContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*Expr_aritContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Expr_aritContext).Get_ID().GetColumn()
			}
		}()))

	case 5:
		{
			p.SetState(1037)

			var _m = p.Match(swiftgrammarCORIZQ)

			localctx.(*Expr_aritContext)._CORIZQ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1038)

			var _x = p.expression(0)

			localctx.(*Expr_aritContext).exp = _x
			localctx.(*Expr_aritContext)._expression = _x
		}
		{
			p.SetState(1039)
			p.Match(swiftgrammarPTCOMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1040)

			var _x = p.expression(0)

			localctx.(*Expr_aritContext).tam = _x
			localctx.(*Expr_aritContext)._expression = _x
		}
		{
			p.SetState(1041)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Expr_aritContext).p = expresion.NewVector(nil, localctx.(*Expr_aritContext).GetExp().GetP(), localctx.(*Expr_aritContext).GetTam().GetP(), 2, (func() int {
			if localctx.(*Expr_aritContext).Get_CORIZQ() == nil {
				return 0
			} else {
				return localctx.(*Expr_aritContext).Get_CORIZQ().GetLine()
			}
		}()), (func() int {
			if localctx.(*Expr_aritContext).Get_CORIZQ() == nil {
				return 0
			} else {
				return localctx.(*Expr_aritContext).Get_CORIZQ().GetColumn()
			}
		}()))

	case 6:
		{
			p.SetState(1044)

			var _m = p.Match(swiftgrammarCORIZQ)

			localctx.(*Expr_aritContext)._CORIZQ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1045)

			var _x = p.listParams(0)

			localctx.(*Expr_aritContext).live = _x
		}
		{
			p.SetState(1046)
			p.Match(swiftgrammarCORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Expr_aritContext).p = expresion.NewVector(localctx.(*Expr_aritContext).GetLive().GetL_e(), nil, nil, 1, (func() int {
			if localctx.(*Expr_aritContext).Get_CORIZQ() == nil {
				return 0
			} else {
				return localctx.(*Expr_aritContext).Get_CORIZQ().GetLine()
			}
		}()), (func() int {
			if localctx.(*Expr_aritContext).Get_CORIZQ() == nil {
				return 0
			} else {
				return localctx.(*Expr_aritContext).Get_CORIZQ().GetColumn()
			}
		}()))

	case 7:
		{
			p.SetState(1049)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Expr_aritContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1050)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1051)

			var _x = p.l_StructExp(0)

			localctx.(*Expr_aritContext)._l_StructExp = _x
		}
		{
			p.SetState(1052)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Expr_aritContext).p = instructionExpre.NewStructExpre((func() string {
			if localctx.(*Expr_aritContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Expr_aritContext).Get_ID().GetText()
			}
		}()), localctx.(*Expr_aritContext).Get_l_StructExp().GetL(), (func() int {
			if localctx.(*Expr_aritContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Expr_aritContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*Expr_aritContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Expr_aritContext).Get_ID().GetColumn()
			}
		}()))

	case 8:
		{
			p.SetState(1055)

			var _x = p.Primitivo()

			localctx.(*Expr_aritContext)._primitivo = _x
		}
		localctx.(*Expr_aritContext).p = localctx.(*Expr_aritContext).Get_primitivo().GetP()

	case 9:
		{
			p.SetState(1058)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1059)

			var _x = p.expression(0)

			localctx.(*Expr_aritContext)._expression = _x
		}
		{
			p.SetState(1060)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Expr_aritContext).p = localctx.(*Expr_aritContext).Get_expression().GetP()

	case 10:
		{
			p.SetState(1063)

			var _x = p.Casteo()

			localctx.(*Expr_aritContext)._casteo = _x
		}
		localctx.(*Expr_aritContext).p = localctx.(*Expr_aritContext).Get_casteo().GetP()

	case 11:
		{
			p.SetState(1066)

			var _x = p.If_exp()

			localctx.(*Expr_aritContext)._if_exp = _x
		}
		localctx.(*Expr_aritContext).p = localctx.(*Expr_aritContext).Get_if_exp().GetP()

	case 12:
		{
			p.SetState(1069)

			var _x = p.Switch_sent()

			localctx.(*Expr_aritContext)._switch_sent = _x
		}
		localctx.(*Expr_aritContext).p = localctx.(*Expr_aritContext).Get_switch_sent().GetP()

	case 13:
		{
			p.SetState(1072)

			var _x = p.While_true()

			localctx.(*Expr_aritContext)._while_true = _x
		}
		localctx.(*Expr_aritContext).p = localctx.(*Expr_aritContext).Get_while_true().GetP()

	case 14:
		{
			p.SetState(1075)

			var _x = p.CallFunction()

			localctx.(*Expr_aritContext)._callFunction = _x
		}
		localctx.(*Expr_aritContext).p = localctx.(*Expr_aritContext).Get_callFunction().GetP()

	case 15:
		{
			p.SetState(1078)

			var _m = p.Match(swiftgrammarID)

			localctx.(*Expr_aritContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1079)
			p.Match(swiftgrammarPUNTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1080)
			p.Match(swiftgrammarREMOVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1081)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1082)

			var _x = p.expression(0)

			localctx.(*Expr_aritContext)._expression = _x
		}
		{
			p.SetState(1083)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Expr_aritContext).p = instructionExpre.NewRemove((func() string {
			if localctx.(*Expr_aritContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Expr_aritContext).Get_ID().GetText()
			}
		}()), localctx.(*Expr_aritContext).Get_expression().GetP(), (func() int {
			if localctx.(*Expr_aritContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Expr_aritContext).Get_ID().GetLine()
			}
		}()), (func() int {
			if localctx.(*Expr_aritContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Expr_aritContext).Get_ID().GetColumn()
			}
		}()))

	case 16:
		{
			p.SetState(1086)

			var _m = p.Match(swiftgrammarIN)

			localctx.(*Expr_aritContext)._IN = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1087)

			var _x = p.Primitivo()

			localctx.(*Expr_aritContext)._primitivo = _x
		}
		localctx.(*Expr_aritContext).p = expresion.NewcadenaFor(localctx.(*Expr_aritContext).Get_primitivo().GetP(), (func() int {
			if localctx.(*Expr_aritContext).Get_IN() == nil {
				return 0
			} else {
				return localctx.(*Expr_aritContext).Get_IN().GetLine()
			}
		}()), (func() int {
			if localctx.(*Expr_aritContext).Get_IN() == nil {
				return 0
			} else {
				return localctx.(*Expr_aritContext).Get_IN().GetColumn()
			}
		}()))

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1121)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpr_aritContext(p, _parentctx, _parentState)
				localctx.(*Expr_aritContext).opIz = _prevctx
				p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_expr_arit)
				p.SetState(1092)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
					goto errorExit
				}
				{
					p.SetState(1093)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Expr_aritContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&5476377146882523136) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Expr_aritContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1094)

					var _x = p.expr_arit(22)

					localctx.(*Expr_aritContext).opDe = _x
				}
				localctx.(*Expr_aritContext).p = expresion.NewOperacion(localctx.(*Expr_aritContext).GetOpIz().GetP(), (func() string {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetText()
					}
				}()), localctx.(*Expr_aritContext).GetOpDe().GetP(), false, (func() int {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return 0
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetLine()
					}
				}()), localctx.(*Expr_aritContext).GetOp().GetColumn())

			case 2:
				localctx = NewExpr_aritContext(p, _parentctx, _parentState)
				localctx.(*Expr_aritContext).opIz = _prevctx
				p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_expr_arit)
				p.SetState(1097)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(1098)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Expr_aritContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == swiftgrammarADD || _la == swiftgrammarSUB) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Expr_aritContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1099)

					var _x = p.expr_arit(20)

					localctx.(*Expr_aritContext).opDe = _x
				}
				localctx.(*Expr_aritContext).p = expresion.NewOperacion(localctx.(*Expr_aritContext).GetOpIz().GetP(), (func() string {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetText()
					}
				}()), localctx.(*Expr_aritContext).GetOpDe().GetP(), false, (func() int {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return 0
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetLine()
					}
				}()), localctx.(*Expr_aritContext).GetOp().GetColumn())

			case 3:
				localctx = NewExpr_aritContext(p, _parentctx, _parentState)
				localctx.(*Expr_aritContext).opIz = _prevctx
				p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_expr_arit)
				p.SetState(1102)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
					goto errorExit
				}
				{
					p.SetState(1103)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Expr_aritContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&141863388262170624) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Expr_aritContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1104)

					var _x = p.expr_arit(19)

					localctx.(*Expr_aritContext).opDe = _x
				}
				localctx.(*Expr_aritContext).p = expresion.NewOperacion(localctx.(*Expr_aritContext).GetOpIz().GetP(), (func() string {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetText()
					}
				}()), localctx.(*Expr_aritContext).GetOpDe().GetP(), false, (func() int {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return 0
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetLine()
					}
				}()), localctx.(*Expr_aritContext).GetOp().GetColumn())

			case 4:
				localctx = NewExpr_aritContext(p, _parentctx, _parentState)
				localctx.(*Expr_aritContext).opIz = _prevctx
				p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_expr_arit)
				p.SetState(1107)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(1108)

					var _m = p.Match(swiftgrammarAND)

					localctx.(*Expr_aritContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1109)

					var _x = p.expr_arit(17)

					localctx.(*Expr_aritContext).opDe = _x
				}
				localctx.(*Expr_aritContext).p = expresion.NewOperacion(localctx.(*Expr_aritContext).GetOpIz().GetP(), (func() string {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetText()
					}
				}()), localctx.(*Expr_aritContext).GetOpDe().GetP(), false, (func() int {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return 0
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetLine()
					}
				}()), localctx.(*Expr_aritContext).GetOp().GetColumn())

			case 5:
				localctx = NewExpr_aritContext(p, _parentctx, _parentState)
				localctx.(*Expr_aritContext).opIz = _prevctx
				p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_expr_arit)
				p.SetState(1112)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(1113)

					var _m = p.Match(swiftgrammarOR)

					localctx.(*Expr_aritContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1114)

					var _x = p.expr_arit(16)

					localctx.(*Expr_aritContext).opDe = _x
				}
				localctx.(*Expr_aritContext).p = expresion.NewOperacion(localctx.(*Expr_aritContext).GetOpIz().GetP(), (func() string {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetText()
					}
				}()), localctx.(*Expr_aritContext).GetOpDe().GetP(), false, (func() int {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return 0
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetLine()
					}
				}()), localctx.(*Expr_aritContext).GetOp().GetColumn())

			case 6:
				localctx = NewExpr_aritContext(p, _parentctx, _parentState)
				localctx.(*Expr_aritContext).opIz = _prevctx
				p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_expr_arit)
				p.SetState(1117)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
					goto errorExit
				}
				{
					p.SetState(1118)
					p.Match(swiftgrammarPUNTO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1119)
					p.Match(swiftgrammarCOUNT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*Expr_aritContext).p = expresion.NewCount(localctx.(*Expr_aritContext).GetOpIz().GetP(), (func() antlr.Token {
					if localctx.(*Expr_aritContext).GetOpIz() == nil {
						return nil
					} else {
						return localctx.(*Expr_aritContext).GetOpIz().GetStart()
					}
				}()).GetLine(), (func() antlr.Token {
					if localctx.(*Expr_aritContext).GetOpIz() == nil {
						return nil
					} else {
						return localctx.(*Expr_aritContext).GetOpIz().GetStart()
					}
				}()).GetColumn())

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1125)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICasteoContext is an interface to support dynamic dispatch.
type ICasteoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_PARIZQ returns the _PARIZQ token.
	Get_PARIZQ() antlr.Token

	// Set_PARIZQ sets the _PARIZQ token.
	Set_PARIZQ(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// GetTypec returns the typec rule contexts.
	GetTypec() ITipo_castContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// SetTypec sets the typec rule contexts.
	SetTypec(ITipo_castContext)

	// GetP returns the p attribute.
	GetP() interfaces.Expresion

	// SetP sets the p attribute.
	SetP(interfaces.Expresion)

	// Getter signatures
	PARIZQ() antlr.TerminalNode
	Expression() IExpressionContext
	AS() antlr.TerminalNode
	PARDER() antlr.TerminalNode
	Tipo_cast() ITipo_castContext

	// IsCasteoContext differentiates from other interfaces.
	IsCasteoContext()
}

type CasteoContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	p           interfaces.Expresion
	_PARIZQ     antlr.Token
	_expression IExpressionContext
	typec       ITipo_castContext
}

func NewEmptyCasteoContext() *CasteoContext {
	var p = new(CasteoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_casteo
	return p
}

func InitEmptyCasteoContext(p *CasteoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_casteo
}

func (*CasteoContext) IsCasteoContext() {}

func NewCasteoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CasteoContext {
	var p = new(CasteoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_casteo

	return p
}

func (s *CasteoContext) GetParser() antlr.Parser { return s.parser }

func (s *CasteoContext) Get_PARIZQ() antlr.Token { return s._PARIZQ }

func (s *CasteoContext) Set_PARIZQ(v antlr.Token) { s._PARIZQ = v }

func (s *CasteoContext) Get_expression() IExpressionContext { return s._expression }

func (s *CasteoContext) GetTypec() ITipo_castContext { return s.typec }

func (s *CasteoContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *CasteoContext) SetTypec(v ITipo_castContext) { s.typec = v }

func (s *CasteoContext) GetP() interfaces.Expresion { return s.p }

func (s *CasteoContext) SetP(v interfaces.Expresion) { s.p = v }

func (s *CasteoContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARIZQ, 0)
}

func (s *CasteoContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CasteoContext) AS() antlr.TerminalNode {
	return s.GetToken(swiftgrammarAS, 0)
}

func (s *CasteoContext) PARDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARDER, 0)
}

func (s *CasteoContext) Tipo_cast() ITipo_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipo_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipo_castContext)
}

func (s *CasteoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CasteoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CasteoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterCasteo(s)
	}
}

func (s *CasteoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitCasteo(s)
	}
}

func (p *swiftgrammar) Casteo() (localctx ICasteoContext) {
	localctx = NewCasteoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, swiftgrammarRULE_casteo)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1126)

		var _m = p.Match(swiftgrammarPARIZQ)

		localctx.(*CasteoContext)._PARIZQ = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1127)

		var _x = p.expression(0)

		localctx.(*CasteoContext)._expression = _x
	}
	{
		p.SetState(1128)
		p.Match(swiftgrammarAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1129)

		var _x = p.Tipo_cast()

		localctx.(*CasteoContext).typec = _x
	}
	{
		p.SetState(1130)
		p.Match(swiftgrammarPARDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*CasteoContext).p = expresion.NewCasteo(localctx.(*CasteoContext).Get_expression().GetP(), localctx.(*CasteoContext).GetTypec().GetTc(), (func() int {
		if localctx.(*CasteoContext).Get_PARIZQ() == nil {
			return 0
		} else {
			return localctx.(*CasteoContext).Get_PARIZQ().GetLine()
		}
	}()), localctx.(*CasteoContext).Get_PARIZQ().GetColumn())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITipo_castContext is an interface to support dynamic dispatch.
type ITipo_castContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTc returns the tc attribute.
	GetTc() interfaces.TipoExpresion

	// SetTc sets the tc attribute.
	SetTc(interfaces.TipoExpresion)

	// Getter signatures
	T_FLOAT() antlr.TerminalNode
	T_NUMBER() antlr.TerminalNode
	USIZE() antlr.TerminalNode

	// IsTipo_castContext differentiates from other interfaces.
	IsTipo_castContext()
}

type Tipo_castContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	tc     interfaces.TipoExpresion
}

func NewEmptyTipo_castContext() *Tipo_castContext {
	var p = new(Tipo_castContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_tipo_cast
	return p
}

func InitEmptyTipo_castContext(p *Tipo_castContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_tipo_cast
}

func (*Tipo_castContext) IsTipo_castContext() {}

func NewTipo_castContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tipo_castContext {
	var p = new(Tipo_castContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_tipo_cast

	return p
}

func (s *Tipo_castContext) GetParser() antlr.Parser { return s.parser }

func (s *Tipo_castContext) GetTc() interfaces.TipoExpresion { return s.tc }

func (s *Tipo_castContext) SetTc(v interfaces.TipoExpresion) { s.tc = v }

func (s *Tipo_castContext) T_FLOAT() antlr.TerminalNode {
	return s.GetToken(swiftgrammarT_FLOAT, 0)
}

func (s *Tipo_castContext) T_NUMBER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarT_NUMBER, 0)
}

func (s *Tipo_castContext) USIZE() antlr.TerminalNode {
	return s.GetToken(swiftgrammarUSIZE, 0)
}

func (s *Tipo_castContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tipo_castContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tipo_castContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterTipo_cast(s)
	}
}

func (s *Tipo_castContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitTipo_cast(s)
	}
}

func (p *swiftgrammar) Tipo_cast() (localctx ITipo_castContext) {
	localctx = NewTipo_castContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, swiftgrammarRULE_tipo_cast)
	p.SetState(1139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case swiftgrammarT_FLOAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1133)
			p.Match(swiftgrammarT_FLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Tipo_castContext).tc = interfaces.FLOAT

	case swiftgrammarT_NUMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1135)
			p.Match(swiftgrammarT_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Tipo_castContext).tc = interfaces.INTEGER

	case swiftgrammarUSIZE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1137)
			p.Match(swiftgrammarUSIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Tipo_castContext).tc = interfaces.INTEGER

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IL_StructExpContext is an interface to support dynamic dispatch.
type IL_StructExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// GetList returns the list rule contexts.
	GetList() IL_StructExpContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// SetList sets the list rule contexts.
	SetList(IL_StructExpContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// Getter signatures
	ID() antlr.TerminalNode
	DPUNTO2() antlr.TerminalNode
	Expression() IExpressionContext
	COMA() antlr.TerminalNode
	L_StructExp() IL_StructExpContext

	// IsL_StructExpContext differentiates from other interfaces.
	IsL_StructExpContext()
}

type L_StructExpContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	l           *arrayList.List
	list        IL_StructExpContext
	_ID         antlr.Token
	_expression IExpressionContext
}

func NewEmptyL_StructExpContext() *L_StructExpContext {
	var p = new(L_StructExpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_l_StructExp
	return p
}

func InitEmptyL_StructExpContext(p *L_StructExpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_l_StructExp
}

func (*L_StructExpContext) IsL_StructExpContext() {}

func NewL_StructExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *L_StructExpContext {
	var p = new(L_StructExpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_l_StructExp

	return p
}

func (s *L_StructExpContext) GetParser() antlr.Parser { return s.parser }

func (s *L_StructExpContext) Get_ID() antlr.Token { return s._ID }

func (s *L_StructExpContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *L_StructExpContext) GetList() IL_StructExpContext { return s.list }

func (s *L_StructExpContext) Get_expression() IExpressionContext { return s._expression }

func (s *L_StructExpContext) SetList(v IL_StructExpContext) { s.list = v }

func (s *L_StructExpContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *L_StructExpContext) GetL() *arrayList.List { return s.l }

func (s *L_StructExpContext) SetL(v *arrayList.List) { s.l = v }

func (s *L_StructExpContext) ID() antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, 0)
}

func (s *L_StructExpContext) DPUNTO2() antlr.TerminalNode {
	return s.GetToken(swiftgrammarDPUNTO2, 0)
}

func (s *L_StructExpContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *L_StructExpContext) COMA() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCOMA, 0)
}

func (s *L_StructExpContext) L_StructExp() IL_StructExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IL_StructExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IL_StructExpContext)
}

func (s *L_StructExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *L_StructExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *L_StructExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterL_StructExp(s)
	}
}

func (s *L_StructExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitL_StructExp(s)
	}
}

func (p *swiftgrammar) L_StructExp() (localctx IL_StructExpContext) {
	return p.l_StructExp(0)
}

func (p *swiftgrammar) l_StructExp(_p int) (localctx IL_StructExpContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewL_StructExpContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IL_StructExpContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 110
	p.EnterRecursionRule(localctx, 110, swiftgrammarRULE_l_StructExp, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1142)

		var _m = p.Match(swiftgrammarID)

		localctx.(*L_StructExpContext)._ID = _m
		if p.HasError() {
			// Recognition error - abort rule
		//	goto errorExit
		}
	}
	{
		p.SetState(1143)
		p.Match(swiftgrammarDPUNTO2)
		if p.HasError() {
			// Recognition error - abort rule
		//	goto errorExit
		}
	}
	{
		p.SetState(1144)

		var _x = p.expression(0)

		localctx.(*L_StructExpContext)._expression = _x
	}

	Str_ep := instructionExpre.NewStructContenido((func() string {
		if localctx.(*L_StructExpContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*L_StructExpContext).Get_ID().GetText()
		}
	}()), localctx.(*L_StructExpContext).Get_expression().GetP())
	localctx.(*L_StructExpContext).SetL(arrayList.New())
	localctx.(*L_StructExpContext).l.Add(Str_ep)

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1156)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewL_StructExpContext(p, _parentctx, _parentState)
			localctx.(*L_StructExpContext).list = _prevctx
			p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_l_StructExp)
			p.SetState(1147)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(1148)
				p.Match(swiftgrammarCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1149)

				var _m = p.Match(swiftgrammarID)

				localctx.(*L_StructExpContext)._ID = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1150)
				p.Match(swiftgrammarDPUNTO2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1151)

				var _x = p.expression(0)

				localctx.(*L_StructExpContext)._expression = _x
			}

			Str_ep := instructionExpre.NewStructContenido((func() string {
				if localctx.(*L_StructExpContext).Get_ID() == nil {
					return ""
				} else {
					return localctx.(*L_StructExpContext).Get_ID().GetText()
				}
			}()), localctx.(*L_StructExpContext).Get_expression().GetP())
			localctx.(*L_StructExpContext).GetList().GetL().Add(Str_ep)
			localctx.(*L_StructExpContext).SetL(localctx.(*L_StructExpContext).GetList().GetL())

		}
		p.SetState(1158)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitivoContext is an interface to support dynamic dispatch.
type IPrimitivoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_NUMBER returns the _NUMBER token.
	Get_NUMBER() antlr.Token

	// Get_FLOAT returns the _FLOAT token.
	Get_FLOAT() antlr.Token

	// Get_CHAR returns the _CHAR token.
	Get_CHAR() antlr.Token

	// Get_TRUE returns the _TRUE token.
	Get_TRUE() antlr.Token

	// Get_FALSE returns the _FALSE token.
	Get_FALSE() antlr.Token

	// Set_NUMBER sets the _NUMBER token.
	Set_NUMBER(antlr.Token)

	// Set_FLOAT sets the _FLOAT token.
	Set_FLOAT(antlr.Token)

	// Set_CHAR sets the _CHAR token.
	Set_CHAR(antlr.Token)

	// Set_TRUE sets the _TRUE token.
	Set_TRUE(antlr.Token)

	// Set_FALSE sets the _FALSE token.
	Set_FALSE(antlr.Token)

	// Get_strings returns the _strings rule contexts.
	Get_strings() IStringsContext

	// GetList returns the list rule contexts.
	GetList() IListIDArrayContext

	// Set_strings sets the _strings rule contexts.
	Set_strings(IStringsContext)

	// SetList sets the list rule contexts.
	SetList(IListIDArrayContext)

	// GetP returns the p attribute.
	GetP() interfaces.Expresion

	// SetP sets the p attribute.
	SetP(interfaces.Expresion)

	// Getter signatures
	NUMBER() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	Strings() IStringsContext
	CHAR() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	ListIDArray() IListIDArrayContext

	// IsPrimitivoContext differentiates from other interfaces.
	IsPrimitivoContext()
}

type PrimitivoContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	p        interfaces.Expresion
	_NUMBER  antlr.Token
	_FLOAT   antlr.Token
	_strings IStringsContext
	_CHAR    antlr.Token
	_TRUE    antlr.Token
	_FALSE   antlr.Token
	list     IListIDArrayContext
}

func NewEmptyPrimitivoContext() *PrimitivoContext {
	var p = new(PrimitivoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_primitivo
	return p
}

func InitEmptyPrimitivoContext(p *PrimitivoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_primitivo
}

func (*PrimitivoContext) IsPrimitivoContext() {}

func NewPrimitivoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitivoContext {
	var p = new(PrimitivoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_primitivo

	return p
}

func (s *PrimitivoContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitivoContext) Get_NUMBER() antlr.Token { return s._NUMBER }

func (s *PrimitivoContext) Get_FLOAT() antlr.Token { return s._FLOAT }

func (s *PrimitivoContext) Get_CHAR() antlr.Token { return s._CHAR }

func (s *PrimitivoContext) Get_TRUE() antlr.Token { return s._TRUE }

func (s *PrimitivoContext) Get_FALSE() antlr.Token { return s._FALSE }

func (s *PrimitivoContext) Set_NUMBER(v antlr.Token) { s._NUMBER = v }

func (s *PrimitivoContext) Set_FLOAT(v antlr.Token) { s._FLOAT = v }

func (s *PrimitivoContext) Set_CHAR(v antlr.Token) { s._CHAR = v }

func (s *PrimitivoContext) Set_TRUE(v antlr.Token) { s._TRUE = v }

func (s *PrimitivoContext) Set_FALSE(v antlr.Token) { s._FALSE = v }

func (s *PrimitivoContext) Get_strings() IStringsContext { return s._strings }

func (s *PrimitivoContext) GetList() IListIDArrayContext { return s.list }

func (s *PrimitivoContext) Set_strings(v IStringsContext) { s._strings = v }

func (s *PrimitivoContext) SetList(v IListIDArrayContext) { s.list = v }

func (s *PrimitivoContext) GetP() interfaces.Expresion { return s.p }

func (s *PrimitivoContext) SetP(v interfaces.Expresion) { s.p = v }

func (s *PrimitivoContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarNUMBER, 0)
}

func (s *PrimitivoContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(swiftgrammarFLOAT, 0)
}

func (s *PrimitivoContext) Strings() IStringsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringsContext)
}

func (s *PrimitivoContext) CHAR() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCHAR, 0)
}

func (s *PrimitivoContext) TRUE() antlr.TerminalNode {
	return s.GetToken(swiftgrammarTRUE, 0)
}

func (s *PrimitivoContext) FALSE() antlr.TerminalNode {
	return s.GetToken(swiftgrammarFALSE, 0)
}

func (s *PrimitivoContext) ListIDArray() IListIDArrayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListIDArrayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListIDArrayContext)
}

func (s *PrimitivoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitivoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitivoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterPrimitivo(s)
	}
}

func (s *PrimitivoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitPrimitivo(s)
	}
}

func (p *swiftgrammar) Primitivo() (localctx IPrimitivoContext) {
	localctx = NewPrimitivoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, swiftgrammarRULE_primitivo)
	p.SetState(1175)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case swiftgrammarNUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1159)

			var _m = p.Match(swiftgrammarNUMBER)

			localctx.(*PrimitivoContext)._NUMBER = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		num, err := strconv.Atoi((func() string {
			if localctx.(*PrimitivoContext).Get_NUMBER() == nil {
				return ""
			} else {
				return localctx.(*PrimitivoContext).Get_NUMBER().GetText()
			}
		}()))
		if err != nil {
			fmt.Println(err)
		}
		localctx.(*PrimitivoContext).p = expresion.NewPrimitivo(num, interfaces.INTEGER, (func() int {
			if localctx.(*PrimitivoContext).Get_NUMBER() == nil {
				return 0
			} else {
				return localctx.(*PrimitivoContext).Get_NUMBER().GetLine()
			}
		}()), localctx.(*PrimitivoContext).Get_NUMBER().GetColumn())

	case swiftgrammarFLOAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1161)

			var _m = p.Match(swiftgrammarFLOAT)

			localctx.(*PrimitivoContext)._FLOAT = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		num, err := strconv.ParseFloat((func() string {
			if localctx.(*PrimitivoContext).Get_FLOAT() == nil {
				return ""
			} else {
				return localctx.(*PrimitivoContext).Get_FLOAT().GetText()
			}
		}()), 64)
		if err != nil {
			fmt.Println(err)
		}
		localctx.(*PrimitivoContext).p = expresion.NewPrimitivo(num, interfaces.FLOAT, (func() int {
			if localctx.(*PrimitivoContext).Get_FLOAT() == nil {
				return 0
			} else {
				return localctx.(*PrimitivoContext).Get_FLOAT().GetLine()
			}
		}()), localctx.(*PrimitivoContext).Get_FLOAT().GetColumn())

	case swiftgrammarT_STRING, swiftgrammarSTRING, swiftgrammarAMP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1163)

			var _x = p.Strings()

			localctx.(*PrimitivoContext)._strings = _x
		}
		localctx.(*PrimitivoContext).p = localctx.(*PrimitivoContext).Get_strings().GetP()

	case swiftgrammarCHAR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1166)

			var _m = p.Match(swiftgrammarCHAR)

			localctx.(*PrimitivoContext)._CHAR = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		chr := (func() string {
			if localctx.(*PrimitivoContext).Get_CHAR() == nil {
				return ""
			} else {
				return localctx.(*PrimitivoContext).Get_CHAR().GetText()
			}
		}())
		localctx.(*PrimitivoContext).p = expresion.NewPrimitivo(chr[1:len(chr)-1], interfaces.CHAR, (func() int {
			if localctx.(*PrimitivoContext).Get_CHAR() == nil {
				return 0
			} else {
				return localctx.(*PrimitivoContext).Get_CHAR().GetLine()
			}
		}()), (func() int {
			if localctx.(*PrimitivoContext).Get_CHAR() == nil {
				return 0
			} else {
				return localctx.(*PrimitivoContext).Get_CHAR().GetColumn()
			}
		}()))

	case swiftgrammarTRUE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1168)

			var _m = p.Match(swiftgrammarTRUE)

			localctx.(*PrimitivoContext)._TRUE = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*PrimitivoContext).p = expresion.NewPrimitivo(true, interfaces.BOOLEAN, (func() int {
			if localctx.(*PrimitivoContext).Get_TRUE() == nil {
				return 0
			} else {
				return localctx.(*PrimitivoContext).Get_TRUE().GetLine()
			}
		}()), localctx.(*PrimitivoContext).Get_TRUE().GetColumn())

	case swiftgrammarFALSE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1170)

			var _m = p.Match(swiftgrammarFALSE)

			localctx.(*PrimitivoContext)._FALSE = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*PrimitivoContext).p = expresion.NewPrimitivo(false, interfaces.BOOLEAN, (func() int {
			if localctx.(*PrimitivoContext).Get_FALSE() == nil {
				return 0
			} else {
				return localctx.(*PrimitivoContext).Get_FALSE().GetLine()
			}
		}()), localctx.(*PrimitivoContext).Get_FALSE().GetColumn())

	case swiftgrammarID:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1172)

			var _x = p.listIDArray(0)

			localctx.(*PrimitivoContext).list = _x
		}
		localctx.(*PrimitivoContext).p = localctx.(*PrimitivoContext).GetList().GetP()

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListIDArrayContext is an interface to support dynamic dispatch.
type IListIDArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Get_CORIZQ returns the _CORIZQ token.
	Get_CORIZQ() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Set_CORIZQ sets the _CORIZQ token.
	Set_CORIZQ(antlr.Token)

	// GetList returns the list rule contexts.
	GetList() IListIDArrayContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// SetList sets the list rule contexts.
	SetList(IListIDArrayContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetP returns the p attribute.
	GetP() interfaces.Expresion

	// SetP sets the p attribute.
	SetP(interfaces.Expresion)

	// Getter signatures
	ID() antlr.TerminalNode
	CORIZQ() antlr.TerminalNode
	Expression() IExpressionContext
	CORDER() antlr.TerminalNode
	ListIDArray() IListIDArrayContext
	PUNTO() antlr.TerminalNode

	// IsListIDArrayContext differentiates from other interfaces.
	IsListIDArrayContext()
}

type ListIDArrayContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	p           interfaces.Expresion
	list        IListIDArrayContext
	_ID         antlr.Token
	_CORIZQ     antlr.Token
	_expression IExpressionContext
}

func NewEmptyListIDArrayContext() *ListIDArrayContext {
	var p = new(ListIDArrayContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_listIDArray
	return p
}

func InitEmptyListIDArrayContext(p *ListIDArrayContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_listIDArray
}

func (*ListIDArrayContext) IsListIDArrayContext() {}

func NewListIDArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListIDArrayContext {
	var p = new(ListIDArrayContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_listIDArray

	return p
}

func (s *ListIDArrayContext) GetParser() antlr.Parser { return s.parser }

func (s *ListIDArrayContext) Get_ID() antlr.Token { return s._ID }

func (s *ListIDArrayContext) Get_CORIZQ() antlr.Token { return s._CORIZQ }

func (s *ListIDArrayContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *ListIDArrayContext) Set_CORIZQ(v antlr.Token) { s._CORIZQ = v }

func (s *ListIDArrayContext) GetList() IListIDArrayContext { return s.list }

func (s *ListIDArrayContext) Get_expression() IExpressionContext { return s._expression }

func (s *ListIDArrayContext) SetList(v IListIDArrayContext) { s.list = v }

func (s *ListIDArrayContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *ListIDArrayContext) GetP() interfaces.Expresion { return s.p }

func (s *ListIDArrayContext) SetP(v interfaces.Expresion) { s.p = v }

func (s *ListIDArrayContext) ID() antlr.TerminalNode {
	return s.GetToken(swiftgrammarID, 0)
}

func (s *ListIDArrayContext) CORIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORIZQ, 0)
}

func (s *ListIDArrayContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListIDArrayContext) CORDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarCORDER, 0)
}

func (s *ListIDArrayContext) ListIDArray() IListIDArrayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListIDArrayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListIDArrayContext)
}

func (s *ListIDArrayContext) PUNTO() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPUNTO, 0)
}

func (s *ListIDArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListIDArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListIDArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterListIDArray(s)
	}
}

func (s *ListIDArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitListIDArray(s)
	}
}

func (p *swiftgrammar) ListIDArray() (localctx IListIDArrayContext) {
	return p.listIDArray(0)
}

func (p *swiftgrammar) listIDArray(_p int) (localctx IListIDArrayContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewListIDArrayContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListIDArrayContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 114
	p.EnterRecursionRule(localctx, 114, swiftgrammarRULE_listIDArray, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1178)

		var _m = p.Match(swiftgrammarID)

		localctx.(*ListIDArrayContext)._ID = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	localctx.(*ListIDArrayContext).p = expresion.NewIdentificador((func() string {
		if localctx.(*ListIDArrayContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*ListIDArrayContext).Get_ID().GetText()
		}
	}()), (func() int {
		if localctx.(*ListIDArrayContext).Get_ID() == nil {
			return 0
		} else {
			return localctx.(*ListIDArrayContext).Get_ID().GetLine()
		}
	}()), localctx.(*ListIDArrayContext).Get_ID().GetColumn())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1193)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1191)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) {
			case 1:
				localctx = NewListIDArrayContext(p, _parentctx, _parentState)
				localctx.(*ListIDArrayContext).list = _prevctx
				p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_listIDArray)
				p.SetState(1181)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1182)

					var _m = p.Match(swiftgrammarCORIZQ)

					localctx.(*ListIDArrayContext)._CORIZQ = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1183)

					var _x = p.expression(0)

					localctx.(*ListIDArrayContext)._expression = _x
				}
				{
					p.SetState(1184)
					p.Match(swiftgrammarCORDER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*ListIDArrayContext).p = expresion.NewArrayAccess(localctx.(*ListIDArrayContext).GetList().GetP(), localctx.(*ListIDArrayContext).Get_expression().GetP(), (func() int {
					if localctx.(*ListIDArrayContext).Get_CORIZQ() == nil {
						return 0
					} else {
						return localctx.(*ListIDArrayContext).Get_CORIZQ().GetLine()
					}
				}()), (func() int {
					if localctx.(*ListIDArrayContext).Get_CORIZQ() == nil {
						return 0
					} else {
						return localctx.(*ListIDArrayContext).Get_CORIZQ().GetColumn()
					}
				}()))

			case 2:
				localctx = NewListIDArrayContext(p, _parentctx, _parentState)
				localctx.(*ListIDArrayContext).list = _prevctx
				p.PushNewRecursionContext(localctx, _startState, swiftgrammarRULE_listIDArray)
				p.SetState(1187)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1188)
					p.Match(swiftgrammarPUNTO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1189)

					var _m = p.Match(swiftgrammarID)

					localctx.(*ListIDArrayContext)._ID = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*ListIDArrayContext).p = expresion.NewStructAccess(localctx.(*ListIDArrayContext).GetList().GetP(), (func() string {
					if localctx.(*ListIDArrayContext).Get_ID() == nil {
						return ""
					} else {
						return localctx.(*ListIDArrayContext).Get_ID().GetText()
					}
				}()), (func() antlr.Token {
					if localctx.(*ListIDArrayContext).GetList() == nil {
						return nil
					} else {
						return localctx.(*ListIDArrayContext).GetList().GetStart()
					}
				}()).GetLine(), (func() antlr.Token {
					if localctx.(*ListIDArrayContext).GetList() == nil {
						return nil
					} else {
						return localctx.(*ListIDArrayContext).GetList().GetStart()
					}
				}()).GetColumn())

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1195)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringsContext is an interface to support dynamic dispatch.
type IStringsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_STRING returns the _STRING token.
	Get_STRING() antlr.Token

	// Set_STRING sets the _STRING token.
	Set_STRING(antlr.Token)

	// GetP returns the p attribute.
	GetP() interfaces.Expresion

	// SetP sets the p attribute.
	SetP(interfaces.Expresion)

	// Getter signatures
	T_STRING() antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	STRING() antlr.TerminalNode
	PARDER() antlr.TerminalNode
	AllAMP() []antlr.TerminalNode
	AMP(i int) antlr.TerminalNode

	// IsStringsContext differentiates from other interfaces.
	IsStringsContext()
}

type StringsContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	p       interfaces.Expresion
	_STRING antlr.Token
}

func NewEmptyStringsContext() *StringsContext {
	var p = new(StringsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_strings
	return p
}

func InitEmptyStringsContext(p *StringsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = swiftgrammarRULE_strings
}

func (*StringsContext) IsStringsContext() {}

func NewStringsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringsContext {
	var p = new(StringsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = swiftgrammarRULE_strings

	return p
}

func (s *StringsContext) GetParser() antlr.Parser { return s.parser }

func (s *StringsContext) Get_STRING() antlr.Token { return s._STRING }

func (s *StringsContext) Set_STRING(v antlr.Token) { s._STRING = v }

func (s *StringsContext) GetP() interfaces.Expresion { return s.p }

func (s *StringsContext) SetP(v interfaces.Expresion) { s.p = v }

func (s *StringsContext) T_STRING() antlr.TerminalNode {
	return s.GetToken(swiftgrammarT_STRING, 0)
}

func (s *StringsContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARIZQ, 0)
}

func (s *StringsContext) STRING() antlr.TerminalNode {
	return s.GetToken(swiftgrammarSTRING, 0)
}

func (s *StringsContext) PARDER() antlr.TerminalNode {
	return s.GetToken(swiftgrammarPARDER, 0)
}

func (s *StringsContext) AllAMP() []antlr.TerminalNode {
	return s.GetTokens(swiftgrammarAMP)
}

func (s *StringsContext) AMP(i int) antlr.TerminalNode {
	return s.GetToken(swiftgrammarAMP, i)
}

func (s *StringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.EnterStrings(s)
	}
}

func (s *StringsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(swiftgrammarListener); ok {
		listenerT.ExitStrings(s)
	}
}

func (p *swiftgrammar) Strings() (localctx IStringsContext) {
	localctx = NewStringsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, swiftgrammarRULE_strings)
	var _la int

	p.SetState(1213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case swiftgrammarAMP:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1197)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == swiftgrammarAMP {
			{
				p.SetState(1196)
				p.Match(swiftgrammarAMP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1199)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1201)
			p.Match(swiftgrammarT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1202)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1203)

			var _m = p.Match(swiftgrammarSTRING)

			localctx.(*StringsContext)._STRING = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1204)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		str := (func() string {
			if localctx.(*StringsContext).Get_STRING() == nil {
				return ""
			} else {
				return localctx.(*StringsContext).Get_STRING().GetText()
			}
		}())[1 : len((func() string {
			if localctx.(*StringsContext).Get_STRING() == nil {
				return ""
			} else {
				return localctx.(*StringsContext).Get_STRING().GetText()
			}
		}()))-1]
		localctx.(*StringsContext).p = expresion.NewPrimitivo(str, interfaces.STR, (func() int {
			if localctx.(*StringsContext).Get_STRING() == nil {
				return 0
			} else {
				return localctx.(*StringsContext).Get_STRING().GetLine()
			}
		}()), localctx.(*StringsContext).Get_STRING().GetColumn())

	case swiftgrammarT_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1206)
			p.Match(swiftgrammarT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1207)
			p.Match(swiftgrammarPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1208)

			var _m = p.Match(swiftgrammarSTRING)

			localctx.(*StringsContext)._STRING = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1209)
			p.Match(swiftgrammarPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		str := (func() string {
			if localctx.(*StringsContext).Get_STRING() == nil {
				return ""
			} else {
				return localctx.(*StringsContext).Get_STRING().GetText()
			}
		}())[1 : len((func() string {
			if localctx.(*StringsContext).Get_STRING() == nil {
				return ""
			} else {
				return localctx.(*StringsContext).Get_STRING().GetText()
			}
		}()))-1]
		localctx.(*StringsContext).p = expresion.NewPrimitivo(str, interfaces.STRING, (func() int {
			if localctx.(*StringsContext).Get_STRING() == nil {
				return 0
			} else {
				return localctx.(*StringsContext).Get_STRING().GetLine()
			}
		}()), localctx.(*StringsContext).Get_STRING().GetColumn())

	case swiftgrammarSTRING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1211)

			var _m = p.Match(swiftgrammarSTRING)

			localctx.(*StringsContext)._STRING = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		str := (func() string {
			if localctx.(*StringsContext).Get_STRING() == nil {
				return ""
			} else {
				return localctx.(*StringsContext).Get_STRING().GetText()
			}
		}())[1 : len((func() string {
			if localctx.(*StringsContext).Get_STRING() == nil {
				return ""
			} else {
				return localctx.(*StringsContext).Get_STRING().GetText()
			}
		}()))-1]
		localctx.(*StringsContext).p = expresion.NewPrimitivo(str, interfaces.STR, (func() int {
			if localctx.(*StringsContext).Get_STRING() == nil {
				return 0
			} else {
				return localctx.(*StringsContext).Get_STRING().GetLine()
			}
		}()), localctx.(*StringsContext).Get_STRING().GetColumn())

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *swiftgrammar) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 2:
		var t *ListaglobalContext = nil
		if localctx != nil {
			t = localctx.(*ListaglobalContext)
		}
		return p.Listaglobal_Sempred(t, predIndex)

	case 6:
		var t *Params_declarContext = nil
		if localctx != nil {
			t = localctx.(*Params_declarContext)
		}
		return p.Params_declar_Sempred(t, predIndex)

	case 13:
		var t *Lista_structContext = nil
		if localctx != nil {
			t = localctx.(*Lista_structContext)
		}
		return p.Lista_struct_Sempred(t, predIndex)

	case 22:
		var t *ListParamsContext = nil
		if localctx != nil {
			t = localctx.(*ListParamsContext)
		}
		return p.ListParams_Sempred(t, predIndex)

	case 23:
		var t *ListParamsCallContext = nil
		if localctx != nil {
			t = localctx.(*ListParamsCallContext)
		}
		return p.ListParamsCall_Sempred(t, predIndex)

	case 32:
		var t *L_AccessStructContext = nil
		if localctx != nil {
			t = localctx.(*L_AccessStructContext)
		}
		return p.L_AccessStruct_Sempred(t, predIndex)

	case 33:
		var t *List_indexContext = nil
		if localctx != nil {
			t = localctx.(*List_indexContext)
		}
		return p.List_index_Sempred(t, predIndex)

	case 42:
		var t *Match_brazosContext = nil
		if localctx != nil {
			t = localctx.(*Match_brazosContext)
		}
		return p.Match_brazos_Sempred(t, predIndex)

	case 43:
		var t *Match_brazos_expContext = nil
		if localctx != nil {
			t = localctx.(*Match_brazos_expContext)
		}
		return p.Match_brazos_exp_Sempred(t, predIndex)

	case 46:
		var t *ListaOpcionesContext = nil
		if localctx != nil {
			t = localctx.(*ListaOpcionesContext)
		}
		return p.ListaOpciones_Sempred(t, predIndex)

	case 51:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 52:
		var t *Expr_aritContext = nil
		if localctx != nil {
			t = localctx.(*Expr_aritContext)
		}
		return p.Expr_arit_Sempred(t, predIndex)

	case 55:
		var t *L_StructExpContext = nil
		if localctx != nil {
			t = localctx.(*L_StructExpContext)
		}
		return p.L_StructExp_Sempred(t, predIndex)

	case 57:
		var t *ListIDArrayContext = nil
		if localctx != nil {
			t = localctx.(*ListIDArrayContext)
		}
		return p.ListIDArray_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *swiftgrammar) Listaglobal_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *swiftgrammar) Params_declar_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *swiftgrammar) Lista_struct_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *swiftgrammar) ListParams_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *swiftgrammar) ListParamsCall_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *swiftgrammar) L_AccessStruct_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *swiftgrammar) List_index_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *swiftgrammar) Match_brazos_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *swiftgrammar) Match_brazos_exp_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *swiftgrammar) ListaOpciones_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 12:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *swiftgrammar) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 13:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *swiftgrammar) Expr_arit_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 14:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 20)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *swiftgrammar) L_StructExp_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 20:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *swiftgrammar) ListIDArray_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 21:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 22:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
